// Generated by CommonJS Everywhere 0.9.4
(function (global) {
  function require(file, parentModule) {
    if ({}.hasOwnProperty.call(require.cache, file))
      return require.cache[file];
    var resolved = require.resolve(file);
    if (!resolved)
      throw new Error('Failed to resolve module ' + file);
    var module$ = {
        id: file,
        require: require,
        filename: file,
        exports: {},
        loaded: false,
        parent: parentModule,
        children: []
      };
    if (parentModule)
      parentModule.children.push(module$);
    var dirname = file.slice(0, file.lastIndexOf('/') + 1);
    require.cache[file] = module$.exports;
    resolved.call(module$.exports, module$, module$.exports, dirname, file);
    module$.loaded = true;
    return require.cache[file] = module$.exports;
  }
  require.modules = {};
  require.cache = {};
  require.resolve = function (file) {
    return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;
  };
  require.define = function (file, fn) {
    require.modules[file] = fn;
  };
  var process = function () {
      var cwd = '/';
      return {
        title: 'browser',
        version: 'v0.8.9',
        browser: true,
        env: {},
        argv: [],
        nextTick: global.setImmediate || function (fn) {
          setTimeout(fn, 0);
        },
        cwd: function () {
          return cwd;
        },
        chdir: function (dir) {
          cwd = dir;
        }
      };
    }();
  require.define('/main.coffee', function (module, exports, __dirname, __filename) {
    var _, canvas, components, datatable, design, Dots, Exp, html, include, layout, lib, libs, Psy, Q, samplers, stimresp, utils;
    Exp = require('/elements.js', module);
    Psy = require('/psycloud.js', module);
    Dots = require('/dotmotion.js', module);
    utils = require('/utils.js', module);
    datatable = require('/datatable.js', module);
    samplers = require('/samplers.js', module);
    stimresp = require('/stimresp.js', module);
    layout = require('/layout.js', module);
    design = require('/design.js', module);
    canvas = require('/components/canvas/canvas.js', module);
    html = require('/components/html/html.js', module);
    components = require('/components/components.js', module);
    _ = require('/../node_modules/lodash/dist/lodash.js', module);
    Q = require('/../node_modules/q/q.js', module);
    include = function (lib) {
      return function (accum$) {
        var key, value;
        for (key in lib) {
          value = lib[key];
          accum$.push(exports[key] = value);
        }
        return accum$;
      }.call(this, []);
    };
    libs = [
      Exp,
      Psy,
      Dots,
      utils,
      datatable,
      samplers,
      stimresp,
      layout,
      design,
      canvas,
      html,
      components
    ];
    for (var i$ = 0, length$ = libs.length; i$ < length$; ++i$) {
      lib = libs[i$];
      include(lib);
    }
    exports.Q = Q;
    exports._ = _;
  });
  require.define('/../node_modules/q/q.js', function (module, exports, __dirname, __filename) {
    (function (definition) {
      if (typeof bootstrap === 'function') {
        bootstrap('promise', definition);
      } else if (typeof exports === 'object') {
        module.exports = definition();
      } else if (typeof define === 'function' && define.amd) {
        define(definition);
      } else if (typeof ses !== 'undefined') {
        if (!ses.ok()) {
          return;
        } else {
          ses.makeQ = definition;
        }
      } else {
        Q = definition();
      }
    }(function () {
      'use strict';
      var qStartingLine = captureLine();
      var qFileName;
      var noop = function () {
      };
      var nextTick;
      if (typeof process !== 'undefined') {
        nextTick = process.nextTick;
      } else if (typeof setImmediate === 'function') {
        if (typeof window !== 'undefined') {
          nextTick = setImmediate.bind(window);
        } else {
          nextTick = setImmediate;
        }
      } else {
        (function () {
          var head = {
              task: void 0,
              next: null
            }, tail = head, maxPendingTicks = 2, pendingTicks = 0, queuedTasks = 0, usedTicks = 0, requestTick;
          function onTick() {
            --pendingTicks;
            if (++usedTicks >= maxPendingTicks) {
              usedTicks = 0;
              maxPendingTicks *= 4;
              var expectedTicks = queuedTasks && Math.min(queuedTasks - 1, maxPendingTicks);
              while (pendingTicks < expectedTicks) {
                ++pendingTicks;
                requestTick();
              }
            }
            while (queuedTasks) {
              --queuedTasks;
              head = head.next;
              var task = head.task;
              head.task = void 0;
              task();
            }
            usedTicks = 0;
          }
          nextTick = function (task) {
            tail = tail.next = {
              task: task,
              next: null
            };
            if (pendingTicks < ++queuedTasks && pendingTicks < maxPendingTicks) {
              ++pendingTicks;
              requestTick();
            }
          };
          if (typeof MessageChannel !== 'undefined') {
            var channel = new MessageChannel;
            channel.port1.onmessage = onTick;
            requestTick = function () {
              channel.port2.postMessage(0);
            };
          } else {
            requestTick = function () {
              setTimeout(onTick, 0);
            };
          }
        }());
      }
      function uncurryThis(f) {
        var call = Function.call;
        return function () {
          return call.apply(f, arguments);
        };
      }
      var array_slice = uncurryThis(Array.prototype.slice);
      var array_reduce = uncurryThis(Array.prototype.reduce || function (callback, basis) {
          var index = 0, length = this.length;
          if (arguments.length === 1) {
            do {
              if (index in this) {
                basis = this[index++];
                break;
              }
              if (++index >= length) {
                throw new TypeError;
              }
            } while (1);
          }
          for (; index < length; index++) {
            if (index in this) {
              basis = callback(basis, this[index], index);
            }
          }
          return basis;
        });
      var array_indexOf = uncurryThis(Array.prototype.indexOf || function (value) {
          for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
              return i;
            }
          }
          return -1;
        });
      var array_map = uncurryThis(Array.prototype.map || function (callback, thisp) {
          var self = this;
          var collect = [];
          array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
          }, void 0);
          return collect;
        });
      var object_create = Object.create || function (prototype) {
          function Type() {
          }
          Type.prototype = prototype;
          return new Type;
        };
      var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
      var object_keys = Object.keys || function (object) {
          var keys = [];
          for (var key in object) {
            if (object_hasOwnProperty(object, key)) {
              keys.push(key);
            }
          }
          return keys;
        };
      var object_toString = uncurryThis(Object.prototype.toString);
      function isStopIteration(exception) {
        return object_toString(exception) === '[object StopIteration]' || exception instanceof QReturnValue;
      }
      var QReturnValue;
      if (typeof ReturnValue !== 'undefined') {
        QReturnValue = ReturnValue;
      } else {
        QReturnValue = function (value) {
          this.value = value;
        };
      }
      Q.longStackJumpLimit = 1;
      var STACK_JUMP_SEPARATOR = 'From previous event:';
      function makeStackTraceLong(error, promise) {
        if (promise.stack && typeof error === 'object' && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {
          error.stack = filterStackString(error.stack) + '\n' + STACK_JUMP_SEPARATOR + '\n' + filterStackString(promise.stack);
        }
      }
      function filterStackString(stackString) {
        var lines = stackString.split('\n');
        var desiredLines = [];
        for (var i = 0; i < lines.length; ++i) {
          var line = lines[i];
          if (!isInternalFrame(line) && !isNodeFrame(line)) {
            desiredLines.push(line);
          }
        }
        return desiredLines.join('\n');
      }
      function isNodeFrame(stackLine) {
        return stackLine.indexOf('(module.js:') !== -1 || stackLine.indexOf('(node.js:') !== -1;
      }
      function isInternalFrame(stackLine) {
        var pieces = /at .+ \((.*):(\d+):\d+\)/.exec(stackLine);
        if (!pieces) {
          return false;
        }
        var fileName = pieces[1];
        var lineNumber = pieces[2];
        return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;
      }
      function captureLine() {
        if (Error.captureStackTrace) {
          var fileName, lineNumber;
          var oldPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = function (error, frames) {
            fileName = frames[1].getFileName();
            lineNumber = frames[1].getLineNumber();
          };
          new Error().stack;
          Error.prepareStackTrace = oldPrepareStackTrace;
          qFileName = fileName;
          return lineNumber;
        }
      }
      function deprecate(callback, name, alternative) {
        return function () {
          if (typeof console !== 'undefined' && typeof console.warn === 'function') {
            console.warn(name + ' is deprecated, use ' + alternative + ' instead.', new Error('').stack);
          }
          return callback.apply(callback, arguments);
        };
      }
      function Q(value) {
        return resolve(value);
      }
      Q.nextTick = nextTick;
      Q.defer = defer;
      function defer() {
        var pending = [], progressListeners = [], value;
        var deferred = object_create(defer.prototype);
        var promise = object_create(makePromise.prototype);
        promise.promiseDispatch = function (resolve, op, operands) {
          var args = array_slice(arguments);
          if (pending) {
            pending.push(args);
            if (op === 'when' && operands[1]) {
              progressListeners.push(operands[1]);
            }
          } else {
            nextTick(function () {
              value.promiseDispatch.apply(value, args);
            });
          }
        };
        promise.valueOf = function () {
          if (pending) {
            return promise;
          }
          var nearer = valueOf(value);
          if (isPromise(nearer)) {
            value = nearer;
          }
          return nearer;
        };
        if (Error.captureStackTrace && Q.longStackJumpLimit > 0) {
          Error.captureStackTrace(promise, defer);
          promise.stack = promise.stack.substring(promise.stack.indexOf('\n') + 1);
        }
        function become(resolvedValue) {
          if (!pending) {
            return;
          }
          value = resolve(resolvedValue);
          array_reduce(pending, function (undefined, pending) {
            nextTick(function () {
              value.promiseDispatch.apply(value, pending);
            });
          }, void 0);
          pending = void 0;
          progressListeners = void 0;
        }
        deferred.promise = promise;
        deferred.resolve = become;
        deferred.fulfill = function (value) {
          become(fulfill(value));
        };
        deferred.reject = function (exception) {
          become(reject(exception));
        };
        deferred.notify = function (progress) {
          if (pending) {
            array_reduce(progressListeners, function (undefined, progressListener) {
              nextTick(function () {
                progressListener(progress);
              });
            }, void 0);
          }
        };
        return deferred;
      }
      defer.prototype.makeNodeResolver = function () {
        var self = this;
        return function (error, value) {
          if (error) {
            self.reject(error);
          } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
          } else {
            self.resolve(value);
          }
        };
      };
      Q.promise = promise;
      function promise(makePromise) {
        var deferred = defer();
        fcall(makePromise, deferred.resolve, deferred.reject, deferred.notify).fail(deferred.reject);
        return deferred.promise;
      }
      Q.makePromise = makePromise;
      function makePromise(descriptor, fallback, valueOf, exception, isException) {
        if (fallback === void 0) {
          fallback = function (op) {
            return reject(new Error('Promise does not support operation: ' + op));
          };
        }
        var promise = object_create(makePromise.prototype);
        promise.promiseDispatch = function (resolve, op, args) {
          var result;
          try {
            if (descriptor[op]) {
              result = descriptor[op].apply(promise, args);
            } else {
              result = fallback.call(promise, op, args);
            }
          } catch (exception) {
            result = reject(exception);
          }
          if (resolve) {
            resolve(result);
          }
        };
        if (valueOf) {
          promise.valueOf = valueOf;
        }
        if (isException) {
          promise.exception = exception;
        }
        return promise;
      }
      makePromise.prototype.then = function (fulfilled, rejected, progressed) {
        return when(this, fulfilled, rejected, progressed);
      };
      makePromise.prototype.thenResolve = function (value) {
        return when(this, function () {
          return value;
        });
      };
      makePromise.prototype.thenReject = function (reason) {
        return when(this, function () {
          throw reason;
        });
      };
      array_reduce([
        'isFulfilled',
        'isRejected',
        'isPending',
        'dispatch',
        'when',
        'spread',
        'get',
        'put',
        'set',
        'del',
        'delete',
        'post',
        'send',
        'invoke',
        'keys',
        'fapply',
        'fcall',
        'fbind',
        'all',
        'allResolved',
        'timeout',
        'delay',
        'catch',
        'finally',
        'fail',
        'fin',
        'progress',
        'done',
        'nfcall',
        'nfapply',
        'nfbind',
        'denodeify',
        'nbind',
        'ncall',
        'napply',
        'nbind',
        'npost',
        'nsend',
        'ninvoke',
        'nodeify'
      ], function (undefined, name) {
        makePromise.prototype[name] = function () {
          return Q[name].apply(Q, [this].concat(array_slice(arguments)));
        };
      }, void 0);
      makePromise.prototype.toSource = function () {
        return this.toString();
      };
      makePromise.prototype.toString = function () {
        return '[object Promise]';
      };
      Q.nearer = valueOf;
      function valueOf(value) {
        if (isPromise(value)) {
          return value.valueOf();
        }
        return value;
      }
      Q.isPromise = isPromise;
      function isPromise(object) {
        return object && typeof object.promiseDispatch === 'function';
      }
      Q.isPromiseAlike = isPromiseAlike;
      function isPromiseAlike(object) {
        return object && typeof object.then === 'function';
      }
      Q.isPending = isPending;
      function isPending(object) {
        return !isFulfilled(object) && !isRejected(object);
      }
      Q.isFulfilled = isFulfilled;
      function isFulfilled(object) {
        return !isPromiseAlike(valueOf(object));
      }
      Q.isRejected = isRejected;
      function isRejected(object) {
        object = valueOf(object);
        return isPromise(object) && 'exception' in object;
      }
      var rejections = [];
      var errors = [];
      var errorsDisplayed;
      function displayErrors() {
        if (!errorsDisplayed && typeof window !== 'undefined' && !window.Touch && window.console) {
          console.log('Should be empty:', errors);
        }
        errorsDisplayed = true;
      }
      if (typeof process !== 'undefined' && process.on) {
        process.on('exit', function () {
          for (var i = 0; i < errors.length; i++) {
            var error = errors[i];
            if (error && typeof error.stack !== 'undefined') {
              console.warn('Unhandled rejected promise:', error.stack);
            } else {
              console.warn('Unhandled rejected promise (no stack):', error);
            }
          }
        });
      }
      Q.reject = reject;
      function reject(exception) {
        var rejection = makePromise({
            'when': function (rejected) {
              if (rejected) {
                var at = array_indexOf(rejections, this);
                if (at !== -1) {
                  errors.splice(at, 1);
                  rejections.splice(at, 1);
                }
              }
              return rejected ? rejected(exception) : this;
            }
          }, function fallback() {
            return reject(exception);
          }, function valueOf() {
            return this;
          }, exception, true);
        displayErrors();
        rejections.push(rejection);
        errors.push(exception);
        return rejection;
      }
      Q.fulfill = fulfill;
      function fulfill(object) {
        return makePromise({
          'when': function () {
            return object;
          },
          'get': function (name) {
            return object[name];
          },
          'set': function (name, value) {
            object[name] = value;
          },
          'delete': function (name) {
            delete object[name];
          },
          'post': function (name, args) {
            if (name == null) {
              return object.apply(void 0, args);
            } else {
              return object[name].apply(object, args);
            }
          },
          'apply': function (thisP, args) {
            return object.apply(thisP, args);
          },
          'keys': function () {
            return object_keys(object);
          }
        }, void 0, function valueOf() {
          return object;
        });
      }
      Q.resolve = resolve;
      function resolve(value) {
        if (isPromise(value)) {
          return value;
        }
        value = valueOf(value);
        if (isPromiseAlike(value)) {
          return coerce(value);
        } else {
          return fulfill(value);
        }
      }
      function coerce(promise) {
        var deferred = defer();
        nextTick(function () {
          try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
          } catch (exception) {
            deferred.reject(exception);
          }
        });
        return deferred.promise;
      }
      Q.master = master;
      function master(object) {
        return makePromise({
          'isDef': function () {
          }
        }, function fallback(op, args) {
          return dispatch(object, op, args);
        }, function () {
          return valueOf(object);
        });
      }
      Q.when = when;
      function when(value, fulfilled, rejected, progressed) {
        var deferred = defer();
        var done = false;
        function _fulfilled(value) {
          try {
            return typeof fulfilled === 'function' ? fulfilled(value) : value;
          } catch (exception) {
            return reject(exception);
          }
        }
        function _rejected(exception) {
          if (typeof rejected === 'function') {
            makeStackTraceLong(exception, resolvedValue);
            try {
              return rejected(exception);
            } catch (newException) {
              return reject(newException);
            }
          }
          return reject(exception);
        }
        function _progressed(value) {
          return typeof progressed === 'function' ? progressed(value) : value;
        }
        var resolvedValue = resolve(value);
        nextTick(function () {
          resolvedValue.promiseDispatch(function (value) {
            if (done) {
              return;
            }
            done = true;
            deferred.resolve(_fulfilled(value));
          }, 'when', [function (exception) {
              if (done) {
                return;
              }
              done = true;
              deferred.resolve(_rejected(exception));
            }]);
        });
        resolvedValue.promiseDispatch(void 0, 'when', [
          void 0,
          function (value) {
            var newValue;
            var threw = false;
            try {
              newValue = _progressed(value);
            } catch (e) {
              threw = true;
              if (Q.onerror) {
                Q.onerror(e);
              } else {
                throw e;
              }
            }
            if (!threw) {
              deferred.notify(newValue);
            }
          }
        ]);
        return deferred.promise;
      }
      Q.spread = spread;
      function spread(promise, fulfilled, rejected) {
        return when(promise, function (valuesOrPromises) {
          return all(valuesOrPromises).then(function (values) {
            return fulfilled.apply(void 0, values);
          }, rejected);
        }, rejected);
      }
      Q.async = async;
      function async(makeGenerator) {
        return function () {
          function continuer(verb, arg) {
            var result;
            try {
              result = generator[verb](arg);
            } catch (exception) {
              if (isStopIteration(exception)) {
                return exception.value;
              } else {
                return reject(exception);
              }
            }
            return when(result, callback, errback);
          }
          var generator = makeGenerator.apply(this, arguments);
          var callback = continuer.bind(continuer, 'send');
          var errback = continuer.bind(continuer, 'throw');
          return callback();
        };
      }
      Q['return'] = _return;
      function _return(value) {
        throw new QReturnValue(value);
      }
      Q.promised = promised;
      function promised(callback) {
        return function () {
          return spread([
            this,
            all(arguments)
          ], function (self, args) {
            return callback.apply(self, args);
          });
        };
      }
      Q.dispatch = dispatch;
      function dispatch(object, op, args) {
        var deferred = defer();
        nextTick(function () {
          resolve(object).promiseDispatch(deferred.resolve, op, args);
        });
        return deferred.promise;
      }
      Q.dispatcher = dispatcher;
      function dispatcher(op) {
        return function (object) {
          var args = array_slice(arguments, 1);
          return dispatch(object, op, args);
        };
      }
      Q.get = dispatcher('get');
      Q.set = dispatcher('set');
      Q['delete'] = Q.del = dispatcher('delete');
      var post = Q.post = dispatcher('post');
      Q.send = send;
      Q.invoke = send;
      function send(value, name) {
        var args = array_slice(arguments, 2);
        return post(value, name, args);
      }
      Q.fapply = fapply;
      function fapply(value, args) {
        return dispatch(value, 'apply', [
          void 0,
          args
        ]);
      }
      Q['try'] = fcall;
      Q.fcall = fcall;
      function fcall(value) {
        var args = array_slice(arguments, 1);
        return fapply(value, args);
      }
      Q.fbind = fbind;
      function fbind(value) {
        var args = array_slice(arguments, 1);
        return function fbound() {
          var allArgs = args.concat(array_slice(arguments));
          return dispatch(value, 'apply', [
            this,
            allArgs
          ]);
        };
      }
      Q.keys = dispatcher('keys');
      Q.all = all;
      function all(promises) {
        return when(promises, function (promises) {
          var countDown = 0;
          var deferred = defer();
          array_reduce(promises, function (undefined, promise, index) {
            if (isFulfilled(promise)) {
              promises[index] = valueOf(promise);
            } else {
              ++countDown;
              when(promise, function (value) {
                promises[index] = value;
                if (--countDown === 0) {
                  deferred.resolve(promises);
                }
              }, deferred.reject);
            }
          }, void 0);
          if (countDown === 0) {
            deferred.resolve(promises);
          }
          return deferred.promise;
        });
      }
      Q.allResolved = allResolved;
      function allResolved(promises) {
        return when(promises, function (promises) {
          promises = array_map(promises, resolve);
          return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
          })), function () {
            return promises;
          });
        });
      }
      Q['catch'] = Q.fail = fail;
      function fail(promise, rejected) {
        return when(promise, void 0, rejected);
      }
      Q.progress = progress;
      function progress(promise, progressed) {
        return when(promise, void 0, void 0, progressed);
      }
      Q['finally'] = Q.fin = fin;
      function fin(promise, callback) {
        return when(promise, function (value) {
          return when(callback(), function () {
            return value;
          });
        }, function (exception) {
          return when(callback(), function () {
            return reject(exception);
          });
        });
      }
      Q.done = done;
      function done(promise, fulfilled, rejected, progress) {
        var onUnhandledError = function (error) {
          nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
              Q.onerror(error);
            } else {
              throw error;
            }
          });
        };
        var promiseToHandle = fulfilled || rejected || progress ? when(promise, fulfilled, rejected, progress) : promise;
        if (typeof process === 'object' && process && process.domain) {
          onUnhandledError = process.domain.bind(onUnhandledError);
        }
        fail(promiseToHandle, onUnhandledError);
      }
      Q.timeout = timeout;
      function timeout(promise, ms) {
        var deferred = defer();
        var timeoutId = setTimeout(function () {
            deferred.reject(new Error('Timed out after ' + ms + ' ms'));
          }, ms);
        when(promise, function (value) {
          clearTimeout(timeoutId);
          deferred.resolve(value);
        }, function (exception) {
          clearTimeout(timeoutId);
          deferred.reject(exception);
        });
        return deferred.promise;
      }
      Q.delay = delay;
      function delay(promise, timeout) {
        if (timeout === void 0) {
          timeout = promise;
          promise = void 0;
        }
        var deferred = defer();
        setTimeout(function () {
          deferred.resolve(promise);
        }, timeout);
        return deferred.promise;
      }
      Q.nfapply = nfapply;
      function nfapply(callback, args) {
        var nodeArgs = array_slice(args);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        fapply(callback, nodeArgs).fail(deferred.reject);
        return deferred.promise;
      }
      Q.nfcall = nfcall;
      function nfcall(callback) {
        var nodeArgs = array_slice(arguments, 1);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        fapply(callback, nodeArgs).fail(deferred.reject);
        return deferred.promise;
      }
      Q.nfbind = nfbind;
      Q.denodeify = Q.nfbind;
      function nfbind(callback) {
        var baseArgs = array_slice(arguments, 1);
        return function () {
          var nodeArgs = baseArgs.concat(array_slice(arguments));
          var deferred = defer();
          nodeArgs.push(deferred.makeNodeResolver());
          fapply(callback, nodeArgs).fail(deferred.reject);
          return deferred.promise;
        };
      }
      Q.nbind = nbind;
      function nbind(callback) {
        var baseArgs = array_slice(arguments, 1);
        return function () {
          var nodeArgs = baseArgs.concat(array_slice(arguments));
          var deferred = defer();
          nodeArgs.push(deferred.makeNodeResolver());
          var thisArg = this;
          function bound() {
            return callback.apply(thisArg, arguments);
          }
          fapply(bound, nodeArgs).fail(deferred.reject);
          return deferred.promise;
        };
      }
      Q.npost = npost;
      function npost(object, name, args) {
        var nodeArgs = array_slice(args || []);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        post(object, name, nodeArgs).fail(deferred.reject);
        return deferred.promise;
      }
      Q.nsend = nsend;
      Q.ninvoke = Q.nsend;
      function nsend(object, name) {
        var nodeArgs = array_slice(arguments, 2);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        post(object, name, nodeArgs).fail(deferred.reject);
        return deferred.promise;
      }
      Q.nodeify = nodeify;
      function nodeify(promise, nodeback) {
        if (nodeback) {
          promise.then(function (value) {
            nextTick(function () {
              nodeback(null, value);
            });
          }, function (error) {
            nextTick(function () {
              nodeback(error);
            });
          });
        } else {
          return promise;
        }
      }
      var qEndingLine = captureLine();
      return Q;
    }));
  });
  require.define('/../node_modules/lodash/dist/lodash.js', function (module, exports, __dirname, __filename) {
    ;
    (function (window) {
      var undefined;
      var arrayPool = [], objectPool = [];
      var idCounter = 0;
      var indicatorObject = {};
      var keyPrefix = +new Date + '';
      var largeArraySize = 75;
      var maxPoolSize = 40;
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reInterpolate = /<%=([\s\S]+?)%>/g;
      var reThis = (reThis = /\bthis\b/) && reThis.test(runInContext) && reThis;
      var whitespace = ' \t\x0B\f\xa0\ufeff' + '\n\r\u2028\u2029' + '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000';
      var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');
      var reNoMatch = /($^)/;
      var reUnescapedHtml = /[&<>"']/g;
      var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
      var contextProps = [
          'Array',
          'Boolean',
          'Date',
          'Function',
          'Math',
          'Number',
          'Object',
          'RegExp',
          'String',
          '_',
          'attachEvent',
          'clearTimeout',
          'isFinite',
          'isNaN',
          'parseInt',
          'setImmediate',
          'setTimeout'
        ];
      var templateCounter = 0;
      var argsClass = '[object Arguments]', arrayClass = '[object Array]', boolClass = '[object Boolean]', dateClass = '[object Date]', errorClass = '[object Error]', funcClass = '[object Function]', numberClass = '[object Number]', objectClass = '[object Object]', regexpClass = '[object RegExp]', stringClass = '[object String]';
      var cloneableClasses = {};
      cloneableClasses[funcClass] = false;
      cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
      var objectTypes = {
          'boolean': false,
          'function': true,
          'object': true,
          'number': false,
          'string': false,
          'undefined': false
        };
      var stringEscapes = {
          '\\': '\\',
          "'": "'",
          '\n': 'n',
          '\r': 'r',
          '\t': 't',
          '\u2028': 'u2028',
          '\u2029': 'u2029'
        };
      var freeExports = objectTypes[typeof exports] && exports;
      var freeModule = objectTypes[typeof module] && module && module.exports == freeExports && module;
      var freeGlobal = objectTypes[typeof global] && global;
      if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
        window = freeGlobal;
      }
      function basicIndexOf(array, value, fromIndex) {
        var index = (fromIndex || 0) - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function cacheIndexOf(cache, value) {
        var type = typeof value;
        cache = cache.cache;
        if (type == 'boolean' || value == null) {
          return cache[value];
        }
        if (type != 'number' && type != 'string') {
          type = 'object';
        }
        var key = type == 'number' ? value : keyPrefix + value;
        cache = cache[type] || (cache[type] = {});
        return type == 'object' ? cache[key] && basicIndexOf(cache[key], value) > -1 ? 0 : -1 : cache[key] ? 0 : -1;
      }
      function cachePush(value) {
        var cache = this.cache, type = typeof value;
        if (type == 'boolean' || value == null) {
          cache[value] = true;
        } else {
          if (type != 'number' && type != 'string') {
            type = 'object';
          }
          var key = type == 'number' ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
          if (type == 'object') {
            if ((typeCache[key] || (typeCache[key] = [])).push(value) == this.array.length) {
              cache[type] = false;
            }
          } else {
            typeCache[key] = true;
          }
        }
      }
      function charAtCallback(value) {
        return value.charCodeAt(0);
      }
      function compareAscending(a, b) {
        var ai = a.index, bi = b.index;
        a = a.criteria;
        b = b.criteria;
        if (a !== b) {
          if (a > b || typeof a == 'undefined') {
            return 1;
          }
          if (a < b || typeof b == 'undefined') {
            return -1;
          }
        }
        return ai < bi ? -1 : 1;
      }
      function createCache(array) {
        var index = -1, length = array.length;
        var cache = getObject();
        cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;
        var result = getObject();
        result.array = array;
        result.cache = cache;
        result.push = cachePush;
        while (++index < length) {
          result.push(array[index]);
        }
        return cache.object === false ? (releaseObject(result), null) : result;
      }
      function escapeStringChar(match) {
        return '\\' + stringEscapes[match];
      }
      function getArray() {
        return arrayPool.pop() || [];
      }
      function getObject() {
        return objectPool.pop() || {
          'array': null,
          'cache': null,
          'criteria': null,
          'false': false,
          'index': 0,
          'leading': false,
          'maxWait': 0,
          'null': false,
          'number': null,
          'object': null,
          'push': null,
          'string': null,
          'trailing': false,
          'true': false,
          'undefined': false,
          'value': null
        };
      }
      function noop() {
      }
      function releaseArray(array) {
        array.length = 0;
        if (arrayPool.length < maxPoolSize) {
          arrayPool.push(array);
        }
      }
      function releaseObject(object) {
        var cache = object.cache;
        if (cache) {
          releaseObject(cache);
        }
        object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
        if (objectPool.length < maxPoolSize) {
          objectPool.push(object);
        }
      }
      function slice(array, start, end) {
        start || (start = 0);
        if (typeof end == 'undefined') {
          end = array ? array.length : 0;
        }
        var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
        while (++index < length) {
          result[index] = array[start + index];
        }
        return result;
      }
      function runInContext(context) {
        context = context ? _.defaults(window.Object(), context, _.pick(window, contextProps)) : window;
        var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
        var arrayRef = [];
        var objectProto = Object.prototype, stringProto = String.prototype;
        var oldDash = context._;
        var reNative = RegExp('^' + String(objectProto.valueOf).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/valueOf|for [^\]]+/g, '.+?') + '$');
        var ceil = Math.ceil, clearTimeout = context.clearTimeout, concat = arrayRef.concat, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = reNative.test(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, propertyIsEnumerable = objectProto.propertyIsEnumerable, setImmediate = context.setImmediate, setTimeout = context.setTimeout, toString = objectProto.toString;
        var nativeBind = reNative.test(nativeBind = toString.bind) && nativeBind, nativeCreate = reNative.test(nativeCreate = Object.create) && nativeCreate, nativeIsArray = reNative.test(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = reNative.test(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeSlice = arrayRef.slice;
        var isIeOpera = reNative.test(context.attachEvent), isV8 = nativeBind && !/\n|true/.test(nativeBind + isIeOpera);
        var ctorByClass = {};
        ctorByClass[arrayClass] = Array;
        ctorByClass[boolClass] = Boolean;
        ctorByClass[dateClass] = Date;
        ctorByClass[funcClass] = Function;
        ctorByClass[objectClass] = Object;
        ctorByClass[numberClass] = Number;
        ctorByClass[regexpClass] = RegExp;
        ctorByClass[stringClass] = String;
        function lodash(value) {
          return value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__') ? value : new lodashWrapper(value);
        }
        function lodashWrapper(value) {
          this.__wrapped__ = value;
        }
        lodashWrapper.prototype = lodash.prototype;
        var support = lodash.support = {};
        support.fastBind = nativeBind && !isV8;
        lodash.templateSettings = {
          'escape': /<%-([\s\S]+?)%>/g,
          'evaluate': /<%([\s\S]+?)%>/g,
          'interpolate': reInterpolate,
          'variable': '',
          'imports': { '_': lodash }
        };
        function createBound(func, thisArg, partialArgs, indicator) {
          var isFunc = isFunction(func), isPartial = !partialArgs, key = thisArg;
          if (isPartial) {
            var rightIndicator = indicator;
            partialArgs = thisArg;
          } else if (!isFunc) {
            if (!indicator) {
              throw new TypeError;
            }
            thisArg = func;
          }
          function bound() {
            var args = arguments, thisBinding = isPartial ? this : thisArg;
            if (!isFunc) {
              func = thisArg[key];
            }
            if (partialArgs.length) {
              args = args.length ? (args = nativeSlice.call(args), rightIndicator ? args.concat(partialArgs) : partialArgs.concat(args)) : partialArgs;
            }
            if (this instanceof bound) {
              thisBinding = createObject(func.prototype);
              var result = func.apply(thisBinding, args);
              return isObject(result) ? result : thisBinding;
            }
            return func.apply(thisBinding, args);
          }
          return bound;
        }
        function createObject(prototype) {
          return isObject(prototype) ? nativeCreate(prototype) : {};
        }
        function escapeHtmlChar(match) {
          return htmlEscapes[match];
        }
        function getIndexOf(array, value, fromIndex) {
          var result = (result = lodash.indexOf) === indexOf ? basicIndexOf : result;
          return result;
        }
        function overloadWrapper(func) {
          return function (array, flag, callback, thisArg) {
            if (typeof flag != 'boolean' && flag != null) {
              thisArg = callback;
              callback = !(thisArg && thisArg[flag] === array) ? flag : undefined;
              flag = false;
            }
            if (callback != null) {
              callback = lodash.createCallback(callback, thisArg);
            }
            return func(array, flag, callback, thisArg);
          };
        }
        function shimIsPlainObject(value) {
          var ctor, result;
          if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
            return false;
          }
          forIn(value, function (value, key) {
            result = key;
          });
          return result === undefined || hasOwnProperty.call(value, result);
        }
        function unescapeHtmlChar(match) {
          return htmlUnescapes[match];
        }
        function isArguments(value) {
          return toString.call(value) == argsClass;
        }
        var isArray = nativeIsArray;
        var shimKeys = function (object) {
          var index, iterable = object, result = [];
          if (!iterable)
            return result;
          if (!objectTypes[typeof object])
            return result;
          for (index in iterable) {
            if (hasOwnProperty.call(iterable, index)) {
              result.push(index);
            }
          }
          return result;
        };
        var keys = !nativeKeys ? shimKeys : function (object) {
            if (!isObject(object)) {
              return [];
            }
            return nativeKeys(object);
          };
        var htmlEscapes = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
          };
        var htmlUnescapes = invert(htmlEscapes);
        var assign = function (object, source, guard) {
          var index, iterable = object, result = iterable;
          if (!iterable)
            return result;
          var args = arguments, argsIndex = 0, argsLength = typeof guard == 'number' ? 2 : args.length;
          if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
            var callback = lodash.createCallback(args[--argsLength - 1], args[argsLength--], 2);
          } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
            callback = args[--argsLength];
          }
          while (++argsIndex < argsLength) {
            iterable = args[argsIndex];
            if (iterable && objectTypes[typeof iterable]) {
              var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
              while (++ownIndex < length) {
                index = ownProps[ownIndex];
                result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
              }
            }
          }
          return result;
        };
        function clone(value, deep, callback, thisArg, stackA, stackB) {
          var result = value;
          if (typeof deep != 'boolean' && deep != null) {
            thisArg = callback;
            callback = deep;
            deep = false;
          }
          if (typeof callback == 'function') {
            callback = typeof thisArg == 'undefined' ? callback : lodash.createCallback(callback, thisArg, 1);
            result = callback(result);
            if (typeof result != 'undefined') {
              return result;
            }
            result = value;
          }
          var isObj = isObject(result);
          if (isObj) {
            var className = toString.call(result);
            if (!cloneableClasses[className]) {
              return result;
            }
            var isArr = isArray(result);
          }
          if (!isObj || !deep) {
            return isObj ? isArr ? slice(result) : assign({}, result) : result;
          }
          var ctor = ctorByClass[className];
          switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+result);
          case numberClass:
          case stringClass:
            return new ctor(result);
          case regexpClass:
            return ctor(result.source, reFlags.exec(result));
          }
          var initedStack = !stackA;
          stackA || (stackA = getArray());
          stackB || (stackB = getArray());
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == value) {
              return stackB[length];
            }
          }
          result = isArr ? ctor(result.length) : {};
          if (isArr) {
            if (hasOwnProperty.call(value, 'index')) {
              result.index = value.index;
            }
            if (hasOwnProperty.call(value, 'input')) {
              result.input = value.input;
            }
          }
          stackA.push(value);
          stackB.push(result);
          (isArr ? forEach : forOwn)(value, function (objValue, key) {
            result[key] = clone(objValue, deep, callback, undefined, stackA, stackB);
          });
          if (initedStack) {
            releaseArray(stackA);
            releaseArray(stackB);
          }
          return result;
        }
        function cloneDeep(value, callback, thisArg) {
          return clone(value, true, callback, thisArg);
        }
        var defaults = function (object, source, guard) {
          var index, iterable = object, result = iterable;
          if (!iterable)
            return result;
          var args = arguments, argsIndex = 0, argsLength = typeof guard == 'number' ? 2 : args.length;
          while (++argsIndex < argsLength) {
            iterable = args[argsIndex];
            if (iterable && objectTypes[typeof iterable]) {
              var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
              while (++ownIndex < length) {
                index = ownProps[ownIndex];
                if (typeof result[index] == 'undefined')
                  result[index] = iterable[index];
              }
            }
          }
          return result;
        };
        function findKey(object, callback, thisArg) {
          var result;
          callback = lodash.createCallback(callback, thisArg);
          forOwn(object, function (value, key, object) {
            if (callback(value, key, object)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        var forIn = function (collection, callback, thisArg) {
          var index, iterable = collection, result = iterable;
          if (!iterable)
            return result;
          if (!objectTypes[typeof iterable])
            return result;
          callback = callback && typeof thisArg == 'undefined' ? callback : lodash.createCallback(callback, thisArg);
          for (index in iterable) {
            if (callback(iterable[index], index, collection) === false)
              return result;
          }
          return result;
        };
        var forOwn = function (collection, callback, thisArg) {
          var index, iterable = collection, result = iterable;
          if (!iterable)
            return result;
          if (!objectTypes[typeof iterable])
            return result;
          callback = callback && typeof thisArg == 'undefined' ? callback : lodash.createCallback(callback, thisArg);
          var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
          while (++ownIndex < length) {
            index = ownProps[ownIndex];
            if (callback(iterable[index], index, collection) === false)
              return result;
          }
          return result;
        };
        function functions(object) {
          var result = [];
          forIn(object, function (value, key) {
            if (isFunction(value)) {
              result.push(key);
            }
          });
          return result.sort();
        }
        function has(object, property) {
          return object ? hasOwnProperty.call(object, property) : false;
        }
        function invert(object) {
          var index = -1, props = keys(object), length = props.length, result = {};
          while (++index < length) {
            var key = props[index];
            result[object[key]] = key;
          }
          return result;
        }
        function isBoolean(value) {
          return value === true || value === false || toString.call(value) == boolClass;
        }
        function isDate(value) {
          return value ? typeof value == 'object' && toString.call(value) == dateClass : false;
        }
        function isElement(value) {
          return value ? value.nodeType === 1 : false;
        }
        function isEmpty(value) {
          var result = true;
          if (!value) {
            return result;
          }
          var className = toString.call(value), length = value.length;
          if (className == arrayClass || className == stringClass || className == argsClass || className == objectClass && typeof length == 'number' && isFunction(value.splice)) {
            return !length;
          }
          forOwn(value, function () {
            return result = false;
          });
          return result;
        }
        function isEqual(a, b, callback, thisArg, stackA, stackB) {
          var whereIndicator = callback === indicatorObject;
          if (typeof callback == 'function' && !whereIndicator) {
            callback = lodash.createCallback(callback, thisArg, 2);
            var result = callback(a, b);
            if (typeof result != 'undefined') {
              return !!result;
            }
          }
          if (a === b) {
            return a !== 0 || 1 / a == 1 / b;
          }
          var type = typeof a, otherType = typeof b;
          if (a === a && (!a || type != 'function' && type != 'object') && (!b || otherType != 'function' && otherType != 'object')) {
            return false;
          }
          if (a == null || b == null) {
            return a === b;
          }
          var className = toString.call(a), otherClass = toString.call(b);
          if (className == argsClass) {
            className = objectClass;
          }
          if (otherClass == argsClass) {
            otherClass = objectClass;
          }
          if (className != otherClass) {
            return false;
          }
          switch (className) {
          case boolClass:
          case dateClass:
            return +a == +b;
          case numberClass:
            return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
          case regexpClass:
          case stringClass:
            return a == String(b);
          }
          var isArr = className == arrayClass;
          if (!isArr) {
            if (hasOwnProperty.call(a, '__wrapped__ ') || hasOwnProperty.call(b, '__wrapped__')) {
              return isEqual(a.__wrapped__ || a, b.__wrapped__ || b, callback, thisArg, stackA, stackB);
            }
            if (className != objectClass) {
              return false;
            }
            var ctorA = a.constructor, ctorB = b.constructor;
            if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB)) {
              return false;
            }
          }
          var initedStack = !stackA;
          stackA || (stackA = getArray());
          stackB || (stackB = getArray());
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == a) {
              return stackB[length] == b;
            }
          }
          var size = 0;
          result = true;
          stackA.push(a);
          stackB.push(b);
          if (isArr) {
            length = a.length;
            size = b.length;
            result = size == a.length;
            if (!result && !whereIndicator) {
              return result;
            }
            while (size--) {
              var index = length, value = b[size];
              if (whereIndicator) {
                while (index--) {
                  if (result = isEqual(a[index], value, callback, thisArg, stackA, stackB)) {
                    break;
                  }
                }
              } else if (!(result = isEqual(a[size], value, callback, thisArg, stackA, stackB))) {
                break;
              }
            }
            return result;
          }
          forIn(b, function (value, key, b) {
            if (hasOwnProperty.call(b, key)) {
              size++;
              return result = hasOwnProperty.call(a, key) && isEqual(a[key], value, callback, thisArg, stackA, stackB);
            }
          });
          if (result && !whereIndicator) {
            forIn(a, function (value, key, a) {
              if (hasOwnProperty.call(a, key)) {
                return result = --size > -1;
              }
            });
          }
          if (initedStack) {
            releaseArray(stackA);
            releaseArray(stackB);
          }
          return result;
        }
        function isFinite(value) {
          return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
        }
        function isFunction(value) {
          return typeof value == 'function';
        }
        function isObject(value) {
          return !!(value && objectTypes[typeof value]);
        }
        function isNaN(value) {
          return isNumber(value) && value != +value;
        }
        function isNull(value) {
          return value === null;
        }
        function isNumber(value) {
          return typeof value == 'number' || toString.call(value) == numberClass;
        }
        var isPlainObject = function (value) {
          if (!(value && toString.call(value) == objectClass)) {
            return false;
          }
          var valueOf = value.valueOf, objProto = typeof valueOf == 'function' && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
          return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
        };
        function isRegExp(value) {
          return value ? typeof value == 'object' && toString.call(value) == regexpClass : false;
        }
        function isString(value) {
          return typeof value == 'string' || toString.call(value) == stringClass;
        }
        function isUndefined(value) {
          return typeof value == 'undefined';
        }
        function merge(object, source, deepIndicator) {
          var args = arguments, index = 0, length = 2;
          if (!isObject(object)) {
            return object;
          }
          if (deepIndicator === indicatorObject) {
            var callback = args[3], stackA = args[4], stackB = args[5];
          } else {
            var initedStack = true;
            stackA = getArray();
            stackB = getArray();
            if (typeof deepIndicator != 'number') {
              length = args.length;
            }
            if (length > 3 && typeof args[length - 2] == 'function') {
              callback = lodash.createCallback(args[--length - 1], args[length--], 2);
            } else if (length > 2 && typeof args[length - 1] == 'function') {
              callback = args[--length];
            }
          }
          while (++index < length) {
            (isArray(args[index]) ? forEach : forOwn)(args[index], function (source, key) {
              var found, isArr, result = source, value = object[key];
              if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                var stackLength = stackA.length;
                while (stackLength--) {
                  if (found = stackA[stackLength] == source) {
                    value = stackB[stackLength];
                    break;
                  }
                }
                if (!found) {
                  var isShallow;
                  if (callback) {
                    result = callback(value, source);
                    if (isShallow = typeof result != 'undefined') {
                      value = result;
                    }
                  }
                  if (!isShallow) {
                    value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
                  }
                  stackA.push(source);
                  stackB.push(value);
                  if (!isShallow) {
                    value = merge(value, source, indicatorObject, callback, stackA, stackB);
                  }
                }
              } else {
                if (callback) {
                  result = callback(value, source);
                  if (typeof result == 'undefined') {
                    result = source;
                  }
                }
                if (typeof result != 'undefined') {
                  value = result;
                }
              }
              object[key] = value;
            });
          }
          if (initedStack) {
            releaseArray(stackA);
            releaseArray(stackB);
          }
          return object;
        }
        function omit(object, callback, thisArg) {
          var indexOf = getIndexOf(), isFunc = typeof callback == 'function', result = {};
          if (isFunc) {
            callback = lodash.createCallback(callback, thisArg);
          } else {
            var props = concat.apply(arrayRef, nativeSlice.call(arguments, 1));
          }
          forIn(object, function (value, key, object) {
            if (isFunc ? !callback(value, key, object) : indexOf(props, key) < 0) {
              result[key] = value;
            }
          });
          return result;
        }
        function pairs(object) {
          var index = -1, props = keys(object), length = props.length, result = Array(length);
          while (++index < length) {
            var key = props[index];
            result[index] = [
              key,
              object[key]
            ];
          }
          return result;
        }
        function pick(object, callback, thisArg) {
          var result = {};
          if (typeof callback != 'function') {
            var index = -1, props = concat.apply(arrayRef, nativeSlice.call(arguments, 1)), length = isObject(object) ? props.length : 0;
            while (++index < length) {
              var key = props[index];
              if (key in object) {
                result[key] = object[key];
              }
            }
          } else {
            callback = lodash.createCallback(callback, thisArg);
            forIn(object, function (value, key, object) {
              if (callback(value, key, object)) {
                result[key] = value;
              }
            });
          }
          return result;
        }
        function transform(object, callback, accumulator, thisArg) {
          var isArr = isArray(object);
          callback = lodash.createCallback(callback, thisArg, 4);
          if (accumulator == null) {
            if (isArr) {
              accumulator = [];
            } else {
              var ctor = object && object.constructor, proto = ctor && ctor.prototype;
              accumulator = createObject(proto);
            }
          }
          (isArr ? forEach : forOwn)(object, function (value, index, object) {
            return callback(accumulator, value, index, object);
          });
          return accumulator;
        }
        function values(object) {
          var index = -1, props = keys(object), length = props.length, result = Array(length);
          while (++index < length) {
            result[index] = object[props[index]];
          }
          return result;
        }
        function at(collection) {
          var index = -1, props = concat.apply(arrayRef, nativeSlice.call(arguments, 1)), length = props.length, result = Array(length);
          while (++index < length) {
            result[index] = collection[props[index]];
          }
          return result;
        }
        function contains(collection, target, fromIndex) {
          var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = false;
          fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
          if (length && typeof length == 'number') {
            result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
          } else {
            forOwn(collection, function (value) {
              if (++index >= fromIndex) {
                return !(result = value === target);
              }
            });
          }
          return result;
        }
        function countBy(collection, callback, thisArg) {
          var result = {};
          callback = lodash.createCallback(callback, thisArg);
          forEach(collection, function (value, key, collection) {
            key = String(callback(value, key, collection));
            hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
          });
          return result;
        }
        function every(collection, callback, thisArg) {
          var result = true;
          callback = lodash.createCallback(callback, thisArg);
          var index = -1, length = collection ? collection.length : 0;
          if (typeof length == 'number') {
            while (++index < length) {
              if (!(result = !!callback(collection[index], index, collection))) {
                break;
              }
            }
          } else {
            forOwn(collection, function (value, index, collection) {
              return result = !!callback(value, index, collection);
            });
          }
          return result;
        }
        function filter(collection, callback, thisArg) {
          var result = [];
          callback = lodash.createCallback(callback, thisArg);
          var index = -1, length = collection ? collection.length : 0;
          if (typeof length == 'number') {
            while (++index < length) {
              var value = collection[index];
              if (callback(value, index, collection)) {
                result.push(value);
              }
            }
          } else {
            forOwn(collection, function (value, index, collection) {
              if (callback(value, index, collection)) {
                result.push(value);
              }
            });
          }
          return result;
        }
        function find(collection, callback, thisArg) {
          callback = lodash.createCallback(callback, thisArg);
          var index = -1, length = collection ? collection.length : 0;
          if (typeof length == 'number') {
            while (++index < length) {
              var value = collection[index];
              if (callback(value, index, collection)) {
                return value;
              }
            }
          } else {
            var result;
            forOwn(collection, function (value, index, collection) {
              if (callback(value, index, collection)) {
                result = value;
                return false;
              }
            });
            return result;
          }
        }
        function forEach(collection, callback, thisArg) {
          var index = -1, length = collection ? collection.length : 0;
          callback = callback && typeof thisArg == 'undefined' ? callback : lodash.createCallback(callback, thisArg);
          if (typeof length == 'number') {
            while (++index < length) {
              if (callback(collection[index], index, collection) === false) {
                break;
              }
            }
          } else {
            forOwn(collection, callback);
          }
          return collection;
        }
        function groupBy(collection, callback, thisArg) {
          var result = {};
          callback = lodash.createCallback(callback, thisArg);
          forEach(collection, function (value, key, collection) {
            key = String(callback(value, key, collection));
            (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
          });
          return result;
        }
        function invoke(collection, methodName) {
          var args = nativeSlice.call(arguments, 2), index = -1, isFunc = typeof methodName == 'function', length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
          forEach(collection, function (value) {
            result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
          });
          return result;
        }
        function map(collection, callback, thisArg) {
          var index = -1, length = collection ? collection.length : 0;
          callback = lodash.createCallback(callback, thisArg);
          if (typeof length == 'number') {
            var result = Array(length);
            while (++index < length) {
              result[index] = callback(collection[index], index, collection);
            }
          } else {
            result = [];
            forOwn(collection, function (value, key, collection) {
              result[++index] = callback(value, key, collection);
            });
          }
          return result;
        }
        function max(collection, callback, thisArg) {
          var computed = -Infinity, result = computed;
          if (!callback && isArray(collection)) {
            var index = -1, length = collection.length;
            while (++index < length) {
              var value = collection[index];
              if (value > result) {
                result = value;
              }
            }
          } else {
            callback = !callback && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg);
            forEach(collection, function (value, index, collection) {
              var current = callback(value, index, collection);
              if (current > computed) {
                computed = current;
                result = value;
              }
            });
          }
          return result;
        }
        function min(collection, callback, thisArg) {
          var computed = Infinity, result = computed;
          if (!callback && isArray(collection)) {
            var index = -1, length = collection.length;
            while (++index < length) {
              var value = collection[index];
              if (value < result) {
                result = value;
              }
            }
          } else {
            callback = !callback && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg);
            forEach(collection, function (value, index, collection) {
              var current = callback(value, index, collection);
              if (current < computed) {
                computed = current;
                result = value;
              }
            });
          }
          return result;
        }
        function pluck(collection, property) {
          var index = -1, length = collection ? collection.length : 0;
          if (typeof length == 'number') {
            var result = Array(length);
            while (++index < length) {
              result[index] = collection[index][property];
            }
          }
          return result || map(collection, property);
        }
        function reduce(collection, callback, accumulator, thisArg) {
          if (!collection)
            return accumulator;
          var noaccum = arguments.length < 3;
          callback = lodash.createCallback(callback, thisArg, 4);
          var index = -1, length = collection.length;
          if (typeof length == 'number') {
            if (noaccum) {
              accumulator = collection[++index];
            }
            while (++index < length) {
              accumulator = callback(accumulator, collection[index], index, collection);
            }
          } else {
            forOwn(collection, function (value, index, collection) {
              accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
            });
          }
          return accumulator;
        }
        function reduceRight(collection, callback, accumulator, thisArg) {
          var iterable = collection, length = collection ? collection.length : 0, noaccum = arguments.length < 3;
          if (typeof length != 'number') {
            var props = keys(collection);
            length = props.length;
          }
          callback = lodash.createCallback(callback, thisArg, 4);
          forEach(collection, function (value, index, collection) {
            index = props ? props[--length] : --length;
            accumulator = noaccum ? (noaccum = false, iterable[index]) : callback(accumulator, iterable[index], index, collection);
          });
          return accumulator;
        }
        function reject(collection, callback, thisArg) {
          callback = lodash.createCallback(callback, thisArg);
          return filter(collection, function (value, index, collection) {
            return !callback(value, index, collection);
          });
        }
        function shuffle(collection) {
          var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
          forEach(collection, function (value) {
            var rand = floor(nativeRandom() * (++index + 1));
            result[index] = result[rand];
            result[rand] = value;
          });
          return result;
        }
        function size(collection) {
          var length = collection ? collection.length : 0;
          return typeof length == 'number' ? length : keys(collection).length;
        }
        function some(collection, callback, thisArg) {
          var result;
          callback = lodash.createCallback(callback, thisArg);
          var index = -1, length = collection ? collection.length : 0;
          if (typeof length == 'number') {
            while (++index < length) {
              if (result = callback(collection[index], index, collection)) {
                break;
              }
            }
          } else {
            forOwn(collection, function (value, index, collection) {
              return !(result = callback(value, index, collection));
            });
          }
          return !!result;
        }
        function sortBy(collection, callback, thisArg) {
          var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
          callback = lodash.createCallback(callback, thisArg);
          forEach(collection, function (value, key, collection) {
            var object = result[++index] = getObject();
            object.criteria = callback(value, key, collection);
            object.index = index;
            object.value = value;
          });
          length = result.length;
          result.sort(compareAscending);
          while (length--) {
            var object = result[length];
            result[length] = object.value;
            releaseObject(object);
          }
          return result;
        }
        function toArray(collection) {
          if (collection && typeof collection.length == 'number') {
            return slice(collection);
          }
          return values(collection);
        }
        var where = filter;
        function compact(array) {
          var index = -1, length = array ? array.length : 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result.push(value);
            }
          }
          return result;
        }
        function difference(array) {
          var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, seen = concat.apply(arrayRef, nativeSlice.call(arguments, 1)), result = [];
          var isLarge = length >= largeArraySize && indexOf === basicIndexOf;
          if (isLarge) {
            var cache = createCache(seen);
            if (cache) {
              indexOf = cacheIndexOf;
              seen = cache;
            } else {
              isLarge = false;
            }
          }
          while (++index < length) {
            var value = array[index];
            if (indexOf(seen, value) < 0) {
              result.push(value);
            }
          }
          if (isLarge) {
            releaseObject(seen);
          }
          return result;
        }
        function findIndex(array, callback, thisArg) {
          var index = -1, length = array ? array.length : 0;
          callback = lodash.createCallback(callback, thisArg);
          while (++index < length) {
            if (callback(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function first(array, callback, thisArg) {
          if (array) {
            var n = 0, length = array.length;
            if (typeof callback != 'number' && callback != null) {
              var index = -1;
              callback = lodash.createCallback(callback, thisArg);
              while (++index < length && callback(array[index], index, array)) {
                n++;
              }
            } else {
              n = callback;
              if (n == null || thisArg) {
                return array[0];
              }
            }
            return slice(array, 0, nativeMin(nativeMax(0, n), length));
          }
        }
        var flatten = overloadWrapper(function flatten(array, isShallow, callback) {
            var index = -1, length = array ? array.length : 0, result = [];
            while (++index < length) {
              var value = array[index];
              if (callback) {
                value = callback(value, index, array);
              }
              if (isArray(value)) {
                push.apply(result, isShallow ? value : flatten(value));
              } else {
                result.push(value);
              }
            }
            return result;
          });
        function indexOf(array, value, fromIndex) {
          if (typeof fromIndex == 'number') {
            var length = array ? array.length : 0;
            fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
          } else if (fromIndex) {
            var index = sortedIndex(array, value);
            return array[index] === value ? index : -1;
          }
          return array ? basicIndexOf(array, value, fromIndex) : -1;
        }
        function initial(array, callback, thisArg) {
          if (!array) {
            return [];
          }
          var n = 0, length = array.length;
          if (typeof callback != 'number' && callback != null) {
            var index = length;
            callback = lodash.createCallback(callback, thisArg);
            while (index-- && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = callback == null || thisArg ? 1 : callback || n;
          }
          return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
        }
        function intersection(array) {
          var args = arguments, argsLength = args.length, argsIndex = -1, caches = getArray(), index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [], seen = getArray();
          while (++argsIndex < argsLength) {
            var value = args[argsIndex];
            caches[argsIndex] = indexOf === basicIndexOf && (value ? value.length : 0) >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen);
          }
          outer:
            while (++index < length) {
              var cache = caches[0];
              value = array[index];
              if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                argsIndex = argsLength;
                (cache || seen).push(value);
                while (--argsIndex) {
                  cache = caches[argsIndex];
                  if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                    continue outer;
                  }
                }
                result.push(value);
              }
            }
          while (argsLength--) {
            cache = caches[argsLength];
            if (cache) {
              releaseObject(cache);
            }
          }
          releaseArray(caches);
          releaseArray(seen);
          return result;
        }
        function last(array, callback, thisArg) {
          if (array) {
            var n = 0, length = array.length;
            if (typeof callback != 'number' && callback != null) {
              var index = length;
              callback = lodash.createCallback(callback, thisArg);
              while (index-- && callback(array[index], index, array)) {
                n++;
              }
            } else {
              n = callback;
              if (n == null || thisArg) {
                return array[length - 1];
              }
            }
            return slice(array, nativeMax(0, length - n));
          }
        }
        function lastIndexOf(array, value, fromIndex) {
          var index = array ? array.length : 0;
          if (typeof fromIndex == 'number') {
            index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function range(start, end, step) {
          start = +start || 0;
          step = +step || 1;
          if (end == null) {
            end = start;
            start = 0;
          }
          var index = -1, length = nativeMax(0, ceil((end - start) / step)), result = Array(length);
          while (++index < length) {
            result[index] = start;
            start += step;
          }
          return result;
        }
        function rest(array, callback, thisArg) {
          if (typeof callback != 'number' && callback != null) {
            var n = 0, index = -1, length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg);
            while (++index < length && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = callback == null || thisArg ? 1 : nativeMax(0, callback);
          }
          return slice(array, n);
        }
        function sortedIndex(array, value, callback, thisArg) {
          var low = 0, high = array ? array.length : low;
          callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
          value = callback(value);
          while (low < high) {
            var mid = low + high >>> 1;
            callback(array[mid]) < value ? low = mid + 1 : high = mid;
          }
          return low;
        }
        function union(array) {
          if (!isArray(array)) {
            arguments[0] = array ? nativeSlice.call(array) : arrayRef;
          }
          return uniq(concat.apply(arrayRef, arguments));
        }
        var uniq = overloadWrapper(function (array, isSorted, callback) {
            var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [];
            var isLarge = !isSorted && length >= largeArraySize && indexOf === basicIndexOf, seen = callback || isLarge ? getArray() : result;
            if (isLarge) {
              var cache = createCache(seen);
              if (cache) {
                indexOf = cacheIndexOf;
                seen = cache;
              } else {
                isLarge = false;
                seen = callback ? seen : (releaseArray(seen), result);
              }
            }
            while (++index < length) {
              var value = array[index], computed = callback ? callback(value, index, array) : value;
              if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
                if (callback || isLarge) {
                  seen.push(computed);
                }
                result.push(value);
              }
            }
            if (isLarge) {
              releaseArray(seen.array);
              releaseObject(seen);
            } else if (callback) {
              releaseArray(seen);
            }
            return result;
          });
        function unzip(array) {
          var index = -1, length = array ? max(pluck(array, 'length')) : 0, result = Array(length < 0 ? 0 : length);
          while (++index < length) {
            result[index] = pluck(array, index);
          }
          return result;
        }
        function without(array) {
          return difference(array, nativeSlice.call(arguments, 1));
        }
        function zip(array) {
          return array ? unzip(arguments) : [];
        }
        function zipObject(keys, values) {
          var index = -1, length = keys ? keys.length : 0, result = {};
          while (++index < length) {
            var key = keys[index];
            if (values) {
              result[key] = values[index];
            } else {
              result[key[0]] = key[1];
            }
          }
          return result;
        }
        function after(n, func) {
          if (n < 1) {
            return func();
          }
          return function () {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function bind(func, thisArg) {
          return support.fastBind || nativeBind && arguments.length > 2 ? nativeBind.call.apply(nativeBind, arguments) : createBound(func, thisArg, nativeSlice.call(arguments, 2));
        }
        function bindAll(object) {
          var funcs = arguments.length > 1 ? concat.apply(arrayRef, nativeSlice.call(arguments, 1)) : functions(object), index = -1, length = funcs.length;
          while (++index < length) {
            var key = funcs[index];
            object[key] = bind(object[key], object);
          }
          return object;
        }
        function bindKey(object, key) {
          return createBound(object, key, nativeSlice.call(arguments, 2), indicatorObject);
        }
        function compose() {
          var funcs = arguments;
          return function () {
            var args = arguments, length = funcs.length;
            while (length--) {
              args = [funcs[length].apply(this, args)];
            }
            return args[0];
          };
        }
        function createCallback(func, thisArg, argCount) {
          if (func == null) {
            return identity;
          }
          var type = typeof func;
          if (type != 'function') {
            if (type != 'object') {
              return function (object) {
                return object[func];
              };
            }
            var props = keys(func);
            return function (object) {
              var length = props.length, result = false;
              while (length--) {
                if (!(result = isEqual(object[props[length]], func[props[length]], indicatorObject))) {
                  break;
                }
              }
              return result;
            };
          }
          if (typeof thisArg == 'undefined' || reThis && !reThis.test(fnToString.call(func))) {
            return func;
          }
          if (argCount === 1) {
            return function (value) {
              return func.call(thisArg, value);
            };
          }
          if (argCount === 2) {
            return function (a, b) {
              return func.call(thisArg, a, b);
            };
          }
          if (argCount === 4) {
            return function (accumulator, value, index, collection) {
              return func.call(thisArg, accumulator, value, index, collection);
            };
          }
          return function (value, index, collection) {
            return func.call(thisArg, value, index, collection);
          };
        }
        function debounce(func, wait, options) {
          var args, result, thisArg, callCount = 0, lastCalled = 0, maxWait = false, maxTimeoutId = null, timeoutId = null, trailing = true;
          function clear() {
            clearTimeout(maxTimeoutId);
            clearTimeout(timeoutId);
            callCount = 0;
            maxTimeoutId = timeoutId = null;
          }
          function delayed() {
            var isCalled = trailing && (!leading || callCount > 1);
            clear();
            if (isCalled) {
              if (maxWait !== false) {
                lastCalled = new Date;
              }
              result = func.apply(thisArg, args);
            }
          }
          function maxDelayed() {
            clear();
            if (trailing || maxWait !== wait) {
              lastCalled = new Date;
              result = func.apply(thisArg, args);
            }
          }
          wait = nativeMax(0, wait || 0);
          if (options === true) {
            var leading = true;
            trailing = false;
          } else if (isObject(options)) {
            leading = options.leading;
            maxWait = 'maxWait' in options && nativeMax(wait, options.maxWait || 0);
            trailing = 'trailing' in options ? options.trailing : trailing;
          }
          return function () {
            args = arguments;
            thisArg = this;
            callCount++;
            clearTimeout(timeoutId);
            if (maxWait === false) {
              if (leading && callCount < 2) {
                result = func.apply(thisArg, args);
              }
            } else {
              var now = new Date;
              if (!maxTimeoutId && !leading) {
                lastCalled = now;
              }
              var remaining = maxWait - (now - lastCalled);
              if (remaining <= 0) {
                clearTimeout(maxTimeoutId);
                maxTimeoutId = null;
                lastCalled = now;
                result = func.apply(thisArg, args);
              } else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout(maxDelayed, remaining);
              }
            }
            if (wait !== maxWait) {
              timeoutId = setTimeout(delayed, wait);
            }
            return result;
          };
        }
        function defer(func) {
          var args = nativeSlice.call(arguments, 1);
          return setTimeout(function () {
            func.apply(undefined, args);
          }, 1);
        }
        if (isV8 && freeModule && typeof setImmediate == 'function') {
          defer = bind(setImmediate, context);
        }
        function delay(func, wait) {
          var args = nativeSlice.call(arguments, 2);
          return setTimeout(function () {
            func.apply(undefined, args);
          }, wait);
        }
        function memoize(func, resolver) {
          function memoized() {
            var cache = memoized.cache, key = keyPrefix + (resolver ? resolver.apply(this, arguments) : arguments[0]);
            return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
          }
          memoized.cache = {};
          return memoized;
        }
        function once(func) {
          var ran, result;
          return function () {
            if (ran) {
              return result;
            }
            ran = true;
            result = func.apply(this, arguments);
            func = null;
            return result;
          };
        }
        function partial(func) {
          return createBound(func, nativeSlice.call(arguments, 1));
        }
        function partialRight(func) {
          return createBound(func, nativeSlice.call(arguments, 1), null, indicatorObject);
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (options === false) {
            leading = false;
          } else if (isObject(options)) {
            leading = 'leading' in options ? options.leading : leading;
            trailing = 'trailing' in options ? options.trailing : trailing;
          }
          options = getObject();
          options.leading = leading;
          options.maxWait = wait;
          options.trailing = trailing;
          var result = debounce(func, wait, options);
          releaseObject(options);
          return result;
        }
        function wrap(value, wrapper) {
          return function () {
            var args = [value];
            push.apply(args, arguments);
            return wrapper.apply(this, args);
          };
        }
        function escape(string) {
          return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
        }
        function identity(value) {
          return value;
        }
        function mixin(object) {
          forEach(functions(object), function (methodName) {
            var func = lodash[methodName] = object[methodName];
            lodash.prototype[methodName] = function () {
              var value = this.__wrapped__, args = [value];
              push.apply(args, arguments);
              var result = func.apply(lodash, args);
              return value && typeof value == 'object' && value === result ? this : new lodashWrapper(result);
            };
          });
        }
        function noConflict() {
          context._ = oldDash;
          return this;
        }
        var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function (value, radix) {
            return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
          };
        function random(min, max) {
          if (min == null && max == null) {
            max = 1;
          }
          min = +min || 0;
          if (max == null) {
            max = min;
            min = 0;
          } else {
            max = +max || 0;
          }
          var rand = nativeRandom();
          return min % 1 || max % 1 ? min + nativeMin(rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1))), max) : min + floor(rand * (max - min + 1));
        }
        function result(object, property) {
          var value = object ? object[property] : undefined;
          return isFunction(value) ? object[property]() : value;
        }
        function template(text, data, options) {
          var settings = lodash.templateSettings;
          text || (text = '');
          options = defaults({}, options, settings);
          var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
          var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
          text.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = options.variable, hasVariable = variable;
          if (!hasVariable) {
            variable = 'obj';
            source = 'with (' + variable + ') {\n' + source + '\n}\n';
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
          source = 'function(' + variable + ') {\n' + (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
          var sourceURL = '\n/*\n//@ sourceURL=' + (options.sourceURL || '/lodash/template/source[' + templateCounter++ + ']') + '\n*/';
          try {
            var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
          } catch (e) {
            e.source = source;
            throw e;
          }
          if (data) {
            return result(data);
          }
          result.source = source;
          return result;
        }
        function times(n, callback, thisArg) {
          n = (n = +n) > -1 ? n : 0;
          var index = -1, result = Array(n);
          callback = lodash.createCallback(callback, thisArg, 1);
          while (++index < n) {
            result[index] = callback(index);
          }
          return result;
        }
        function unescape(string) {
          return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return String(prefix == null ? '' : prefix) + id;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function wrapperToString() {
          return String(this.__wrapped__);
        }
        function wrapperValueOf() {
          return this.__wrapped__;
        }
        lodash.after = after;
        lodash.assign = assign;
        lodash.at = at;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.compact = compact;
        lodash.compose = compose;
        lodash.countBy = countBy;
        lodash.createCallback = createCallback;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.forEach = forEach;
        lodash.forIn = forIn;
        lodash.forOwn = forOwn;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.map = map;
        lodash.max = max;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.min = min;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.range = range;
        lodash.reject = reject;
        lodash.rest = rest;
        lodash.shuffle = shuffle;
        lodash.sortBy = sortBy;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.unzip = unzip;
        lodash.values = values;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.collect = map;
        lodash.drop = rest;
        lodash.each = forEach;
        lodash.extend = assign;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        mixin(lodash);
        lodash.chain = lodash;
        lodash.prototype.chain = function () {
          return this;
        };
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.contains = contains;
        lodash.escape = escape;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.has = has;
        lodash.identity = identity;
        lodash.indexOf = indexOf;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isNaN = isNaN;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isUndefined = isUndefined;
        lodash.lastIndexOf = lastIndexOf;
        lodash.mixin = mixin;
        lodash.noConflict = noConflict;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.result = result;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.template = template;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.all = every;
        lodash.any = some;
        lodash.detect = find;
        lodash.findWhere = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.include = contains;
        lodash.inject = reduce;
        forOwn(lodash, function (func, methodName) {
          if (!lodash.prototype[methodName]) {
            lodash.prototype[methodName] = function () {
              var args = [this.__wrapped__];
              push.apply(args, arguments);
              return func.apply(lodash, args);
            };
          }
        });
        lodash.first = first;
        lodash.last = last;
        lodash.take = first;
        lodash.head = first;
        forOwn(lodash, function (func, methodName) {
          if (!lodash.prototype[methodName]) {
            lodash.prototype[methodName] = function (callback, thisArg) {
              var result = func(this.__wrapped__, callback, thisArg);
              return callback == null || thisArg && typeof callback != 'function' ? result : new lodashWrapper(result);
            };
          }
        });
        lodash.VERSION = '1.3.1';
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.value = wrapperValueOf;
        lodash.prototype.valueOf = wrapperValueOf;
        forEach([
          'join',
          'pop',
          'shift'
        ], function (methodName) {
          var func = arrayRef[methodName];
          lodash.prototype[methodName] = function () {
            return func.apply(this.__wrapped__, arguments);
          };
        });
        forEach([
          'push',
          'reverse',
          'sort',
          'unshift'
        ], function (methodName) {
          var func = arrayRef[methodName];
          lodash.prototype[methodName] = function () {
            func.apply(this.__wrapped__, arguments);
            return this;
          };
        });
        forEach([
          'concat',
          'slice',
          'splice'
        ], function (methodName) {
          var func = arrayRef[methodName];
          lodash.prototype[methodName] = function () {
            return new lodashWrapper(func.apply(this.__wrapped__, arguments));
          };
        });
        return lodash;
      }
      var _ = runInContext();
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        window._ = _;
        define(function () {
          return _;
        });
      } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          (freeModule.exports = _)._ = _;
        } else {
          freeExports._ = _;
        }
      } else {
        window._ = _;
      }
    }(this));
  });
  require.define('/components/kinetic/kinetic.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Kinetic;
      Kinetic = {};
      Kinetic.Arrow = require('/components/kinetic/arrow.js', module).Arrow;
      Kinetic.Blank = require('/components/kinetic/blank.js', module).Blank;
      Kinetic.Circle = require('/components/kinetic/circle.js', module).Circle;
      Kinetic.Clear = require('/components/kinetic/clear.js', module).Clear;
      Kinetic.FixationCross = require('/components/kinetic/fixationcross.js', module).FixationCross;
      Kinetic.CanvasBorder = require('/components/kinetic/canvasborder.js', module).CanvasBorder;
      Kinetic.GridLines = require('/components/kinetic/gridlines.js', module).GridLines;
      Kinetic.Rectangle = require('/components/kinetic/rectangle.js', module).Rectangle;
      Kinetic.StartButton = require('/components/kinetic/startbutton.js', module).StartButton;
      Kinetic.Text = require('/components/kinetic/text.js', module).Text;
      Kinetic.TextInput = require('/components/kinetic/textinput.js', module).TextInput;
      exports.Kinetic = Kinetic;
    }.call(this));
  });
  require.define('/components/kinetic/arrow.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Arrow, Stimulus, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      Arrow = function (_super) {
        __extends(Arrow, _super);
        function Arrow() {
          _ref = Arrow.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        Arrow.prototype.defaults = {
          x: 100,
          y: 100,
          length: 100,
          angle: 0,
          thickness: 40,
          fill: 'red',
          arrowSize: 50
        };
        Arrow.prototype.render = function (context, layer) {
          var group, rect, triangle, _this;
          rect = new Kinetic.Rect({
            x: 0,
            y: 0,
            width: this.spec.length,
            height: this.spec.thickness,
            fill: this.spec.fill,
            stroke: this.spec.stroke,
            strokeWidth: this.spec.strokeWidth,
            opacity: this.spec.opacity
          });
          _this = this;
          triangle = new Kinetic.Shape({
            drawFunc: function (cx) {
              cx.beginPath();
              cx.moveTo(_this.spec.length, -_this.spec.arrowSize / 2);
              cx.lineTo(_this.spec.length + _this.spec.arrowSize, _this.spec.thickness / 2);
              cx.lineTo(_this.spec.length, _this.spec.thickness + _this.spec.arrowSize / 2);
              cx.closePath();
              return cx.fillStrokeShape(this);
            },
            fill: _this.spec.fill,
            stroke: this.spec.stroke,
            strokeWidth: this.spec.strokeWidth,
            opacity: this.spec.opacity
          });
          group = new Kinetic.Group({
            x: this.spec.x,
            y: this.spec.y,
            rotationDeg: this.spec.angle,
            offset: [
              0,
              this.spec.thickness / 2
            ]
          });
          group.add(rect);
          group.add(triangle);
          return layer.add(group);
        };
        return Arrow;
      }(Stimulus);
      exports.Arrow = Arrow;
    }.call(this));
  });
  require.define('/stimresp.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Module, Response, Stimulus, lay, _, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      _ = require('/../node_modules/lodash/dist/lodash.js', module);
      lay = require('/layout.js', module);
      Module = require('/module.js', module).Module;
      exports.Stimulus = Stimulus = function (_super) {
        __extends(Stimulus, _super);
        Stimulus.prototype.defaults = {};
        function Stimulus(spec) {
          var _ref;
          if (spec == null) {
            spec = {};
          }
          this.spec = _.defaults(spec, this.defaults);
          this.spec = _.omit(this.spec, function (value, key) {
            return !value;
          });
          this.name = this.constructor.name;
          if (((_ref = this.spec) != null ? _ref.id : void 0) != null) {
            this.id = this.spec.id;
          } else {
            this.id = _.uniqueId('stim_');
          }
          this.stopped = false;
          this.layout = new lay.AbsoluteLayout;
          this.overlay = false;
          this.name = this.constructor.name;
        }
        Stimulus.prototype.computeCoordinates = function (context, position) {
          var cpos;
          if (position) {
            cpos = this.layout.computePosition([
              context.width(),
              context.height()
            ], position);
            return cpos;
          } else if (this.spec.x && this.spec.y) {
            return [
              this.spec.x,
              this.spec.y
            ];
          } else {
            return [
              0,
              0
            ];
          }
        };
        Stimulus.prototype.reset = function () {
          return this.stopped = false;
        };
        Stimulus.prototype.render = function (context, layer) {
        };
        Stimulus.prototype.stop = function (context) {
          return this.stopped = true;
        };
        return Stimulus;
      }(Module);
      exports.Response = Response = function (_super) {
        __extends(Response, _super);
        function Response() {
          _ref = Response.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        Response.prototype.start = function (context) {
          return this.activate(context);
        };
        Response.prototype.activate = function (context) {
        };
        return Response;
      }(Stimulus);
    }.call(this));
  });
  require.define('/layout.js', function (module, exports, __dirname, __filename) {
    (function () {
      var AbsoluteLayout, GridLayout, Layout, computeGridCells, convertPercentageToFraction, convertToCoordinate, isPercentage, positionToCoord, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      isPercentage = function (perc) {
        return _.isString(perc) && perc.slice(-1) === '%';
      };
      convertPercentageToFraction = function (perc, dim) {
        var frac;
        frac = parseFloat(perc) / 100;
        frac = Math.min(1, frac);
        frac = Math.max(0, frac);
        return frac * dim;
      };
      convertToCoordinate = function (val, d) {
        if (isPercentage(val)) {
          return val = convertPercentageToFraction(val, d);
        } else {
          return Math.min(val, d);
        }
      };
      computeGridCells = function (rows, cols, bounds) {
        var col, row, _i, _results;
        _results = [];
        for (row = _i = 0; 0 <= rows ? _i < rows : _i > rows; row = 0 <= rows ? ++_i : --_i) {
          _results.push(function () {
            var _j, _results1;
            _results1 = [];
            for (col = _j = 0; 0 <= cols ? _j < cols : _j > cols; col = 0 <= cols ? ++_j : --_j) {
              _results1.push({
                x: bounds.x + bounds.width / cols * col,
                y: bounds.y + bounds.height / rows * row,
                width: bounds.width / cols,
                height: bounds.height / rows
              });
            }
            return _results1;
          }());
        }
        return _results;
      };
      positionToCoord = function (pos, offx, offy, width, height, xy) {
        switch (pos) {
        case 'center':
          return [
            offx + width * .5,
            offy + height * .5
          ];
        case 'center-left' || 'left-center':
          return [
            offx + width * 1 / 6,
            offy + height * .5
          ];
        case 'center-right' || 'right-center':
          return [
            offx + width * 5 / 6,
            offy + height * .5
          ];
        case 'top-left' || 'left-top':
          return [
            offx + width * 1 / 6,
            offy + height * 1 / 6
          ];
        case 'top-right' || 'right-top':
          return [
            offx + width * 5 / 6,
            offy + height * 1 / 6
          ];
        case 'top-center' || 'center-top':
          return [
            offx + width * .5,
            offy + height * 1 / 6
          ];
        case 'bottom-left' || 'left-bottom':
          return [
            offx + width * 1 / 6,
            offy + height * 5 / 6
          ];
        case 'bottom-right' || 'right-bottom':
          return [
            offx + width * 5 / 6,
            offy + height * 5 / 6
          ];
        case 'bottom-center' || 'center-bottom':
          return [
            offx + width * .5,
            offy + height * 5 / 6
          ];
        default:
          return xy;
        }
      };
      exports.Layout = Layout = function () {
        function Layout() {
        }
        Layout.prototype.computePosition = function (dim, stim, constraints) {
          throw new Error('unimplimented');
        };
        return Layout;
      }();
      exports.AbsoluteLayout = AbsoluteLayout = function (_super) {
        __extends(AbsoluteLayout, _super);
        function AbsoluteLayout() {
          _ref = AbsoluteLayout.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        AbsoluteLayout.prototype.computePosition = function (dim, constraints) {
          var x, y;
          x = convertToCoordinate(constraints[0], dim[0]);
          y = convertToCoordinate(constraints[1], dim[1]);
          return [
            x,
            y
          ];
        };
        return AbsoluteLayout;
      }(Layout);
      exports.GridLayout = GridLayout = function (_super) {
        __extends(GridLayout, _super);
        function GridLayout(rows, cols, bounds) {
          this.rows = rows;
          this.cols = cols;
          this.bounds = bounds;
          this.ncells = this.rows * this.cols;
          this.cells = this.computeCells();
        }
        GridLayout.prototype.computeCells = function () {
          return computeGridCells(this.rows, this.cols, this.bounds);
        };
        GridLayout.prototype.computePosition = function (dim, constraints) {
          var cell;
          if (dim[0] !== this.bounds.width && dim[1] !== this.bounds.height) {
            this.bounds.width = dim[0];
            this.bounds.height = dim[1];
            this.cells = this.computeCells();
          }
          cell = this.cells[constraints[0]][constraints[1]];
          return [
            cell.x + cell.width / 2,
            cell.y + cell.height / 2
          ];
        };
        return GridLayout;
      }(Layout);
      exports.positionToCoord = positionToCoord;
    }.call(this));
  });
  require.define('/components/kinetic/clear.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Clear, Stimulus, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      Clear = function (_super) {
        __extends(Clear, _super);
        function Clear() {
          _ref = Clear.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        Clear.prototype.render = function (context, layer) {
          return context.clearContent(true);
        };
        return Clear;
      }(Stimulus);
      exports.clear = Clear;
    }.call(this));
  });
  require.define('/components/kinetic/blank.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Blank, Stimulus, _, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      _ = require('/../node_modules/lodash/dist/lodash.js', module);
      Stimulus = require('/stimresp.js', module).Stimulus;
      Blank = function (_super) {
        __extends(Blank, _super);
        function Blank() {
          _ref = Blank.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        Blank.prototype.defaults = { fill: 'white' };
        Blank.prototype.render = function (context, layer) {
          var blank;
          blank = new Kinetic.Rect({
            x: 0,
            y: 0,
            width: context.width(),
            height: context.height(),
            fill: this.spec.fill
          });
          return layer.add(blank);
        };
        return Blank;
      }(Stimulus);
      exports.Blank = Blank;
    }.call(this));
  });
  require.define('/design.js', function (module, exports, __dirname, __filename) {
    (function () {
      var ArrayIterator, CellTable, DataTable, ExpDesign, Factor, FactorNode, FactorSetNode, FactorSpec, ItemNode, Iterator, TaskNode, TaskSchema, TrialList, VarSpec, VariablesNode, utils, _, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      _ = require('/../node_modules/lodash/dist/lodash.js', module);
      utils = require('/utils.js', module);
      DataTable = require('/datatable.js', module).DataTable;
      exports.Factor = Factor = function (_super) {
        __extends(Factor, _super);
        Factor.asFactor = function (arr) {
          return function (func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
          }(Factor, arr, function () {
          });
        };
        function Factor(arr) {
          var arg, _i, _len;
          for (_i = 0, _len = arr.length; _i < _len; _i++) {
            arg = arr[_i];
            this.push(arg);
          }
          this.levels = _.uniq(arr).sort();
        }
        return Factor;
      }(Array);
      exports.VarSpec = VarSpec = function () {
        function VarSpec() {
        }
        VarSpec.name = '';
        VarSpec.nblocks = 1;
        VarSpec.reps = 1;
        VarSpec.expanded = {};
        VarSpec.prototype.names = function () {
          return this.name;
        };
        VarSpec.prototype.ntrials = function () {
          return this.nblocks * this.reps;
        };
        VarSpec.prototype.valueAt = function (block, trial) {
        };
        return VarSpec;
      }();
      exports.FactorSpec = FactorSpec = function (_super) {
        __extends(FactorSpec, _super);
        function FactorSpec(name, levels) {
          this.name = name;
          this.levels = levels;
          this.factorSet = {};
          this.factorSet[this.name] = this.levels;
          this.conditionTable = DataTable.expand(this.factorSet);
        }
        FactorSpec.prototype.cross = function (other) {
          return new CrossedFactorSpec(this.nblocks, this.reps, [
            this,
            other
          ]);
        };
        FactorSpec.prototype.expand = function (nblocks, reps) {
          var blocks, concatBlocks, i, prop, vset, _i, _results;
          prop = {};
          prop[this.name] = this.levels;
          vset = new DataTable(prop);
          blocks = function () {
            var _i, _results;
            _results = [];
            for (i = _i = 1; 1 <= nblocks ? _i <= nblocks : _i >= nblocks; i = 1 <= nblocks ? ++_i : --_i) {
              _results.push(vset.replicate(reps));
            }
            return _results;
          }();
          concatBlocks = _.reduce(blocks, function (sum, nex) {
            return DataTable.rbind(sum, nex);
          });
          concatBlocks.bindcol('$Block', utils.rep(function () {
            _results = [];
            for (var _i = 1; 1 <= nblocks ? _i <= nblocks : _i >= nblocks; 1 <= nblocks ? _i++ : _i--) {
              _results.push(_i);
            }
            return _results;
          }.apply(this), utils.rep(reps * vset.nrow(), nblocks)));
          return concatBlocks;
        };
        return FactorSpec;
      }(VarSpec);
      exports.CellTable = CellTable = function (_super) {
        __extends(CellTable, _super);
        function CellTable(parents) {
          var fac;
          this.parents = parents;
          this.parentNames = function () {
            var _i, _len, _ref, _results;
            _ref = this.parents;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              fac = _ref[_i];
              _results.push(fac.name);
            }
            return _results;
          }.call(this);
          this.name = _.reduce(this.parentNames, function (n, n1) {
            return n + ':' + n1;
          });
          this.levels = function () {
            var _i, _len, _ref, _results;
            _ref = this.parents;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              fac = _ref[_i];
              _results.push(fac.levels);
            }
            return _results;
          }.call(this);
          this.factorSet = _.zipObject(this.parentNames, this.levels);
          this.table = DataTable.expand(this.factorSet);
        }
        CellTable.prototype.names = function () {
          return this.parentNames;
        };
        CellTable.prototype.conditions = function () {
          var i, rec, _i, _ref, _results;
          _results = [];
          for (i = _i = 0, _ref = this.table.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            rec = this.table.record(i);
            _results.push(_.reduce(rec, function (n, n1) {
              return n + ':' + n1;
            }));
          }
          return _results;
        };
        CellTable.prototype.expand = function (nblocks, reps) {
          var blocks, i;
          return blocks = function () {
            var _i, _results;
            _results = [];
            for (i = _i = 1; 1 <= nblocks ? _i <= nblocks : _i >= nblocks; i = 1 <= nblocks ? ++_i : --_i) {
              _results.push(this.table.replicate(reps));
            }
            return _results;
          }.call(this);
        };
        return CellTable;
      }(VarSpec);
      exports.TaskNode = TaskNode = function () {
        function TaskNode(varSpecs, crossedSet) {
          var i, vname, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2;
          this.varSpecs = varSpecs;
          this.crossedSet = crossedSet != null ? crossedSet : [];
          this.factorNames = _.map(this.varSpecs, function (x) {
            return x.names();
          });
          this.varmap = {};
          for (i = _i = 0, _ref = this.factorNames.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            this.varmap[this.factorNames[i]] = this.varSpecs[i];
          }
          if (this.crossedSet.length > 0) {
            _ref1 = this.crossedSet;
            for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
              vname = _ref1[_j];
              this.crossedVars = this.varmap[vname];
            }
            this.crossedSpec = new CrossedFactorSpec(this.crossedVars);
          } else {
            this.crossedVars = [];
            this.crossedSpec = {};
          }
          this.uncrossedVars = _.difference(this.factorNames, this.crossedSet);
          _ref2 = this.uncrossedVars;
          for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
            vname = _ref2[_k];
            this.uncrossedSpec = this.varmap[vname];
          }
          ({
            expand: function (nblocks, nreps) {
              var ctable;
              if (this.crossedVars.length > 0) {
                return ctable = this.crossedSpec.expand(nblocks, nreps);
              }
            }
          });
        }
        return TaskNode;
      }();
      exports.FactorNode = FactorNode = function () {
        FactorNode.build = function (name, spec) {
          return new FactorNode(name, spec.levels);
        };
        function FactorNode(name, levels) {
          this.name = name;
          this.levels = levels;
          this.cellTable = new CellTable([this]);
        }
        return FactorNode;
      }();
      exports.FactorSetNode = FactorSetNode = function () {
        FactorSetNode.build = function (spec) {
          var fnodes, key, value;
          fnodes = function () {
            var _results;
            _results = [];
            for (key in spec) {
              value = spec[key];
              _results.push(FactorNode.build(key, value));
            }
            return _results;
          }();
          return new FactorSetNode(fnodes);
        };
        function FactorSetNode(factors) {
          var i, _i, _ref;
          this.factors = factors;
          this.factorNames = _.map(this.factors, function (x) {
            return x.name;
          });
          this.varmap = {};
          for (i = _i = 0, _ref = this.factorNames.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            this.varmap[this.factorNames[i]] = this.factors[i];
          }
          this.cellTable = new CellTable(this.factors);
          this.name = this.cellTable.name;
        }
        FactorSetNode.prototype.levels = function () {
          return this.cellTable.levels;
        };
        FactorSetNode.prototype.conditions = function () {
          return this.cellTable.conditions();
        };
        FactorSetNode.prototype.expand = function (nblocks, nreps) {
          return this.cellTable.expand(nblocks, nreps);
        };
        FactorSetNode.prototype.trialList = function (nblocks, nreps) {
          var blk, blocks, i, j, tlist, _i, _j, _ref, _ref1;
          if (nblocks == null) {
            nblocks = 1;
          }
          if (nreps == null) {
            nreps = 1;
          }
          blocks = this.expand(nblocks, nreps);
          tlist = new TrialList(nblocks);
          for (i = _i = 0, _ref = blocks.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            blk = blocks[i];
            for (j = _j = 0, _ref1 = blk.nrow(); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              tlist.add(i, blk.record(j));
            }
          }
          return tlist;
        };
        return FactorSetNode;
      }();
      exports.Iterator = Iterator = function () {
        function Iterator() {
        }
        Iterator.prototype.hasNext = function () {
          return false;
        };
        Iterator.prototype.next = function () {
          throw 'empty iterator';
        };
        Iterator.prototype.map = function (fun) {
          throw 'empty iterator';
        };
        return Iterator;
      }();
      exports.ArrayIterator = ArrayIterator = function (_super) {
        __extends(ArrayIterator, _super);
        function ArrayIterator(arr) {
          this.arr = arr;
          this.cursor = 0;
          ({
            hasNext: function () {
              return this.cursor < this.arr.length;
            },
            next: function () {
              var ret;
              ret = this.arr[this.cursor];
              this.cursor = this.cursor + 1;
              return ret;
            },
            map: function (f) {
              return _.map(this.arr, function (el) {
                return f(el);
              });
            }
          });
        }
        return ArrayIterator;
      }(Iterator);
      exports.TrialList = TrialList = function () {
        function TrialList(nblocks) {
          var i, _i;
          this.blocks = [];
          for (i = _i = 0; 0 <= nblocks ? _i < nblocks : _i > nblocks; i = 0 <= nblocks ? ++_i : --_i) {
            this.blocks.push([]);
          }
        }
        TrialList.prototype.add = function (block, trial, type) {
          if (type == null) {
            type = 'main';
          }
          trial.$TYPE = type;
          return this.blocks[block].push(trial);
        };
        TrialList.prototype.get = function (block, trialNum) {
          return this.blocks[block][trialNum];
        };
        TrialList.prototype.getBlock = function (block) {
          return this.blocks[block];
        };
        TrialList.prototype.ntrials = function () {
          var nt;
          nt = _.map(this.blocks, function (b) {
            return b.length;
          });
          return _.reduce(nt, function (x0, x1) {
            return x0 + x1;
          });
        };
        TrialList.prototype.shuffle = function () {
          return this.blocks = _.map(this.blocks, function (blk) {
            return _.shuffle(blk);
          });
        };
        TrialList.prototype.blockIterator = function () {
          return new ArrayIterator(_.map(this.blocks, function (blk) {
            return new ArrayIterator(blk);
          }));
        };
        return TrialList;
      }();
      exports.ItemNode = ItemNode = function () {
        ItemNode.build = function (name, spec) {
          var attrs;
          attrs = new DataTable(spec.attributes);
          return new ItemNode(name, spec.items, attrs, spec.type);
        };
        function ItemNode(name, items, attributes, type) {
          this.name = name;
          this.items = items;
          this.attributes = attributes;
          this.type = type;
          if (this.items.length !== this.attributes.nrow()) {
            throw 'Number of items must equal number of attributes';
          }
        }
        return ItemNode;
      }();
      exports.VariablesNode = VariablesNode = function () {
        function VariablesNode(variables, crossed) {
          this.variables = variables != null ? variables : [];
          this.crossed = crossed != null ? crossed : [];
        }
        return VariablesNode;
      }();
      exports.TaskSchema = TaskSchema = function () {
        TaskSchema.build = function (spec) {
          var key, schema, value;
          schema = {};
          for (key in spec) {
            value = spec[key];
            schema[key] = FactorSetNode.build(value);
          }
          return new TaskSchema(schema);
        };
        function TaskSchema(schema) {
          this.schema = schema;
        }
        TaskSchema.prototype.trialTypes = function () {
          return _.keys(this.schema);
        };
        TaskSchema.prototype.factors = function (type) {
          return this.schema[type];
        };
        return TaskSchema;
      }();
      exports.ExpDesign = ExpDesign = function () {
        ExpDesign.blocks = 1;
        ExpDesign.validate = function (spec) {
          var des;
          if (!('Design' in spec)) {
            throw 'Design is undefined';
          }
          des = spec['Design'];
          if (!('Variables' in des)) {
            throw 'Variables is undefined';
          }
          if (!('Structure' in des)) {
            throw 'Structure is undefined';
          }
          if (!('Items' in spec)) {
            throw 'Items is undefined';
          }
        };
        ExpDesign.splitCrossedItems = function (itemSpec, crossedVariables) {
          var attrnames, conditionTable, i, indices, itemSets, j, keySet, levs, record, values;
          attrnames = crossedVariables.colnames();
          keySet = function () {
            var _i, _ref, _results;
            _results = [];
            for (i = _i = 0, _ref = crossedVariables.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              record = crossedVariables.record(i);
              levs = _.values(record);
              _results.push(_.reduce(levs, function (a, b) {
                return a + ':' + b;
              }));
            }
            return _results;
          }();
          values = itemSpec['values'];
          conditionTable = new DataTable(_.pick(itemSpec, attrnames));
          itemSets = function () {
            var _i, _ref, _results;
            _results = [];
            for (i = _i = 0, _ref = crossedVariables.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              record = crossedVariables.record(i);
              indices = conditionTable.whichRow(record);
              _results.push(function () {
                var _j, _len, _results1;
                _results1 = [];
                for (_j = 0, _len = indices.length; _j < _len; _j++) {
                  j = indices[_j];
                  _results1.push(values[j]);
                }
                return _results1;
              }());
            }
            return _results;
          }();
          return _.zipObject(keySet, itemSets);
        };
        ExpDesign.prototype.init = function (spec) {
          this.design = spec['Design'];
          this.variables = this.design['Variables'];
          this.itemSpec = spec['Items'];
          this.structure = this.design['Structure'];
          this.factorNames = _.keys(this.variables);
          this.crossed = this.variables['Crossed'];
          return this.auxiliary = this.variables['Auxiliary'];
        };
        ExpDesign.prototype.initStructure = function () {
          if (this.structure['type'] === 'Block') {
            if (!_.has(this.structure, 'reps_per_block')) {
              this.structure['reps_per_block'] = 1;
            }
            this.reps_per_block = this.structure['reps_per_block'];
            return this.blocks = this.structure['blocks'];
          } else {
            this.reps_per_block = 1;
            return this.blocks = 1;
          }
        };
        ExpDesign.prototype.makeConditionalSampler = function (crossedSpec, crossedItems) {
          var crossedItemMap, crossedItemName, key;
          crossedItemName = _.keys(crossedItems)[0];
          console.log('names:', crossedSpec.names());
          crossedItemMap = function () {
            var _i, _len, _ref, _results;
            _ref = crossedSpec.names();
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              key = _ref[_i];
              _results.push(crossedItems[crossedItemName][key]);
            }
            return _results;
          }();
          crossedItemMap = _.zipObject(_.keys(this.crossed), crossedItemMap);
          console.log('item map: ', crossedItemMap);
          return new ConditionalSampler(crossedItems[crossedItemName].values, new DataTable(crossedItemMap), crossedSpec);
        };
        ExpDesign.prototype.makeCrossedSpec = function (crossed, nblocks, nreps) {
          var factors, key, val;
          factors = function () {
            var _results;
            _results = [];
            for (key in crossed) {
              val = crossed[key];
              _results.push(new FactorSpec(nblocks, nreps, key, val.levels));
            }
            return _results;
          }();
          return crossed = new CrossedFactorSpec(nblocks, nreps, factors);
        };
        ExpDesign.prototype.makeFactorSpec = function (fac, nblocks, nreps) {
          return new FactorSpec(nblocks, nreps, _.keys(fac)[0], _.values(fac)[0]);
        };
        function ExpDesign(spec) {
          var crossedItems, crossedSampler;
          if (spec == null) {
            spec = {};
          }
          ExpDesign.validate(spec);
          this.init(spec);
          this.initStructure();
          this.crossedSpec = this.makeCrossedSpec(this.crossed, this.blocks, this.reps_per_block);
          crossedItems = this.itemSpec.Crossed;
          crossedSampler = this.makeConditionalSampler(this.crossedSpec, crossedItems);
          this.fullDesign = this.crossedSpec.expanded.bindcol(_.keys(crossedItems)[0], crossedSampler.take(this.crossedSpec.expanded.nrow()));
          console.log(this.crossedDesign);
        }
        return ExpDesign;
      }();
    }.call(this));
  });
  require.define('/datatable.js', function (module, exports, __dirname, __filename) {
    (function () {
      var DataTable, utils, _, __hasProp = {}.hasOwnProperty;
      _ = require('/../node_modules/lodash/dist/lodash.js', module);
      utils = require('/utils.js', module);
      DataTable = function () {
        function DataTable(vars) {
          var key, samelen, value, varlen;
          if (vars == null) {
            vars = {};
          }
          varlen = _.map(vars, function (x) {
            return x.length;
          });
          samelen = _.all(varlen, function (x) {
            return x === varlen[0];
          });
          if (!samelen) {
            throw 'arguments to DataTable must all have same length.';
          }
          for (key in vars) {
            value = vars[key];
            this[key] = value;
          }
        }
        DataTable.prototype.show = function () {
          var i, _i, _ref, _results;
          console.log('DataTable: rows: ' + this.nrow() + ' columns: ' + this.ncol());
          _results = [];
          for (i = _i = 0, _ref = this.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            _results.push(console.log(this.record(i)));
          }
          return _results;
        };
        DataTable.fromRecords = function (records, union) {
          var allkeys, key, rec, vars, _i, _j, _k, _len, _len1, _len2;
          if (union == null) {
            union = true;
          }
          allkeys = _.uniq(_.flatten(_.map(records, function (rec) {
            return _.keys(rec);
          })));
          vars = {};
          for (_i = 0, _len = allkeys.length; _i < _len; _i++) {
            key = allkeys[_i];
            vars[key] = [];
          }
          for (_j = 0, _len1 = records.length; _j < _len1; _j++) {
            rec = records[_j];
            for (_k = 0, _len2 = allkeys.length; _k < _len2; _k++) {
              key = allkeys[_k];
              vars[key].push(rec[key] || null);
            }
          }
          return new DataTable(vars);
        };
        DataTable.build = function (vars) {
          if (vars == null) {
            vars = {};
          }
          return Object.seal(new DataTable(vars));
        };
        DataTable.rbind = function (tab1, tab2, union) {
          var col1, col2, keys1, keys2, name, out, sharedKeys, _i, _len;
          if (union == null) {
            union = false;
          }
          keys1 = _.keys(tab1);
          keys2 = _.keys(tab2);
          sharedKeys = union ? _.union(keys1, keys2) : _.intersection(keys1, keys2);
          out = {};
          for (_i = 0, _len = sharedKeys.length; _i < _len; _i++) {
            name = sharedKeys[_i];
            col1 = tab1[name];
            col2 = tab2[name];
            if (!col1) {
              col1 = utils.repLen([null], tab1.nrow());
            }
            if (!col2) {
              col2 = utils.repLen([null], tab2.nrow());
            }
            out[name] = col1.concat(col2);
          }
          return new DataTable(out);
        };
        DataTable.cbind = function (tab1, tab2) {
          var diffkeys, key, out, _i, _len;
          if (tab1.nrow() !== tab2.nrow()) {
            throw 'cbind requires arguments to have same number of rows';
          }
          out = _.cloneDeep(tab1);
          diffkeys = _.difference(_.keys(tab2), _.keys(tab1));
          for (_i = 0, _len = diffkeys.length; _i < _len; _i++) {
            key = diffkeys[_i];
            out[key] = tab2[key];
          }
          return out;
        };
        DataTable.expand = function (vars, unique, nreps) {
          var d, i, key, name, nargs, nm, nx, orep, out, r1, r2, r3, repfac, value, _i, _j, _results;
          if (vars == null) {
            vars = {};
          }
          if (unique == null) {
            unique = true;
          }
          if (nreps == null) {
            nreps = 1;
          }
          if (unique) {
            out = {};
            for (name in vars) {
              value = vars[name];
              out[name] = _.unique(value);
            }
            vars = out;
          }
          nargs = _.size(vars);
          nm = _.keys(vars);
          repfac = 1;
          d = _.map(vars, function (x) {
            return x.length;
          });
          orep = _.reduce(d, function (x, acc) {
            return x * acc;
          });
          out = {};
          for (key in vars) {
            value = vars[key];
            nx = value.length;
            orep = orep / nx;
            r1 = utils.rep([repfac], nx);
            r2 = utils.rep(function () {
              _results = [];
              for (var _i = 0; 0 <= nx ? _i < nx : _i > nx; 0 <= nx ? _i++ : _i--) {
                _results.push(_i);
              }
              return _results;
            }.apply(this), r1);
            r3 = utils.rep(r2, orep);
            out[key] = function () {
              var _j, _len, _results1;
              _results1 = [];
              for (_j = 0, _len = r3.length; _j < _len; _j++) {
                i = r3[_j];
                _results1.push(value[i]);
              }
              return _results1;
            }();
            repfac = repfac * nx;
          }
          if (nreps > 1) {
            for (i = _j = 1; 1 <= nreps ? _j <= nreps : _j >= nreps; i = 1 <= nreps ? ++_j : --_j) {
              out = _.merge(out, out);
            }
          }
          return new DataTable(out);
        };
        DataTable.prototype.subset = function (key, filter) {
          var el, i, keep, name, out, val, value;
          keep = function () {
            var _i, _len, _ref, _results;
            _ref = this[key];
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              val = _ref[_i];
              if (filter(val)) {
                _results.push(true);
              } else {
                _results.push(false);
              }
            }
            return _results;
          }.call(this);
          out = {};
          for (name in this) {
            if (!__hasProp.call(this, name))
              continue;
            value = this[name];
            out[name] = function () {
              var _i, _len, _results;
              _results = [];
              for (i = _i = 0, _len = value.length; _i < _len; i = ++_i) {
                el = value[i];
                if (keep[i] === true) {
                  _results.push(el);
                }
              }
              return _results;
            }();
          }
          return new DataTable(out);
        };
        DataTable.prototype.whichRow = function (where) {
          var count, i, key, nkeys, out, rec, value, _i, _ref;
          out = [];
          nkeys = _.keys(where).length;
          for (i = _i = 0, _ref = this.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            rec = this.record(i);
            count = utils.asArray(function () {
              var _results;
              _results = [];
              for (key in where) {
                value = where[key];
                _results.push(rec[key] === value);
              }
              return _results;
            }());
            count = _.map(count, function (x) {
              if (x) {
                return 1;
              } else {
                return 0;
              }
            });
            count = _.reduce(utils.asArray(count), function (sum, num) {
              return sum + num;
            });
            if (count === nkeys) {
              out.push(i);
            }
          }
          return out;
        };
        DataTable.prototype.select = function (where) {
          var count, i, key, nkeys, out, rec, value, _i, _ref;
          out = [];
          nkeys = _.keys(where).length;
          for (i = _i = 0, _ref = this.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            rec = this.record(i);
            count = utils.asArray(function () {
              var _results;
              _results = [];
              for (key in where) {
                value = where[key];
                _results.push(rec[key] === value);
              }
              return _results;
            }());
            count = _.map(count, function (x) {
              if (x) {
                return 1;
              } else {
                return 0;
              }
            });
            count = _.reduce(utils.asArray(count), function (sum, num) {
              return sum + num;
            });
            if (count === nkeys) {
              out.push(rec);
            }
          }
          return out;
        };
        DataTable.prototype.nrow = function () {
          var lens, name, value;
          lens = function () {
            var _results;
            _results = [];
            for (name in this) {
              if (!__hasProp.call(this, name))
                continue;
              value = this[name];
              _results.push(value.length);
            }
            return _results;
          }.call(this);
          return _.max(lens);
        };
        DataTable.prototype.ncol = function () {
          return Object.keys(this).length;
        };
        DataTable.prototype.colnames = function () {
          return Object.keys(this);
        };
        DataTable.prototype.record = function (index) {
          var name, rec, value;
          rec = {};
          for (name in this) {
            if (!__hasProp.call(this, name))
              continue;
            value = this[name];
            rec[name] = value[index];
          }
          return rec;
        };
        DataTable.prototype.replicate = function (nreps) {
          var name, out, value, _this = this;
          out = {};
          for (name in this) {
            if (!__hasProp.call(this, name))
              continue;
            value = this[name];
            out[name] = _.flatten(_.times(nreps, function (n) {
              return value;
            }));
          }
          return new DataTable(out);
        };
        DataTable.prototype.bindcol = function (name, column) {
          if (column.length !== this.nrow()) {
            throw 'new column must be same length as existing DataTable object: column.length is  ' + column.length + ' and this.length is  ' + this.nrow();
          }
          this[name] = column;
          return this;
        };
        DataTable.prototype.bindrow = function (rows) {
          var key, record, value, _i, _len;
          if (!_.isArray(rows)) {
            rows = [rows];
          }
          for (_i = 0, _len = rows.length; _i < _len; _i++) {
            record = rows[_i];
            console.log(record);
            for (key in record) {
              if (!__hasProp.call(record, key))
                continue;
              value = record[key];
              if (!_.has(this, key)) {
                throw new Error('DataTable has no field named ' + key);
              } else {
                this[key].push(value);
              }
            }
          }
          return this;
        };
        return DataTable;
      }();
      exports.DataTable = DataTable;
    }.call(this));
  });
  require.define('/utils.js', function (module, exports, __dirname, __filename) {
    (function () {
      var getTimestamp, _, _ref, _ref1;
      _ = require('/../node_modules/lodash/dist/lodash.js', module);
      if (typeof window !== 'undefined' && window !== null ? (_ref = window.performance) != null ? _ref.now : void 0 : void 0) {
        getTimestamp = function () {
          return window.performance.now();
        };
      } else if (typeof window !== 'undefined' && window !== null ? (_ref1 = window.performance) != null ? _ref1.webkitNow : void 0 : void 0) {
        getTimestamp = function () {
          return window.performance.webkitNow();
        };
      } else {
        getTimestamp = function () {
          return new Date().getTime();
        };
      }
      exports.getTimeStamp = getTimestamp;
      this.browserBackDisabled = false;
      exports.disableBrowserBack = function () {
        var rx;
        if (!this.browserBackDisabled) {
          rx = /INPUT|SELECT|TEXTAREA/i;
          this.browserBackDisabled = true;
          return $(document).bind('keydown keypress', function (e) {
            if (e.which === 8) {
              if (!rx.test(e.target.tagName) || e.target.disabled || e.target.readOnly) {
                return e.preventDefault();
              }
            }
          });
        }
      };
      exports.module = function (name) {
        return global[name] = global[name] || {};
      };
      exports.asArray = function (value) {
        if (_.isArray(value)) {
          return value;
        } else if (_.isNumber(value) || _.isBoolean(value)) {
          return [value];
        } else {
          return _.toArray(value);
        }
      };
      exports.permute = function (input) {
        var main, permArr, usedChars;
        permArr = [];
        usedChars = [];
        exports.main = main = function (input) {
          var ch, i, _i, _ref2;
          for (i = _i = 0, _ref2 = input.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
            ch = input.splice(i, 1)[0];
            usedChars.push(ch);
            if (input.length === 0) {
              permArr.push(usedChars.slice());
            }
            main(input);
            input.splice(i, 0, ch);
            usedChars.pop();
          }
          return permArr;
        };
        return main(input);
      };
      exports.rep = function (vec, times) {
        var el, i, j, out, _this = this;
        if (!(times instanceof Array)) {
          times = [times];
        }
        if (times.length !== 1 && vec.length !== times.length) {
          throw 'vec.length must equal times.length or times.length must be 1';
        }
        if (vec.length === times.length) {
          out = function () {
            var _i, _len, _results;
            _results = [];
            for (i = _i = 0, _len = vec.length; _i < _len; i = ++_i) {
              el = vec[i];
              _results.push(function () {
                var _j, _ref2, _results1;
                _results1 = [];
                for (j = _j = 1, _ref2 = times[i]; 1 <= _ref2 ? _j <= _ref2 : _j >= _ref2; j = 1 <= _ref2 ? ++_j : --_j) {
                  _results1.push(el);
                }
                return _results1;
              }());
            }
            return _results;
          }();
          return _.flatten(out);
        } else {
          out = _.times(times[0], function (n) {
            return vec;
          });
          return _.flatten(out);
        }
      };
      exports.repLen = function (vec, length) {
        var i, _i, _results;
        if (length < 1) {
          throw 'repLen: length must be greater than or equal to 1';
        }
        _results = [];
        for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
          _results.push(vec[i % vec.length]);
        }
        return _results;
      };
      exports.sample = function (elements, n, replace) {
        var i, _i, _results;
        if (replace == null) {
          replace = false;
        }
        if (n > elements.length && !replace) {
          throw "cannot take sample larger than the number of elements when 'replace' argument is false";
        }
        if (!replace) {
          return _.shuffle(elements).slice(0, n);
        } else {
          _results = [];
          for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
            _results.push(Math.floor(Math.random() * elements.length));
          }
          return _results;
        }
      };
      exports.doTimer = function (length, oncomplete) {
        var instance, start;
        start = getTimestamp();
        instance = function () {
          var diff, half;
          diff = getTimestamp() - start;
          if (diff >= length) {
            return oncomplete(diff);
          } else {
            half = Math.max((length - diff) / 2, 1);
            if (half < 20) {
              half = 1;
            }
            return setTimeout(instance, half);
          }
        };
        return setTimeout(instance, 1);
      };
    }.call(this));
  });
  require.define('/samplers.js', function (module, exports, __dirname, __filename) {
    (function () {
      var CombinatoricSampler, ConditionalSampler, DataTable, ExhaustiveSampler, GridSampler, MatchSampler, Sampler, UniformSampler, utils, _, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        }, __slice = [].slice;
      utils = require('/utils.js', module);
      _ = require('/../node_modules/lodash/dist/lodash.js', module);
      DataTable = require('/datatable.js', module).DataTable;
      exports.Sampler = Sampler = function () {
        function Sampler(items) {
          this.items = items;
        }
        Sampler.prototype.sampleFrom = function (items, n) {
          return utils.sample(items, n);
        };
        Sampler.prototype.take = function (n) {
          if (n > this.items.length) {
            throw 'cannot take sample larger than the number of items when using non-replacing sampler';
          }
          return this.sampleFrom(this.items, n);
        };
        return Sampler;
      }();
      exports.ExhaustiveSampler = ExhaustiveSampler = function (_super) {
        __extends(ExhaustiveSampler, _super);
        ExhaustiveSampler.fillBuffer = function (items, n) {
          var buf, i;
          buf = function () {
            var _i, _results;
            _results = [];
            for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
              _results.push(_.shuffle(items));
            }
            return _results;
          }();
          return _.flatten(buf);
        };
        function ExhaustiveSampler(items, buflen) {
          this.items = items;
          if (buflen == null) {
            buflen = 10;
          }
          this.buffer = ExhaustiveSampler.fillBuffer(this.items, buflen);
        }
        ExhaustiveSampler.prototype.take = function (n) {
          var buf, buflen, res;
          if (n <= this.buffer.length) {
            res = _.take(this.buffer, n);
            this.buffer = _.drop(this.buffer, n);
            return res;
          } else {
            buflen = Math.max(n, 10 * this.items.length);
            buf = ExhaustiveSampler.fillBuffer(this.items, buflen / this.items.length);
            this.buffer = this.buffer.concat(buf);
            return this.take(n);
          }
        };
        return ExhaustiveSampler;
      }(Sampler);
      exports.MatchSampler = MatchSampler = function () {
        function MatchSampler(sampler) {
          this.sampler = sampler;
        }
        MatchSampler.prototype.take = function (n, match) {
          var probe, probeIndex, sam;
          if (match == null) {
            match = true;
          }
          sam = this.sampler.take(n);
          if (match) {
            probe = utils.sample(sam, 1)[0];
          } else {
            probe = this.sampler.take(1)[0];
          }
          probeIndex = _.indexOf(sam, probe);
          return {
            targetSet: sam,
            probe: probe,
            probeIndex: probeIndex,
            match: match
          };
        };
        return MatchSampler;
      }();
      exports.UniformSampler = UniformSampler = function (_super) {
        __extends(UniformSampler, _super);
        UniformSampler.validate = function (range) {
          if (range.length !== 2) {
            throw 'range must be an array with two values (min, max)';
          }
          if (range[1] <= range[0]) {
            throw 'range[1] must > range[0]';
          }
        };
        function UniformSampler(range) {
          this.range = range;
          this.interval = this.range[1] - this.range[0];
        }
        UniformSampler.prototype.take = function (n) {
          var i, nums;
          nums = function () {
            var _i, _results;
            _results = [];
            for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
              _results.push(Math.round(Math.random() * this.interval));
            }
            return _results;
          }.call(this);
          return nums;
        };
        return UniformSampler;
      }(Sampler);
      exports.CombinatoricSampler = CombinatoricSampler = function (_super) {
        __extends(CombinatoricSampler, _super);
        function CombinatoricSampler() {
          var samplers;
          samplers = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          this.samplers = samplers;
        }
        CombinatoricSampler.prototype.take = function (n) {
          var i, j, xs, _i, _results;
          _results = [];
          for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
            xs = function () {
              var _j, _ref, _results1;
              _results1 = [];
              for (j = _j = 0, _ref = this.samplers.length; 0 <= _ref ? _j < _ref : _j > _ref; j = 0 <= _ref ? ++_j : --_j) {
                _results1.push(this.samplers[j].take(1));
              }
              return _results1;
            }.call(this);
            _results.push(_.flatten(xs));
          }
          return _results;
        };
        return CombinatoricSampler;
      }(Sampler);
      exports.GridSampler = GridSampler = function (_super) {
        __extends(GridSampler, _super);
        function GridSampler(x, y) {
          var i;
          this.x = x;
          this.y = y;
          this.grid = DataTable.expand({
            x: this.x,
            y: this.y
          });
          console.log('rows:', this.grid.nrow());
          this.tuples = function () {
            var _i, _ref, _results;
            _results = [];
            for (i = _i = 0, _ref = this.grid.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              _results.push(_.values(this.grid.record(i)));
            }
            return _results;
          }.call(this);
        }
        GridSampler.prototype.take = function (n) {
          return utils.sample(this.tuples, n);
        };
        return GridSampler;
      }(Sampler);
      exports.ConditionalSampler = ConditionalSampler = function (_super) {
        __extends(ConditionalSampler, _super);
        ConditionalSampler.prototype.makeItemSubsets = function () {
          var ctable, i, indices, itemSets, j, keySet, levs, record;
          ctable = this.factorSpec.conditionTable;
          keySet = function () {
            var _i, _ref, _results;
            _results = [];
            for (i = _i = 0, _ref = ctable.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              record = ctable.record(i);
              levs = _.values(record);
              _results.push(_.reduce(levs, function (a, b) {
                return a + ':' + b;
              }));
            }
            return _results;
          }();
          console.log(keySet);
          itemSets = function () {
            var _i, _ref, _results;
            _results = [];
            for (i = _i = 0, _ref = ctable.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              record = ctable.record(i);
              indices = this.itemMap.whichRow(record);
              _results.push(function () {
                var _j, _len, _results1;
                _results1 = [];
                for (_j = 0, _len = indices.length; _j < _len; _j++) {
                  j = indices[_j];
                  _results1.push(this.items[j]);
                }
                return _results1;
              }.call(this));
            }
            return _results;
          }.call(this);
          console.log(itemSets);
          return _.zipObject(keySet, itemSets);
        };
        function ConditionalSampler(items, itemMap, factorSpec) {
          var key, value, _ref;
          this.items = items;
          this.itemMap = itemMap;
          this.factorSpec = factorSpec;
          this.keyMap = this.makeItemSubsets();
          this.conditions = _.keys(this.keyMap);
          this.samplerSet = {};
          _ref = this.keyMap;
          for (key in _ref) {
            value = _ref[key];
            this.samplerSet[key] = new ExhaustiveSampler(value);
          }
        }
        ConditionalSampler.prototype.take = function (n) {
          var keys;
          keys = utils.repLen(this.conditions, n);
          return _.flatten(this.takeCondition(keys));
        };
        ConditionalSampler.prototype.takeCondition = function (keys) {
          var key, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = keys.length; _i < _len; _i++) {
            key = keys[_i];
            _results.push(this.samplerSet[key].take(1));
          }
          return _results;
        };
        return ConditionalSampler;
      }(Sampler);
    }.call(this));
  });
  require.define('/dotmotion.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Base, DotSet, RandomDotMotion, x, _, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Base = require('/stimresp.js', module);
      _ = require('/../node_modules/lodash/dist/lodash.js', module);
      DotSet = function () {
        DotSet.randomDelta = function (distance) {
          var rads;
          rads = Math.random() * Math.PI * 2;
          return [
            distance * Math.cos(rads),
            distance * Math.sin(rads)
          ];
        };
        DotSet.coherentDelta = function (distance, direction) {
          return [
            distance * Math.cos(Math.PI * direction / 180),
            distance * Math.sin(Math.PI * direction / 180)
          ];
        };
        DotSet.pointInCircle = function () {
          var r, t, u;
          t = 2 * Math.PI * Math.random();
          u = Math.random() + Math.random();
          r = u > 1 ? 2 - u : u;
          return [
            r * Math.cos(t),
            r * Math.sin(t)
          ];
        };
        DotSet.inCircle = function (center_x, center_y, radius, x, y) {
          var squareDist;
          squareDist = Math.pow(center_x - x, 2) + Math.pow(center_y - y, 2);
          return squareDist <= Math.pow(radius, 2);
        };
        function DotSet(ndots, nparts, coherence) {
          var _this = this;
          this.ndots = ndots;
          this.nparts = nparts != null ? nparts : 3;
          if (coherence == null) {
            coherence = .5;
          }
          this.frameNum = 0;
          this.dotsPerSet = Math.round(this.ndots / this.nparts);
          this.dotSets = _.map([
            0,
            1,
            2
          ], function (i) {
            var _i, _ref, _results;
            return _.map(function () {
              _results = [];
              for (var _i = 0, _ref = _this.dotsPerSet; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--) {
                _results.push(_i);
              }
              return _results;
            }.apply(this), function (d) {
              return [
                Math.random(),
                Math.random()
              ];
            });
          });
        }
        DotSet.prototype.getDotPartition = function (i) {
          return this.dotSets[i];
        };
        DotSet.prototype.nextFrame = function (coherence, distance, direction) {
          var delta, dset, i, partition, res, xy;
          partition = this.frameNum % this.nparts;
          dset = this.dotSets[partition];
          res = function () {
            var _i, _ref, _results;
            _results = [];
            for (i = _i = 0, _ref = dset.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              xy = dset[i];
              delta = Math.random() < coherence ? DotSet.coherentDelta(distance, direction) : DotSet.randomDelta(distance);
              xy = [
                xy[0] + delta[0],
                xy[1] + delta[1]
              ];
              if (xy[0] < 0 || xy[0] > 1 || xy[1] < 0 || xy[1] > 1) {
                xy = [
                  Math.random(),
                  Math.random()
                ];
              }
              _results.push(dset[i] = xy);
            }
            return _results;
          }();
          this.frameNum = this.frameNum + 1;
          return res;
        };
        return DotSet;
      }();
      exports.RandomDotMotion = RandomDotMotion = function (_super) {
        __extends(RandomDotMotion, _super);
        function RandomDotMotion(spec) {
          if (spec == null) {
            spec = {
              x: 0,
              y: 0,
              numDots: 70,
              apRadius: 400,
              dotSpeed: .02,
              dotSize: 2,
              coherence: .55,
              partitions: 3
            };
          }
          this.numDots = spec.numDots;
          this.apRadius = spec.apRadius;
          this.dotSpeed = spec.dotSpeed;
          this.dotSize = spec.dotSize;
          this.coherence = spec.coherence;
          this.partitions = spec.partitions;
          this.x = spec.x;
          this.y = spec.y;
          this.dotSet = new DotSet(this.numDots, 3, .5);
        }
        RandomDotMotion.prototype.createDots = function () {
          var dots, xy, _i, _len, _results;
          dots = this.dotSet.nextFrame(this.coherence, this.dotSpeed, 180);
          _results = [];
          for (_i = 0, _len = dots.length; _i < _len; _i++) {
            xy = dots[_i];
            _results.push(new Kinetic.Rect({
              x: this.x + this.apRadius * xy[0],
              y: this.x + this.apRadius * xy[1],
              width: this.dotSize,
              height: this.dotSize,
              fill: 'green'
            }));
          }
          return _results;
        };
        RandomDotMotion.prototype.createInitialDots = function () {
          var dpart, i, xy, _i, _ref, _results;
          _results = [];
          for (i = _i = 0, _ref = this.partitions; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            dpart = this.dotSet.getDotPartition(i);
            _results.push(function () {
              var _j, _len, _results1;
              _results1 = [];
              for (_j = 0, _len = dpart.length; _j < _len; _j++) {
                xy = dpart[_j];
                _results1.push(new Kinetic.Rect({
                  x: this.x + this.apRadius * xy[0],
                  y: this.x + this.apRadius * xy[1],
                  width: this.dotSize,
                  height: this.dotSize,
                  fill: 'green'
                }));
              }
              return _results1;
            }.call(this));
          }
          return _results;
        };
        RandomDotMotion.prototype.displayInitialDots = function (nodes, group) {
          var node, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = nodes.length; _i < _len; _i++) {
            node = nodes[_i];
            _results.push(group.add(node));
          }
          return _results;
        };
        RandomDotMotion.prototype.render = function (context, layer) {
          var i, nodeSets, _i, _ref, _this = this;
          this.groups = function () {
            var _i, _ref, _results;
            _results = [];
            for (i = _i = 0, _ref = this.partitions; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              _results.push(new Kinetic.Group({ listening: false }));
            }
            return _results;
          }.call(this);
          _.map(this.groups, function (g) {
            return layer.add(g);
          });
          nodeSets = this.createInitialDots();
          for (i = _i = 0, _ref = this.partitions; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            this.displayInitialDots(nodeSets[i], this.groups[i]);
          }
          layer.draw();
          this.anim = new Kinetic.Animation(function (frame) {
            var curset, dx, part, xy, _j, _ref1, _results;
            dx = _this.dotSet.nextFrame(_this.coherence, _this.dotSpeed, 180);
            part = _this.dotSet.frameNum % _this.partitions;
            curset = nodeSets[part];
            _results = [];
            for (i = _j = 0, _ref1 = curset.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
              xy = dx[i];
              xy = [
                xy[0] * _this.apRadius,
                xy[1] * _this.apRadius
              ];
              console.log(xy);
              curset[i].setPosition(xy);
              if (!DotSet.inCircle(.5 * _this.apRadius, .5 * _this.apRadius, _this.apRadius / 2, xy[0], xy[1])) {
                _results.push(curset[i].hide());
              } else {
                _results.push(curset[i].show());
              }
            }
            return _results;
          }, layer);
          layer.draw();
          return this.anim.start();
        };
        RandomDotMotion.prototype.render2 = function (context, layer) {
          var i, nodeSets, _i, _ref, _this = this;
          this.layers = function () {
            var _i, _ref, _results;
            _results = [];
            for (i = _i = 0, _ref = this.partitions; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              _results.push(new Kinetic.Layer({ listening: false }));
            }
            return _results;
          }.call(this);
          _.map(this.layers, function (l) {
            return context.stage.add(l);
          });
          nodeSets = this.createInitialDots();
          for (i = _i = 0, _ref = this.partitions; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            this.displayInitialDots(nodeSets[i], this.layers[i]);
          }
          this.anim = new Kinetic.Animation(function (frame) {
            var curset, dx, part, xy, _j, _ref1;
            dx = _this.dotSet.nextFrame(_this.coherence, _this.dotSpeed, 180);
            part = _this.dotSet.frameNum % _this.partitions;
            curset = nodeSets[part];
            for (i = _j = 0, _ref1 = curset.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
              xy = dx[i];
              xy = [
                xy[0] * _this.apRadius,
                xy[1] * _this.apRadius
              ];
              console.log(xy);
              curset[i].setPosition(xy);
            }
            return _this.layers[part].draw();
          });
          layer.draw();
          return this.anim.start();
        };
        RandomDotMotion.prototype.stop = function (context) {
          return this.anim.stop();
        };
        return RandomDotMotion;
      }(Base.Stimulus);
      x = new DotSet(51, 3);
      console.log(x.dotSets);
      console.log('NEXT', x.nextFrame(.5, .01, 180));
    }.call(this));
  });
  require.define('/psycloud.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Block, BlockSeq, DataTable, Event, EventData, EventDataLog, Experiment, ExperimentContext, ExperimentState, MockStimFactory, Prelude, Presenter, Q, RunnableNode, StimFactory, TAFFY, Trial, buildEvent, buildPrelude, buildResponse, buildStimulus, buildTrial, des, utils, _, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      _ = require('/../node_modules/lodash/dist/lodash.js', module);
      Q = require('/../node_modules/q/q.js', module);
      TAFFY = require('/../node_modules/taffydb/taffy.js', module).taffy;
      utils = require('/utils.js', module);
      DataTable = require('/datatable.js', module).DataTable;
      exports.EventData = EventData = function () {
        function EventData(name, id, data) {
          this.name = name;
          this.id = id;
          this.data = data;
        }
        return EventData;
      }();
      exports.EventDataLog = EventDataLog = function () {
        function EventDataLog() {
          this.eventStack = [];
        }
        EventDataLog.prototype.push = function (ev) {
          return this.eventStack.push(ev);
        };
        EventDataLog.prototype.last = function () {
          if (this.eventStack.length < 1) {
            throw 'EventLog is Empty, canot access last element';
          }
          return this.eventStack[this.eventStack.length - 1].data;
        };
        EventDataLog.prototype.findAll = function (id) {
          return _.filter(this.eventStack, function (ev) {
            return ev.id === id;
          });
        };
        EventDataLog.prototype.findLast = function (id) {
          var i, len, _i;
          len = this.eventStack.length - 1;
          for (i = _i = len; len <= 0 ? _i <= 0 : _i >= 0; i = len <= 0 ? ++_i : --_i) {
            if (this.eventStack[i].id === id) {
              return this.eventStack[i];
            }
          }
        };
        return EventDataLog;
      }();
      exports.StimFactory = StimFactory = function () {
        function StimFactory() {
        }
        StimFactory.prototype.buildStimulus = function (spec, context) {
          var params, stimType;
          stimType = _.keys(spec)[0];
          params = _.values(spec)[0];
          return this.makeStimulus(stimType, params, context);
        };
        StimFactory.prototype.buildResponse = function (spec, context) {
          var params, responseType;
          responseType = _.keys(spec)[0];
          params = _.values(spec)[0];
          return this.makeResponse(responseType, params, context);
        };
        StimFactory.prototype.buildEvent = function (spec, context) {
          var response, responseSpec, stim, stimSpec;
          stimSpec = _.omit(spec, 'Next');
          responseSpec = _.pick(spec, 'Next');
          stim = this.buildStimulus(stimSpec, context);
          response = this.buildResponse(responseSpec.Next, context);
          return this.makeEvent(stim, response, context);
        };
        StimFactory.prototype.makeStimulus = function (name, params, context) {
          throw 'unimplemented';
        };
        StimFactory.prototype.makeResponse = function (name, params, context) {
          throw 'unimplemented';
        };
        StimFactory.prototype.makeEvent = function (stim, response, context) {
          throw 'unimplemented';
        };
        return StimFactory;
      }();
      exports.MockStimFactory = MockStimFactory = function (_super) {
        __extends(MockStimFactory, _super);
        function MockStimFactory() {
          _ref = MockStimFactory.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        MockStimFactory.prototype.makeStimulus = function (name, params, context) {
          var ret;
          ret = {};
          ret[name] = params;
          return ret;
        };
        MockStimFactory.prototype.makeResponse = function (name, params, context) {
          var ret;
          ret = {};
          ret[name] = params;
          return ret;
        };
        MockStimFactory.prototype.makeEvent = function (stim, response, context) {
          return [
            stim,
            response
          ];
        };
        return MockStimFactory;
      }(StimFactory);
      exports.RunnableNode = RunnableNode = function () {
        function RunnableNode(children) {
          this.children = children;
        }
        RunnableNode.functionList = function (nodes, context, callback) {
          var _this = this;
          return _.map(nodes, function (node) {
            return function () {
              if (callback != null) {
                callback(node);
              }
              return node.start(context);
            };
          });
        };
        RunnableNode.prototype.before = function (context) {
          return function () {
            return 0;
          };
        };
        RunnableNode.prototype.after = function (context) {
          return function () {
            return 0;
          };
        };
        RunnableNode.chainFunctions = function (funArray) {
          var fun, result, _i, _len;
          result = Q.resolve(0);
          for (_i = 0, _len = funArray.length; _i < _len; _i++) {
            fun = funArray[_i];
            result = result.then(fun, function (err) {
              console.log('caught error', err);
              throw new Error('Error during execution: ', err);
            });
          }
          return result;
        };
        RunnableNode.prototype.numChildren = function () {
          return this.children.length;
        };
        RunnableNode.prototype.length = function () {
          return this.children.length;
        };
        RunnableNode.prototype.start = function (context) {
          var farray;
          farray = RunnableNode.functionList(this.children, context, function (node) {
            return console.log('callback', node);
          });
          return RunnableNode.chainFunctions(_.flatten([
            this.before(context),
            farray,
            this.after(context)
          ]));
        };
        RunnableNode.prototype.stop = function (context) {
        };
        return RunnableNode;
      }();
      exports.Event = Event = function (_super) {
        __extends(Event, _super);
        function Event(stimulus, response) {
          this.stimulus = stimulus;
          this.response = response;
          Event.__super__.constructor.call(this, [this.response]);
        }
        Event.prototype.stop = function (context) {
          this.stimulus.stop(context);
          return this.response.stop(context);
        };
        Event.prototype.before = function (context) {
          var _this = this;
          return function () {
            var self;
            self = _this;
            if (!context.exState.inPrelude) {
              context.updateState(function () {
                return context.exState.nextEvent(self);
              });
            }
            if (!_this.stimulus.overlay) {
              context.clearContent();
            }
            _this.stimulus.render(context, context.contentLayer);
            return context.draw();
          };
        };
        Event.prototype.after = function (context) {
          var _this = this;
          return function () {
            return _this.stimulus.stop(context);
          };
        };
        Event.prototype.start = function (context) {
          console.log('starting event', this.stimulus.name);
          return Event.__super__.start.call(this, context);
        };
        return Event;
      }(RunnableNode);
      exports.Trial = Trial = function (_super) {
        __extends(Trial, _super);
        function Trial(events, record, feedback, background) {
          if (events == null) {
            events = [];
          }
          this.record = record != null ? record : {};
          this.feedback = feedback;
          this.background = background;
          Trial.__super__.constructor.call(this, events);
        }
        Trial.prototype.numEvents = function () {
          return this.children.length;
        };
        Trial.prototype.push = function (event) {
          return this.children.push(event);
        };
        Trial.prototype.before = function (context) {
          var _this = this;
          return function () {
            var self;
            self = _this;
            context.updateState(function () {
              return context.exState.nextTrial(self);
            });
            context.clearBackground();
            if (_this.background != null) {
              context.setBackground(_this.background);
              return context.drawBackground();
            }
          };
        };
        Trial.prototype.after = function (context) {
          var _this = this;
          return function () {
            var event, spec;
            if (_this.feedback != null) {
              console.log('last event ', context.eventDB().last());
              spec = _this.feedback(context.eventDB);
              console.log('spec is', spec);
              event = context.stimFactory.buildEvent(spec, context);
              return event.start(context);
            } else {
              return Q.fcall(0);
            }
          };
        };
        Trial.prototype.start = function (context) {
          var farray;
          farray = RunnableNode.functionList(this.children, context, function (event) {
            return console.log('event callback', event);
          });
          return RunnableNode.chainFunctions(_.flatten([
            this.before(context),
            farray,
            this.after(context)
          ]));
        };
        Trial.prototype.stop = function (context) {
        };
        return Trial;
      }(RunnableNode);
      exports.Block = Block = function (_super) {
        __extends(Block, _super);
        function Block(children, blockSpec) {
          this.blockSpec = blockSpec;
          Block.__super__.constructor.call(this, children);
        }
        Block.prototype.showEvent = function (spec, context) {
          var event;
          event = buildEvent(spec, context);
          return event.start(context);
        };
        Block.prototype.before = function (context) {
          var self, _this = this;
          self = this;
          return function () {
            var spec;
            context.updateState(function () {
              return context.exState.nextBlock(self);
            });
            if (_this.blockSpec != null && _this.blockSpec.Start) {
              spec = _this.blockSpec.Start(context);
              return _this.showEvent(spec, context);
            } else {
              return Q.fcall(0);
            }
          };
        };
        Block.prototype.after = function (context) {
          var _this = this;
          return function () {
            var spec;
            if (_this.blockSpec != null && _this.blockSpec.End) {
              spec = _this.blockSpec.End(context);
              return _this.showEvent(spec, context);
            } else {
              return Q.fcall(0);
            }
          };
        };
        return Block;
      }(RunnableNode);
      exports.BlockSeq = BlockSeq = function (_super) {
        __extends(BlockSeq, _super);
        function BlockSeq(children) {
          BlockSeq.__super__.constructor.call(this, children);
        }
        return BlockSeq;
      }(RunnableNode);
      exports.Prelude = Prelude = function (_super) {
        __extends(Prelude, _super);
        function Prelude(children) {
          Prelude.__super__.constructor.call(this, children);
        }
        Prelude.prototype.before = function (context) {
          var _this = this;
          return function () {
            return context.updateState(function () {
              console.log('setting in prelude!');
              console.log('exState is', context.exState);
              return context.exState.insidePrelude();
            });
          };
        };
        Prelude.prototype.after = function (context) {
          var _this = this;
          return function () {
            return context.updateState(function () {
              return context.exState.outsidePrelude();
            });
          };
        };
        return Prelude;
      }(RunnableNode);
      exports.ExperimentState = ExperimentState = function () {
        function ExperimentState() {
          this.inPrelude = false;
          this.trial = {};
          this.block = {};
          this.event = {};
          this.blockNumber = 0;
          this.trialNumber = 0;
          this.eventNumber = 0;
          this.stimulus = {};
          this.response = {};
        }
        ExperimentState.prototype.insidePrelude = function () {
          var ret;
          ret = $.extend({}, this);
          ret.inPrelude = true;
          return ret;
        };
        ExperimentState.prototype.outsidePrelude = function () {
          var ret;
          ret = $.extend({}, this);
          ret.inPrelude = false;
          return ret;
        };
        ExperimentState.prototype.nextBlock = function (block) {
          var ret;
          ret = $.extend({}, this);
          ret.blockNumber = this.blockNumber + 1;
          ret.block = block;
          return ret;
        };
        ExperimentState.prototype.nextTrial = function (trial) {
          var ret;
          ret = $.extend({}, this);
          ret.trial = trial;
          ret.trialNumber = this.trialNumber + 1;
          return ret;
        };
        ExperimentState.prototype.nextEvent = function (event) {
          var ret;
          console.log('next Event');
          ret = $.extend({}, this);
          ret.event = event;
          ret.eventNumber = this.eventNumber + 1;
          return ret;
        };
        ExperimentState.prototype.toRecord = function () {
          var key, ret, value, _ref1, _ref10, _ref11, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
          ret = {
            $blockNumber: this.blockNumber,
            $trialNumber: this.trialNumber,
            $eventNumber: this.eventNumber,
            $stimulus: (_ref1 = this.event) != null ? (_ref2 = _ref1.stimulus) != null ? (_ref3 = _ref2.constructor) != null ? _ref3.name : void 0 : void 0 : void 0,
            $response: (_ref4 = this.event) != null ? (_ref5 = _ref4.response) != null ? (_ref6 = _ref5.constructor) != null ? _ref6.name : void 0 : void 0 : void 0,
            $stimulusID: (_ref7 = this.event) != null ? (_ref8 = _ref7.stimulus) != null ? _ref8.id : void 0 : void 0,
            $responseID: (_ref9 = this.event) != null ? (_ref10 = _ref9.response) != null ? _ref10.id : void 0 : void 0
          };
          if (!_.isEmpty(this.trial) && this.trial.record != null) {
            _ref11 = this.trial.record;
            for (key in _ref11) {
              value = _ref11[key];
              ret[key] = value;
            }
          }
          return ret;
        };
        return ExperimentState;
      }();
      exports.ExperimentContext = ExperimentContext = function () {
        function ExperimentContext(stimFactory) {
          this.stimFactory = stimFactory;
          this.eventDB = TAFFY({});
          this.exState = new ExperimentState;
          this.eventData = new EventDataLog;
          this.log = [];
          this.trialNumber = 0;
          this.currentTrial = new Trial([], {});
        }
        ExperimentContext.prototype.updateState = function (fun) {
          this.exState = fun(this.exState);
          console.log('new state is', this.exState);
          console.log('record is', this.exState.toRecord());
          return this.exState;
        };
        ExperimentContext.prototype.pushData = function (data, withState) {
          var record;
          if (withState == null) {
            withState = true;
          }
          if (withState) {
            record = _.extend(this.exState.toRecord(), data);
          } else {
            record = data;
          }
          this.eventDB.insert(record);
          return console.log('db is now', this.eventDB().get());
        };
        ExperimentContext.prototype.logEvent = function (key, value) {
          var record;
          record = _.clone(this.currentTrial.record);
          record[key] = value;
          this.log.push(record);
          return console.log(this.log);
        };
        ExperimentContext.prototype.showEvent = function (event) {
          return event.start(this);
        };
        ExperimentContext.prototype.start = function (blockList) {
          var error, farray;
          try {
            farray = RunnableNode.functionList(blockList, this, function (block) {
              return console.log('block callback', block);
            });
            return RunnableNode.chainFunctions(farray);
          } catch (_error) {
            error = _error;
            return console.log('caught error:', error);
          }
        };
        ExperimentContext.prototype.clearContent = function () {
        };
        ExperimentContext.prototype.clearBackground = function () {
        };
        ExperimentContext.prototype.keydownStream = function () {
        };
        ExperimentContext.prototype.keypressStream = function () {
        };
        ExperimentContext.prototype.mousepressStream = function () {
        };
        ExperimentContext.prototype.draw = function () {
        };
        ExperimentContext.prototype.insertHTMLDiv = function () {
          $('canvas').css('position', 'absolute');
          $('#container').append('<div id="htmlcontainer" class="htmllayer"></div>');
          $('#htmlcontainer').css({
            position: 'absolute',
            'z-index': 999,
            outline: 'none',
            padding: '5px'
          });
          $('#container').attr('tabindex', 0);
          $('#container').css('outline', 'none');
          return $('#container').css('padding', '5px');
        };
        ExperimentContext.prototype.clearHtml = function () {
          $('#htmlcontainer').empty();
          return $('#htmlcontainer').hide();
        };
        ExperimentContext.prototype.appendHtml = function (input) {
          $('#htmlcontainer').addClass('htmllayer');
          $('#htmlcontainer').append(input);
          return $('#htmlcontainer').show();
        };
        ExperimentContext.prototype.hideHtml = function () {
          return $('#htmlcontainer').hide();
        };
        return ExperimentContext;
      }();
      buildStimulus = function (spec, context) {
        var params, stimType;
        stimType = _.keys(spec)[0];
        params = _.values(spec)[0];
        return context.stimFactory.makeStimulus(stimType, params, context);
      };
      buildResponse = function (spec, context) {
        var params, responseType;
        responseType = _.keys(spec)[0];
        console.log('response type', responseType);
        params = _.values(spec)[0];
        console.log('params', params);
        return context.stimFactory.makeResponse(responseType, params, context);
      };
      buildEvent = function (spec, context) {
        var response, responseSpec, stim, stimSpec;
        stimSpec = _.omit(spec, 'Next');
        responseSpec = _.pick(spec, 'Next');
        console.log('stim Spec', stimSpec);
        console.log('response Spec', responseSpec);
        if (responseSpec == null || _.isEmpty(responseSpec)) {
          console.log('keys of stimspec', _.keys(stimSpec));
          stim = buildStimulus(stimSpec, context);
          console.log('stim is', stim);
          return context.stimFactory.makeEvent(stim, stim, context);
        } else {
          stim = buildStimulus(stimSpec, context);
          console.log('stim', stim);
          response = buildResponse(responseSpec.Next, context);
          console.log('response', response);
          return context.stimFactory.makeEvent(stim, response, context);
        }
      };
      buildTrial = function (eventSpec, record, context, feedback, background) {
        var events, key, response, responseSpec, stim, stimSpec, value;
        events = function () {
          var _results;
          _results = [];
          for (key in eventSpec) {
            value = eventSpec[key];
            stimSpec = _.omit(value, 'Next');
            responseSpec = _.pick(value, 'Next');
            stim = buildStimulus(stimSpec, context);
            response = buildResponse(responseSpec.Next, context);
            _results.push(context.stimFactory.makeEvent(stim, response, context));
          }
          return _results;
        }();
        console.log('building trial with record', record);
        return new Trial(events, record, feedback, background);
      };
      buildPrelude = function (preludeSpec, context) {
        var events, key, spec, value;
        console.log('building prelude');
        events = function () {
          var _results;
          _results = [];
          for (key in preludeSpec) {
            value = preludeSpec[key];
            spec = {};
            spec[key] = value;
            console.log('prelude spec', spec);
            _results.push(buildEvent(spec, context));
          }
          return _results;
        }();
        console.log('prelude events', events);
        return new Prelude(events);
      };
      exports.Presenter = Presenter = function () {
        function Presenter(trialList, display, context) {
          this.trialList = trialList;
          this.display = display;
          this.context = context;
          this.trialBuilder = this.display.Trial;
          this.prelude = this.display.Prelude != null ? buildPrelude(this.display.Prelude, this.context) : new Prelude([]);
          console.log('prelude is', this.prelude);
        }
        Presenter.prototype.start = function () {
          var block, record, trialNum, trialSpec, trials, _this = this;
          this.blockList = new BlockSeq(function () {
            var _i, _len, _ref1, _results;
            _ref1 = this.trialList.blocks;
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              block = _ref1[_i];
              trials = function () {
                var _j, _ref2, _results1;
                _results1 = [];
                for (trialNum = _j = 0, _ref2 = block.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; trialNum = 0 <= _ref2 ? ++_j : --_j) {
                  record = _.clone(block[trialNum]);
                  trialSpec = this.trialBuilder(record);
                  _results1.push(buildTrial(trialSpec.Events, record, this.context, trialSpec.Feedback));
                }
                return _results1;
              }.call(this);
              _results.push(new Block(trials, this.display.Block));
            }
            return _results;
          }.call(this));
          return this.prelude.start(this.context).then(function () {
            return _this.blockList.start(_this.context);
          });
        };
        return Presenter;
      }();
      exports.Experiment = Experiment = function () {
        function Experiment(designSpec, stimFactory) {
          this.designSpec = designSpec;
          this.stimFactory = stimFactory != null ? stimFactory : new MockStimFactory;
          this.design = new ExpDesign(this.designSpec);
          this.display = this.designSpec.Display;
          this.trialGenerator = this.display.Trial;
        }
        Experiment.prototype.buildStimulus = function (event, context) {
          var params, stimType;
          stimType = _.keys(event)[0];
          params = _.values(event)[0];
          return this.stimFactory.makeStimulus(stimType, params, context);
        };
        Experiment.prototype.buildEvent = function (event, context) {
          var params, responseType;
          responseType = _.keys(event)[0];
          params = _.values(event)[0];
          return this.stimFactory.makeResponse(responseType, params, context);
        };
        Experiment.prototype.buildTrial = function (eventSpec, record, context) {
          var events, key, response, responseSpec, stim, stimSpec, value;
          events = function () {
            var _results;
            _results = [];
            for (key in eventSpec) {
              value = eventSpec[key];
              stimSpec = _.omit(value, 'Next');
              responseSpec = _.pick(value, 'Next');
              stim = this.buildStimulus(stimSpec);
              response = this.buildResponse(responseSpec.Next);
              _results.push(this.stimFactory.makeEvent(stim, response));
            }
            return _results;
          }.call(this);
          return new Trial(events, record);
        };
        Experiment.prototype.start = function (context) {
          var i, record, trialList, trialSpec, trials;
          trials = this.design.fullDesign;
          console.log(trials.nrow());
          trialList = function () {
            var _i, _ref1, _results;
            _results = [];
            for (i = _i = 0, _ref1 = trials.nrow(); 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
              record = trials.record(i);
              record.$trialNumber = i;
              trialSpec = this.trialGenerator(record);
              _results.push(this.buildTrial(trialSpec, record, context));
            }
            return _results;
          }.call(this);
          return context.start(trialList);
        };
        return Experiment;
      }();
      des = {
        Design: {
          Blocks: [
            [{
                a: 1,
                b: 2,
                c: 3,
                a: 2,
                b: 3,
                c: 4
              }],
            [{
                a: 5,
                b: 7,
                c: 6,
                a: 5,
                b: 7,
                c: 6
              }]
          ]
        }
      };
      console.log(des.Blocks);
      exports.buildStimulus = buildStimulus;
      exports.buildResponse = buildResponse;
      exports.buildEvent = buildEvent;
      exports.buildTrial = buildTrial;
      exports.buildPrelude = buildPrelude;
    }.call(this));
  });
  require.define('/../node_modules/taffydb/taffy.js', function (module, exports, __dirname, __filename) {
    var TAFFY, exports, T;
    (function () {
      'use strict';
      var typeList, makeTest, idx, typeKey, version, TC, idpad, cmax, API, protectJSON, each, eachin, isIndexable, returnFilter, runFilters, numcharsplit, orderByCol, run, intersection, filter, makeCid, safeForJson, isRegexp;
      ;
      if (!TAFFY) {
        version = '2.7';
        TC = 1;
        idpad = '000000';
        cmax = 1e3;
        API = {};
        protectJSON = function (t) {
          if (TAFFY.isArray(t) || TAFFY.isObject(t)) {
            return t;
          } else {
            return JSON.parse(t);
          }
        };
        intersection = function (array1, array2) {
          return filter(array1, function (item) {
            return array2.indexOf(item) >= 0;
          });
        };
        filter = function (obj, iterator, context) {
          var results = [];
          if (obj == null)
            return results;
          if (Array.prototype.filter && obj.filter === Array.prototype.filter)
            return obj.filter(iterator, context);
          each(obj, function (value, index, list) {
            if (iterator.call(context, value, index, list))
              results[results.length] = value;
          });
          return results;
        };
        isRegexp = function (aObj) {
          return Object.prototype.toString.call(aObj) === '[object RegExp]';
        };
        safeForJson = function (aObj) {
          var myResult = T.isArray(aObj) ? [] : T.isObject(aObj) ? {} : null;
          if (aObj === null)
            return aObj;
          for (var i in aObj) {
            myResult[i] = isRegexp(aObj[i]) ? aObj[i].toString() : T.isArray(aObj[i]) || T.isObject(aObj[i]) ? safeForJson(aObj[i]) : aObj[i];
          }
          return myResult;
        };
        makeCid = function (aContext) {
          var myCid = JSON.stringify(aContext);
          if (myCid.match(/regex/) === null)
            return myCid;
          return JSON.stringify(safeForJson(aContext));
        };
        each = function (a, fun, u) {
          var r, i, x, y;
          if (a && (T.isArray(a) && a.length === 1 || !T.isArray(a))) {
            fun(T.isArray(a) ? a[0] : a, 0);
          } else {
            for (r, i, x = 0, a = T.isArray(a) ? a : [a], y = a.length; x < y; x++) {
              i = a[x];
              if (!T.isUndefined(i) || (u || false)) {
                r = fun(i, x);
                if (r === T.EXIT) {
                  break;
                }
              }
            }
          }
        };
        eachin = function (o, fun) {
          var x = 0, r, i;
          for (i in o) {
            if (o.hasOwnProperty(i)) {
              r = fun(o[i], i, x++);
              if (r === T.EXIT) {
                break;
              }
            }
          }
        };
        API.extend = function (m, f) {
          API[m] = function () {
            return f.apply(this, arguments);
          };
        };
        isIndexable = function (f) {
          var i;
          if (T.isString(f) && /[t][0-9]*[r][0-9]*/i.test(f)) {
            return true;
          }
          if (T.isObject(f) && f.___id && f.___s) {
            return true;
          }
          if (T.isArray(f)) {
            i = true;
            each(f, function (r) {
              if (!isIndexable(r)) {
                i = false;
                return TAFFY.EXIT;
              }
            });
            return i;
          }
          return false;
        };
        runFilters = function (r, filter) {
          var match = true;
          each(filter, function (mf) {
            switch (T.typeOf(mf)) {
            case 'function':
              if (!mf.apply(r)) {
                match = false;
                return TAFFY.EXIT;
              }
              break;
            case 'array':
              match = mf.length === 1 ? runFilters(r, mf[0]) : mf.length === 2 ? runFilters(r, mf[0]) || runFilters(r, mf[1]) : mf.length === 3 ? runFilters(r, mf[0]) || runFilters(r, mf[1]) || runFilters(r, mf[2]) : mf.length === 4 ? runFilters(r, mf[0]) || runFilters(r, mf[1]) || runFilters(r, mf[2]) || runFilters(r, mf[3]) : false;
              if (mf.length > 4) {
                each(mf, function (f) {
                  if (runFilters(r, f)) {
                    match = true;
                  }
                });
              }
              break;
            }
          });
          return match;
        };
        returnFilter = function (f) {
          var nf = [];
          if (T.isString(f) && /[t][0-9]*[r][0-9]*/i.test(f)) {
            f = { ___id: f };
          }
          if (T.isArray(f)) {
            each(f, function (r) {
              nf.push(returnFilter(r));
            });
            f = function () {
              var that = this, match = false;
              each(nf, function (f) {
                if (runFilters(that, f)) {
                  match = true;
                }
              });
              return match;
            };
            return f;
          }
          if (T.isObject(f)) {
            if (T.isObject(f) && f.___id && f.___s) {
              f = { ___id: f.___id };
            }
            eachin(f, function (v, i) {
              if (!T.isObject(v)) {
                v = { 'is': v };
              }
              eachin(v, function (mtest, s) {
                var c = [], looper;
                looper = s === 'hasAll' ? function (mtest, func) {
                  func(mtest);
                } : each;
                looper(mtest, function (mtest) {
                  var su = true, f = false, matchFunc;
                  matchFunc = function () {
                    var mvalue = this[i], eqeq = '==', bangeq = '!=', eqeqeq = '===', lt = '<', gt = '>', lteq = '<=', gteq = '>=', bangeqeq = '!==', r;
                    ;
                    if (typeof mvalue === 'undefined') {
                      return false;
                    }
                    if (s.indexOf('!') === 0 && s !== bangeq && s !== bangeqeq) {
                      su = false;
                      s = s.substring(1, s.length);
                    }
                    r = s === 'regex' ? mtest.test(mvalue) : s === 'lt' || s === lt ? mvalue < mtest : s === 'gt' || s === gt ? mvalue > mtest : s === 'lte' || s === lteq ? mvalue <= mtest : s === 'gte' || s === gteq ? mvalue >= mtest : s === 'left' ? mvalue.indexOf(mtest) === 0 : s === 'leftnocase' ? mvalue.toLowerCase().indexOf(mtest.toLowerCase()) === 0 : s === 'right' ? mvalue.substring(mvalue.length - mtest.length) === mtest : s === 'rightnocase' ? mvalue.toLowerCase().substring(mvalue.length - mtest.length) === mtest.toLowerCase() : s === 'like' ? mvalue.indexOf(mtest) >= 0 : s === 'likenocase' ? mvalue.toLowerCase().indexOf(mtest.toLowerCase()) >= 0 : s === eqeqeq || s === 'is' ? mvalue === mtest : s === eqeq ? mvalue == mtest : s === bangeqeq ? mvalue !== mtest : s === bangeq ? mvalue != mtest : s === 'isnocase' ? mvalue.toLowerCase ? mvalue.toLowerCase() === mtest.toLowerCase() : mvalue === mtest : s === 'has' ? T.has(mvalue, mtest) : s === 'hasall' ? T.hasAll(mvalue, mtest) : s === 'contains' ? TAFFY.isArray(mvalue) && mvalue.indexOf(mtest) > -1 : s.indexOf('is') === -1 && !TAFFY.isNull(mvalue) && !TAFFY.isUndefined(mvalue) && !TAFFY.isObject(mtest) && !TAFFY.isArray(mtest) ? mtest === mvalue[s] : T[s] && T.isFunction(T[s]) && s.indexOf('is') === 0 ? T[s](mvalue) === mtest : T[s] && T.isFunction(T[s]) ? T[s](mvalue, mtest) : false;
                    r = r && !su ? false : !r && !su ? true : r;
                    return r;
                  };
                  c.push(matchFunc);
                });
                if (c.length === 1) {
                  nf.push(c[0]);
                } else {
                  nf.push(function () {
                    var that = this, match = false;
                    each(c, function (f) {
                      if (f.apply(that)) {
                        match = true;
                      }
                    });
                    return match;
                  });
                }
              });
            });
            f = function () {
              var that = this, match = true;
              match = nf.length === 1 && !nf[0].apply(that) ? false : nf.length === 2 && (!nf[0].apply(that) || !nf[1].apply(that)) ? false : nf.length === 3 && (!nf[0].apply(that) || !nf[1].apply(that) || !nf[2].apply(that)) ? false : nf.length === 4 && (!nf[0].apply(that) || !nf[1].apply(that) || !nf[2].apply(that) || !nf[3].apply(that)) ? false : true;
              if (nf.length > 4) {
                each(nf, function (f) {
                  if (!runFilters(that, f)) {
                    match = false;
                  }
                });
              }
              return match;
            };
            return f;
          }
          if (T.isFunction(f)) {
            return f;
          }
        };
        orderByCol = function (ar, o) {
          var sortFunc = function (a, b) {
            var r = 0;
            T.each(o, function (sd) {
              var o, col, dir, c, d;
              o = sd.split(' ');
              col = o[0];
              dir = o.length === 1 ? 'logical' : o[1];
              if (dir === 'logical') {
                c = numcharsplit(a[col]);
                d = numcharsplit(b[col]);
                T.each(c.length <= d.length ? c : d, function (x, i) {
                  if (c[i] < d[i]) {
                    r = -1;
                    return TAFFY.EXIT;
                  } else if (c[i] > d[i]) {
                    r = 1;
                    return TAFFY.EXIT;
                  }
                });
              } else if (dir === 'logicaldesc') {
                c = numcharsplit(a[col]);
                d = numcharsplit(b[col]);
                T.each(c.length <= d.length ? c : d, function (x, i) {
                  if (c[i] > d[i]) {
                    r = -1;
                    return TAFFY.EXIT;
                  } else if (c[i] < d[i]) {
                    r = 1;
                    return TAFFY.EXIT;
                  }
                });
              } else if (dir === 'asec' && a[col] < b[col]) {
                r = -1;
                return T.EXIT;
              } else if (dir === 'asec' && a[col] > b[col]) {
                r = 1;
                return T.EXIT;
              } else if (dir === 'desc' && a[col] > b[col]) {
                r = -1;
                return T.EXIT;
              } else if (dir === 'desc' && a[col] < b[col]) {
                r = 1;
                return T.EXIT;
              }
              if (r === 0 && dir === 'logical' && c.length < d.length) {
                r = -1;
              } else if (r === 0 && dir === 'logical' && c.length > d.length) {
                r = 1;
              } else if (r === 0 && dir === 'logicaldesc' && c.length > d.length) {
                r = -1;
              } else if (r === 0 && dir === 'logicaldesc' && c.length < d.length) {
                r = 1;
              }
              if (r !== 0) {
                return T.EXIT;
              }
            });
            return r;
          };
          return ar && ar.push ? ar.sort(sortFunc) : ar;
        };
        (function () {
          var cache = {}, cachcounter = 0;
          numcharsplit = function (thing) {
            if (cachcounter > cmax) {
              cache = {};
              cachcounter = 0;
            }
            return cache['_' + thing] || function () {
              var nthing = String(thing), na = [], rv = '_', rt = '', x, xx, c;
              for (x = 0, xx = nthing.length; x < xx; x++) {
                c = nthing.charCodeAt(x);
                if (c >= 48 && c <= 57 || c === 46) {
                  if (rt !== 'n') {
                    rt = 'n';
                    na.push(rv.toLowerCase());
                    rv = '';
                  }
                  rv = rv + nthing.charAt(x);
                } else {
                  if (rt !== 's') {
                    rt = 's';
                    na.push(parseFloat(rv));
                    rv = '';
                  }
                  rv = rv + nthing.charAt(x);
                }
              }
              na.push(rt === 'n' ? parseFloat(rv) : rv.toLowerCase());
              na.shift();
              cache['_' + thing] = na;
              cachcounter++;
              return na;
            }();
          };
        }());
        run = function () {
          this.context({ results: this.getDBI().query(this.context()) });
        };
        API.extend('filter', function () {
          var nc = TAFFY.mergeObj(this.context(), { run: null }), nq = [];
          ;
          each(nc.q, function (v) {
            nq.push(v);
          });
          nc.q = nq;
          each(arguments, function (f) {
            nc.q.push(returnFilter(f));
            nc.filterRaw.push(f);
          });
          return this.getroot(nc);
        });
        API.extend('order', function (o) {
          o = o.split(',');
          var x = [], nc;
          each(o, function (r) {
            x.push(r.replace(/^\s*/, '').replace(/\s*$/, ''));
          });
          nc = TAFFY.mergeObj(this.context(), { sort: null });
          nc.order = x;
          return this.getroot(nc);
        });
        API.extend('limit', function (n) {
          var nc = TAFFY.mergeObj(this.context(), {}), limitedresults;
          ;
          nc.limit = n;
          if (nc.run && nc.sort) {
            limitedresults = [];
            each(nc.results, function (i, x) {
              if (x + 1 > n) {
                return TAFFY.EXIT;
              }
              limitedresults.push(i);
            });
            nc.results = limitedresults;
          }
          return this.getroot(nc);
        });
        API.extend('start', function (n) {
          var nc = TAFFY.mergeObj(this.context(), {}), limitedresults;
          ;
          nc.start = n;
          if (nc.run && nc.sort && !nc.limit) {
            limitedresults = [];
            each(nc.results, function (i, x) {
              if (x + 1 > n) {
                limitedresults.push(i);
              }
            });
            nc.results = limitedresults;
          } else {
            nc = TAFFY.mergeObj(this.context(), {
              run: null,
              start: n
            });
          }
          return this.getroot(nc);
        });
        API.extend('update', function (arg0, arg1, arg2) {
          var runEvent = true, o = {}, args = arguments, that;
          if (TAFFY.isString(arg0) && (arguments.length === 2 || arguments.length === 3)) {
            o[arg0] = arg1;
            if (arguments.length === 3) {
              runEvent = arg2;
            }
          } else {
            o = arg0;
            if (args.length === 2) {
              runEvent = arg1;
            }
          }
          that = this;
          run.call(this);
          each(this.context().results, function (r) {
            var c = o;
            if (TAFFY.isFunction(c)) {
              c = c.apply(TAFFY.mergeObj(r, {}));
            } else {
              if (T.isFunction(c)) {
                c = c(TAFFY.mergeObj(r, {}));
              }
            }
            if (TAFFY.isObject(c)) {
              that.getDBI().update(r.___id, c, runEvent);
            }
          });
          if (this.context().results.length) {
            this.context({ run: null });
          }
          return this;
        });
        API.extend('remove', function (runEvent) {
          var that = this, c = 0;
          run.call(this);
          each(this.context().results, function (r) {
            that.getDBI().remove(r.___id);
            c++;
          });
          if (this.context().results.length) {
            this.context({ run: null });
            that.getDBI().removeCommit(runEvent);
          }
          return c;
        });
        API.extend('count', function () {
          run.call(this);
          return this.context().results.length;
        });
        API.extend('callback', function (f, delay) {
          if (f) {
            var that = this;
            setTimeout(function () {
              run.call(that);
              f.call(that.getroot(that.context()));
            }, delay || 0);
          }
          return null;
        });
        API.extend('get', function () {
          run.call(this);
          return this.context().results;
        });
        API.extend('stringify', function () {
          return JSON.stringify(this.get());
        });
        API.extend('first', function () {
          run.call(this);
          return this.context().results[0] || false;
        });
        API.extend('last', function () {
          run.call(this);
          return this.context().results[this.context().results.length - 1] || false;
        });
        API.extend('sum', function () {
          var total = 0, that = this;
          run.call(that);
          each(arguments, function (c) {
            each(that.context().results, function (r) {
              total = total + (r[c] || 0);
            });
          });
          return total;
        });
        API.extend('min', function (c) {
          var lowest = null;
          run.call(this);
          each(this.context().results, function (r) {
            if (lowest === null || r[c] < lowest) {
              lowest = r[c];
            }
          });
          return lowest;
        });
        (function () {
          var innerJoinFunction = function () {
              var fnCompareList, fnCombineRow, fnMain;
              fnCompareList = function (left_row, right_row, arg_list) {
                var data_lt, data_rt, op_code, error;
                if (arg_list.length === 2) {
                  data_lt = left_row[arg_list[0]];
                  op_code = '===';
                  data_rt = right_row[arg_list[1]];
                } else {
                  data_lt = left_row[arg_list[0]];
                  op_code = arg_list[1];
                  data_rt = right_row[arg_list[2]];
                }
                switch (op_code) {
                case '===':
                  return data_lt === data_rt;
                case '!==':
                  return data_lt !== data_rt;
                case '<':
                  return data_lt < data_rt;
                case '>':
                  return data_lt > data_rt;
                case '<=':
                  return data_lt <= data_rt;
                case '>=':
                  return data_lt >= data_rt;
                case '==':
                  return data_lt == data_rt;
                case '!=':
                  return data_lt != data_rt;
                default:
                  throw String(op_code) + ' is not supported';
                }
              };
              fnCombineRow = function (left_row, right_row) {
                var out_map = {}, i, prefix;
                for (i in left_row) {
                  if (left_row.hasOwnProperty(i)) {
                    out_map[i] = left_row[i];
                  }
                }
                for (i in right_row) {
                  if (right_row.hasOwnProperty(i) && i !== '___id' && i !== '___s') {
                    prefix = !TAFFY.isUndefined(out_map[i]) ? 'right_' : '';
                    out_map[prefix + String(i)] = right_row[i];
                  }
                }
                return out_map;
              };
              fnMain = function (table) {
                var right_table, i, arg_list = arguments, arg_length = arg_list.length, result_list = [];
                ;
                if (typeof table.filter !== 'function') {
                  if (table.TAFFY) {
                    right_table = table();
                  } else {
                    throw 'TAFFY DB or result not supplied';
                  }
                } else {
                  right_table = table;
                }
                this.context({ results: this.getDBI().query(this.context()) });
                TAFFY.each(this.context().results, function (left_row) {
                  right_table.each(function (right_row) {
                    var arg_data, is_ok = true;
                    CONDITION:
                      for (i = 1; i < arg_length; i++) {
                        arg_data = arg_list[i];
                        if (typeof arg_data === 'function') {
                          is_ok = arg_data(left_row, right_row);
                        } else if (typeof arg_data === 'object' && arg_data.length) {
                          is_ok = fnCompareList(left_row, right_row, arg_data);
                        } else {
                          is_ok = false;
                        }
                        if (!is_ok) {
                          break CONDITION;
                        }
                      }
                    if (is_ok) {
                      result_list.push(fnCombineRow(left_row, right_row));
                    }
                  });
                });
                return TAFFY(result_list)();
              };
              return fnMain;
            }();
          API.extend('join', innerJoinFunction);
        }());
        API.extend('max', function (c) {
          var highest = null;
          run.call(this);
          each(this.context().results, function (r) {
            if (highest === null || r[c] > highest) {
              highest = r[c];
            }
          });
          return highest;
        });
        API.extend('select', function () {
          var ra = [], args = arguments;
          run.call(this);
          if (arguments.length === 1) {
            each(this.context().results, function (r) {
              ra.push(r[args[0]]);
            });
          } else {
            each(this.context().results, function (r) {
              var row = [];
              each(args, function (c) {
                row.push(r[c]);
              });
              ra.push(row);
            });
          }
          return ra;
        });
        API.extend('distinct', function () {
          var ra = [], args = arguments;
          run.call(this);
          if (arguments.length === 1) {
            each(this.context().results, function (r) {
              var v = r[args[0]], dup = false;
              each(ra, function (d) {
                if (v === d) {
                  dup = true;
                  return TAFFY.EXIT;
                }
              });
              if (!dup) {
                ra.push(v);
              }
            });
          } else {
            each(this.context().results, function (r) {
              var row = [], dup = false;
              each(args, function (c) {
                row.push(r[c]);
              });
              each(ra, function (d) {
                var ldup = true;
                each(args, function (c, i) {
                  if (row[i] !== d[i]) {
                    ldup = false;
                    return TAFFY.EXIT;
                  }
                });
                if (ldup) {
                  dup = true;
                  return TAFFY.EXIT;
                }
              });
              if (!dup) {
                ra.push(row);
              }
            });
          }
          return ra;
        });
        API.extend('supplant', function (template, returnarray) {
          var ra = [];
          run.call(this);
          each(this.context().results, function (r) {
            ra.push(template.replace(/\{([^\{\}]*)\}/g, function (a, b) {
              var v = r[b];
              return typeof v === 'string' || typeof v === 'number' ? v : a;
            }));
          });
          return !returnarray ? ra.join('') : ra;
        });
        API.extend('each', function (m) {
          run.call(this);
          each(this.context().results, m);
          return this;
        });
        API.extend('map', function (m) {
          var ra = [];
          run.call(this);
          each(this.context().results, function (r) {
            ra.push(m(r));
          });
          return ra;
        });
        T = function (d) {
          var TOb = [], ID = {}, RC = 1, settings = {
              template: false,
              onInsert: false,
              onUpdate: false,
              onRemove: false,
              onDBChange: false,
              storageName: false,
              forcePropertyCase: null,
              cacheSize: 100,
              name: ''
            }, dm = new Date, CacheCount = 0, CacheClear = 0, Cache = {}, DBI, runIndexes, root;
          ;
          runIndexes = function (indexes) {
            var records = [], UniqueEnforce = false;
            if (indexes.length === 0) {
              return TOb;
            }
            each(indexes, function (f) {
              if (T.isString(f) && /[t][0-9]*[r][0-9]*/i.test(f) && TOb[ID[f]]) {
                records.push(TOb[ID[f]]);
                UniqueEnforce = true;
              }
              if (T.isObject(f) && f.___id && f.___s && TOb[ID[f.___id]]) {
                records.push(TOb[ID[f.___id]]);
                UniqueEnforce = true;
              }
              if (T.isArray(f)) {
                each(f, function (r) {
                  each(runIndexes(r), function (rr) {
                    records.push(rr);
                  });
                });
              }
            });
            if (UniqueEnforce && records.length > 1) {
              records = [];
            }
            return records;
          };
          DBI = {
            dm: function (nd) {
              if (nd) {
                dm = nd;
                Cache = {};
                CacheCount = 0;
                CacheClear = 0;
              }
              if (settings.onDBChange) {
                setTimeout(function () {
                  settings.onDBChange.call(TOb);
                }, 0);
              }
              if (settings.storageName) {
                setTimeout(function () {
                  localStorage.setItem('taffy_' + settings.storageName, JSON.stringify(TOb));
                });
              }
              return dm;
            },
            insert: function (i, runEvent) {
              var columns = [], records = [], input = protectJSON(i);
              ;
              each(input, function (v, i) {
                var nv, o;
                if (T.isArray(v) && i === 0) {
                  each(v, function (av) {
                    columns.push(settings.forcePropertyCase === 'lower' ? av.toLowerCase() : settings.forcePropertyCase === 'upper' ? av.toUpperCase() : av);
                  });
                  return true;
                } else if (T.isArray(v)) {
                  nv = {};
                  each(v, function (av, ai) {
                    nv[columns[ai]] = av;
                  });
                  v = nv;
                } else if (T.isObject(v) && settings.forcePropertyCase) {
                  o = {};
                  eachin(v, function (av, ai) {
                    o[settings.forcePropertyCase === 'lower' ? ai.toLowerCase() : settings.forcePropertyCase === 'upper' ? ai.toUpperCase() : ai] = v[ai];
                  });
                  v = o;
                }
                RC++;
                v.___id = 'T' + String(idpad + TC).slice(-6) + 'R' + String(idpad + RC).slice(-6);
                v.___s = true;
                records.push(v.___id);
                if (settings.template) {
                  v = T.mergeObj(settings.template, v);
                }
                TOb.push(v);
                ID[v.___id] = TOb.length - 1;
                if (settings.onInsert && (runEvent || TAFFY.isUndefined(runEvent))) {
                  settings.onInsert.call(v);
                }
                DBI.dm(new Date);
              });
              return root(records);
            },
            sort: function (o) {
              TOb = orderByCol(TOb, o.split(','));
              ID = {};
              each(TOb, function (r, i) {
                ID[r.___id] = i;
              });
              DBI.dm(new Date);
              return true;
            },
            update: function (id, changes, runEvent) {
              var nc = {}, or, nr, tc, hasChange;
              if (settings.forcePropertyCase) {
                eachin(changes, function (v, p) {
                  nc[settings.forcePropertyCase === 'lower' ? p.toLowerCase() : settings.forcePropertyCase === 'upper' ? p.toUpperCase() : p] = v;
                });
                changes = nc;
              }
              or = TOb[ID[id]];
              nr = T.mergeObj(or, changes);
              tc = {};
              hasChange = false;
              eachin(nr, function (v, i) {
                if (TAFFY.isUndefined(or[i]) || or[i] !== v) {
                  tc[i] = v;
                  hasChange = true;
                }
              });
              if (hasChange) {
                if (settings.onUpdate && (runEvent || TAFFY.isUndefined(runEvent))) {
                  settings.onUpdate.call(nr, TOb[ID[id]], tc);
                }
                TOb[ID[id]] = nr;
                DBI.dm(new Date);
              }
            },
            remove: function (id) {
              TOb[ID[id]].___s = false;
            },
            removeCommit: function (runEvent) {
              var x;
              for (x = TOb.length - 1; x > -1; x--) {
                if (!TOb[x].___s) {
                  if (settings.onRemove && (runEvent || TAFFY.isUndefined(runEvent))) {
                    settings.onRemove.call(TOb[x]);
                  }
                  ID[TOb[x].___id] = undefined;
                  TOb.splice(x, 1);
                }
              }
              ID = {};
              each(TOb, function (r, i) {
                ID[r.___id] = i;
              });
              DBI.dm(new Date);
            },
            query: function (context) {
              var returnq, cid, results, indexed, limitq, ni;
              if (settings.cacheSize) {
                cid = '';
                each(context.filterRaw, function (r) {
                  if (T.isFunction(r)) {
                    cid = 'nocache';
                    return TAFFY.EXIT;
                  }
                });
                if (cid === '') {
                  cid = makeCid(T.mergeObj(context, {
                    q: false,
                    run: false,
                    sort: false
                  }));
                }
              }
              if (!context.results || !context.run || context.run && DBI.dm() > context.run) {
                results = [];
                if (settings.cacheSize && Cache[cid]) {
                  Cache[cid].i = CacheCount++;
                  return Cache[cid].results;
                } else {
                  if (context.q.length === 0 && context.index.length === 0) {
                    each(TOb, function (r) {
                      results.push(r);
                    });
                    returnq = results;
                  } else {
                    indexed = runIndexes(context.index);
                    each(indexed, function (r) {
                      if (context.q.length === 0 || runFilters(r, context.q)) {
                        results.push(r);
                      }
                    });
                    returnq = results;
                  }
                }
              } else {
                returnq = context.results;
              }
              if (context.order.length > 0 && (!context.run || !context.sort)) {
                returnq = orderByCol(returnq, context.order);
              }
              if (returnq.length && (context.limit && context.limit < returnq.length || context.start)) {
                limitq = [];
                each(returnq, function (r, i) {
                  if (!context.start || context.start && i + 1 >= context.start) {
                    if (context.limit) {
                      ni = context.start ? i + 1 - context.start : i;
                      if (ni < context.limit) {
                        limitq.push(r);
                      } else if (ni > context.limit) {
                        return TAFFY.EXIT;
                      }
                    } else {
                      limitq.push(r);
                    }
                  }
                });
                returnq = limitq;
              }
              if (settings.cacheSize && cid !== 'nocache') {
                CacheClear++;
                setTimeout(function () {
                  var bCounter, nc;
                  if (CacheClear >= settings.cacheSize * 2) {
                    CacheClear = 0;
                    bCounter = CacheCount - settings.cacheSize;
                    nc = {};
                    eachin(function (r, k) {
                      if (r.i >= bCounter) {
                        nc[k] = r;
                      }
                    });
                    Cache = nc;
                  }
                }, 0);
                Cache[cid] = {
                  i: CacheCount++,
                  results: returnq
                };
              }
              return returnq;
            }
          };
          root = function () {
            var iAPI, context;
            iAPI = TAFFY.mergeObj(TAFFY.mergeObj(API, { insert: undefined }), {
              getDBI: function () {
                return DBI;
              },
              getroot: function (c) {
                return root.call(c);
              },
              context: function (n) {
                if (n) {
                  context = TAFFY.mergeObj(context, n.hasOwnProperty('results') ? TAFFY.mergeObj(n, {
                    run: new Date,
                    sort: new Date
                  }) : n);
                }
                return context;
              },
              extend: undefined
            });
            context = this && this.q ? this : {
              limit: false,
              start: false,
              q: [],
              filterRaw: [],
              index: [],
              order: [],
              results: false,
              run: null,
              sort: null,
              settings: settings
            };
            each(arguments, function (f) {
              if (isIndexable(f)) {
                context.index.push(f);
              } else {
                context.q.push(returnFilter(f));
              }
              context.filterRaw.push(f);
            });
            return iAPI;
          };
          TC++;
          if (d) {
            DBI.insert(d);
          }
          root.insert = DBI.insert;
          root.merge = function (i, key, runEvent) {
            var search = {}, finalSearch = [], obj = {};
            ;
            runEvent = runEvent || false;
            key = key || 'id';
            each(i, function (o) {
              var existingObject;
              search[key] = o[key];
              finalSearch.push(o[key]);
              existingObject = root(search).first();
              if (existingObject) {
                DBI.update(existingObject.___id, o, runEvent);
              } else {
                DBI.insert(o, runEvent);
              }
            });
            obj[key] = finalSearch;
            return root(obj);
          };
          root.TAFFY = true;
          root.sort = DBI.sort;
          root.settings = function (n) {
            if (n) {
              settings = TAFFY.mergeObj(settings, n);
              if (n.template) {
                root().update(n.template);
              }
            }
            return settings;
          };
          root.store = function (n) {
            var r = false, i;
            if (localStorage) {
              if (n) {
                i = localStorage.getItem('taffy_' + n);
                if (i && i.length > 0) {
                  root.insert(i);
                  r = true;
                }
                if (TOb.length > 0) {
                  setTimeout(function () {
                    localStorage.setItem('taffy_' + settings.storageName, JSON.stringify(TOb));
                  });
                }
              }
              root.settings({ storageName: n });
            }
            return root;
          };
          return root;
        };
        TAFFY = T;
        T.each = each;
        T.eachin = eachin;
        T.extend = API.extend;
        TAFFY.EXIT = 'TAFFYEXIT';
        TAFFY.mergeObj = function (ob1, ob2) {
          var c = {};
          eachin(ob1, function (v, n) {
            c[n] = ob1[n];
          });
          eachin(ob2, function (v, n) {
            c[n] = ob2[n];
          });
          return c;
        };
        TAFFY.has = function (var1, var2) {
          var re = false, n;
          if (var1.TAFFY) {
            re = var1(var2);
            if (re.length > 0) {
              return true;
            } else {
              return false;
            }
          } else {
            switch (T.typeOf(var1)) {
            case 'object':
              if (T.isObject(var2)) {
                eachin(var2, function (v, n) {
                  if (re === true && !T.isUndefined(var1[n]) && var1.hasOwnProperty(n)) {
                    re = T.has(var1[n], var2[n]);
                  } else {
                    re = false;
                    return TAFFY.EXIT;
                  }
                });
              } else if (T.isArray(var2)) {
                each(var2, function (v, n) {
                  re = T.has(var1, var2[n]);
                  if (re) {
                    return TAFFY.EXIT;
                  }
                });
              } else if (T.isString(var2)) {
                if (!TAFFY.isUndefined(var1[var2])) {
                  return true;
                } else {
                  return false;
                }
              }
              return re;
            case 'array':
              if (T.isObject(var2)) {
                each(var1, function (v, i) {
                  re = T.has(var1[i], var2);
                  if (re === true) {
                    return TAFFY.EXIT;
                  }
                });
              } else if (T.isArray(var2)) {
                each(var2, function (v2, i2) {
                  each(var1, function (v1, i1) {
                    re = T.has(var1[i1], var2[i2]);
                    if (re === true) {
                      return TAFFY.EXIT;
                    }
                  });
                  if (re === true) {
                    return TAFFY.EXIT;
                  }
                });
              } else if (T.isString(var2) || T.isNumber(var2)) {
                re = false;
                for (n = 0; n < var1.length; n++) {
                  re = T.has(var1[n], var2);
                  if (re) {
                    return true;
                  }
                }
              }
              return re;
            case 'string':
              if (T.isString(var2) && var2 === var1) {
                return true;
              }
              break;
            default:
              if (T.typeOf(var1) === T.typeOf(var2) && var1 === var2) {
                return true;
              }
              break;
            }
          }
          return false;
        };
        TAFFY.hasAll = function (var1, var2) {
          var T = TAFFY, ar;
          if (T.isArray(var2)) {
            ar = true;
            each(var2, function (v) {
              ar = T.has(var1, v);
              if (ar === false) {
                return TAFFY.EXIT;
              }
            });
            return ar;
          } else {
            return T.has(var1, var2);
          }
        };
        TAFFY.typeOf = function (v) {
          var s = typeof v;
          if (s === 'object') {
            if (v) {
              if (typeof v.length === 'number' && !v.propertyIsEnumerable('length')) {
                s = 'array';
              }
            } else {
              s = 'null';
            }
          }
          return s;
        };
        TAFFY.getObjectKeys = function (ob) {
          var kA = [];
          eachin(ob, function (n, h) {
            kA.push(h);
          });
          kA.sort();
          return kA;
        };
        TAFFY.isSameArray = function (ar1, ar2) {
          return TAFFY.isArray(ar1) && TAFFY.isArray(ar2) && ar1.join(',') === ar2.join(',') ? true : false;
        };
        TAFFY.isSameObject = function (ob1, ob2) {
          var T = TAFFY, rv = true;
          if (T.isObject(ob1) && T.isObject(ob2)) {
            if (T.isSameArray(T.getObjectKeys(ob1), T.getObjectKeys(ob2))) {
              eachin(ob1, function (v, n) {
                if (!(T.isObject(ob1[n]) && T.isObject(ob2[n]) && T.isSameObject(ob1[n], ob2[n]) || T.isArray(ob1[n]) && T.isArray(ob2[n]) && T.isSameArray(ob1[n], ob2[n]) || ob1[n] === ob2[n])) {
                  rv = false;
                  return TAFFY.EXIT;
                }
              });
            } else {
              rv = false;
            }
          } else {
            rv = false;
          }
          return rv;
        };
        typeList = [
          'String',
          'Number',
          'Object',
          'Array',
          'Boolean',
          'Null',
          'Function',
          'Undefined'
        ];
        makeTest = function (thisKey) {
          return function (data) {
            return TAFFY.typeOf(data) === thisKey.toLowerCase() ? true : false;
          };
        };
        for (idx = 0; idx < typeList.length; idx++) {
          typeKey = typeList[idx];
          TAFFY['is' + typeKey] = makeTest(typeKey);
        }
      }
    }());
    if (typeof exports === 'object') {
      exports.taffy = TAFFY;
    }
  });
  require.define('/elements.js', function (module, exports, __dirname, __filename) {
    (function () {
      var AbsoluteLayout, Background, Bacon, Base, ClickResponse, Confirm, FirstResponse, GridLayout, Group, HtmlRange, KeyPressResponse, KineticContext, KineticStimFactory, Layout, MousePressResponse, MultipleChoice, Paragraph, Prompt, Psy, Q, Response, Sequence, Sound, SpaceKeyResponse, Stimulus, disableBrowserBack, doTimer, getTimestamp, input, lay, li, marked, renderable, ul, utils, _, _ref, _ref1, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Psy = require('/psycloud.js', module);
      Bacon = require('/lib/Bacon.js', module).Bacon;
      _ = require('/../node_modules/lodash/dist/lodash.js', module);
      Q = require('/../node_modules/q/q.js', module);
      marked = require('/../node_modules/marked/lib/marked.js', module);
      utils = require('/utils.js', module);
      lay = require('/layout.js', module);
      Base = require('/stimresp.js', module);
      Stimulus = Base.Stimulus;
      Response = Base.Response;
      Background = require('/components/canvas/Background.js', module).Background;
      _ref = require('/../node_modules/teacup/lib/teacup.js', module), renderable = _ref.renderable, ul = _ref.ul, li = _ref.li, input = _ref.input;
      Layout = lay.Layout;
      AbsoluteLayout = lay.AbsoluteLayout;
      GridLayout = lay.GridLayout;
      doTimer = utils.doTimer;
      disableBrowserBack = utils.disableBrowserBack;
      getTimestamp = utils.getTimeStamp;
      exports.Prompt = Prompt = function (_super) {
        __extends(Prompt, _super);
        function Prompt(spec) {
          if (spec == null) {
            spec = {};
          }
          Prompt.__super__.constructor.call(this, spec, {
            title: '',
            delay: 0,
            defaultValue: ''
          });
        }
        Prompt.prototype.activate = function (context) {
          var deferred, promise, _this = this;
          deferred = Q.defer();
          promise = Q.delay(this.spec.delay);
          promise.then(function (f) {
            return vex.dialog.prompt({
              message: _this.spec.title,
              placeholder: _this.spec.defaultValue,
              className: 'vex-theme-wireframe',
              callback: function (value) {
                return deferred.resolve(value);
              }
            });
          });
          return deferred.promise;
        };
        return Prompt;
      }(Response);
      exports.Confirm = Confirm = function (_super) {
        __extends(Confirm, _super);
        function Confirm(spec) {
          if (spec == null) {
            spec = {};
          }
          Confirm.__super__.constructor.call(this, spec, {
            message: '',
            delay: 0,
            defaultValue: ''
          });
        }
        Confirm.prototype.activate = function (context) {
          var deferred, promise, _this = this;
          deferred = Q.defer();
          promise = Q.delay(this.spec.delay);
          promise.then(function (f) {
            return vex.dialog.confirm({
              message: _this.spec.message,
              className: 'vex-theme-wireframe',
              callback: function (value) {
                return deferred.resolve(value);
              }
            });
          });
          return deferred.promise;
        };
        return Confirm;
      }(Response);
      exports.MousePressResponse = MousePressResponse = function (_super) {
        __extends(MousePressResponse, _super);
        function MousePressResponse() {
          MousePressResponse.__super__.constructor.call(this, {}, {});
        }
        MousePressResponse.prototype.activate = function (context) {
          var deferred, mouse, _this = this;
          deferred = Q.defer();
          mouse = context.mousepressStream();
          mouse.stream.take(1).onValue(function (event) {
            mouse.stop();
            return deferred.resolve(event);
          });
          return deferred.promise;
        };
        return MousePressResponse;
      }(Response);
      exports.KeyPressResponse = KeyPressResponse = function (_super) {
        __extends(KeyPressResponse, _super);
        function KeyPressResponse(spec) {
          if (spec == null) {
            spec = {};
          }
          KeyPressResponse.__super__.constructor.call(this, spec, {
            keys: [
              'n',
              'm'
            ],
            correct: ['n'],
            timeout: 3e3
          });
          this.name = 'KeyPress';
        }
        KeyPressResponse.prototype.activate = function (context) {
          var deferred, keyStream, myname, _this = this;
          this.startTime = getTimestamp();
          myname = this.name;
          deferred = Q.defer();
          keyStream = context.keypressStream();
          keyStream.filter(function (event) {
            var char;
            char = String.fromCharCode(event.keyCode);
            return _.contains(_this.spec.keys, char);
          }).take(1).onValue(function (filtered) {
            var Acc, resp, timestamp;
            Acc = _.contains(_this.spec.correct, String.fromCharCode(filtered.keyCode));
            timestamp = getTimestamp();
            resp = {
              name: myname,
              id: _this.id,
              KeyTime: timestamp,
              RT: timestamp - _this.startTime,
              Accuracy: Acc,
              KeyChar: String.fromCharCode(filtered.keyCode)
            };
            context.pushData(resp);
            context.logEvent('KeyPress', getTimestamp());
            context.logEvent('$ACC', Acc);
            console.log('resolving keypress');
            return deferred.resolve(resp);
          });
          return deferred.promise;
        };
        return KeyPressResponse;
      }(Response);
      exports.SpaceKeyResponse = SpaceKeyResponse = function (_super) {
        __extends(SpaceKeyResponse, _super);
        function SpaceKeyResponse(spec) {
          if (spec == null) {
            spec = {};
          }
          SpaceKeyResponse.__super__.constructor.call(this, spec, {});
        }
        SpaceKeyResponse.prototype.activate = function (context) {
          var deferred, keyStream, _this = this;
          deferred = Q.defer();
          keyStream = context.keypressStream();
          keyStream.filter(function (event) {
            var char;
            char = String.fromCharCode(event.keyCode);
            return event.keyCode === 32;
          }).take(1).onValue(function (event) {
            context.logEvent('SpaceKey', getTimestamp());
            return deferred.resolve(event);
          });
          return deferred.promise;
        };
        return SpaceKeyResponse;
      }(Response);
      exports.FirstResponse = FirstResponse = function (_super) {
        __extends(FirstResponse, _super);
        function FirstResponse(responses) {
          this.responses = responses;
          FirstResponse.__super__.constructor.call(this, {}, {});
        }
        FirstResponse.prototype.activate = function (context) {
          var deferred, promises, _this = this;
          deferred = Q.defer();
          promises = _.map(this.responses, function (resp) {
            return resp.activate(context).then(function () {
              return deferred.resolve(resp);
            });
          });
          return deferred.promise;
        };
        return FirstResponse;
      }(Response);
      exports.ClickResponse = ClickResponse = function (_super) {
        __extends(ClickResponse, _super);
        function ClickResponse(refid) {
          this.refid = refid;
        }
        ClickResponse.prototype.activate = function (context) {
          var deferred, element, _this = this;
          element = context.stage.get('#' + this.refid);
          if (!element) {
            throw 'cannot find element with id' + this.refid;
          }
          deferred = Q.defer();
          element.on('click', function (ev) {
            context.logEvent('Click', getTimestamp());
            return deferred.resolve(ev);
          });
          return deferred.promise;
        };
        return ClickResponse;
      }(Response);
      exports.Sound = Sound = function () {
        function Sound(url) {
          this.url = url;
          this.sound = new buzz.sound(this.url);
        }
        Sound.prototype.render = function (context) {
          return this.sound.play();
        };
        return Sound;
      }();
      exports.Group = Group = function (_super) {
        __extends(Group, _super);
        function Group(stims, layout) {
          var stim, _i, _len, _ref1;
          this.stims = stims;
          Group.__super__.constructor.call(this, {}, {});
          if (layout) {
            this.layout = layout;
            _ref1 = this.stims;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              stim = _ref1[_i];
              stim.layout = layout;
            }
          }
        }
        Group.prototype.render = function (context, layer) {
          var stim, _i, _len, _ref1, _results;
          console.log('rendering group');
          _ref1 = this.stims;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            stim = _ref1[_i];
            _results.push(stim.render(context, layer));
          }
          return _results;
        };
        return Group;
      }(Stimulus);
      exports.Sequence = Sequence = function (_super) {
        __extends(Sequence, _super);
        function Sequence(stims, soa, clear, times) {
          var i;
          this.stims = stims;
          this.soa = soa;
          this.clear = clear != null ? clear : true;
          this.times = times != null ? times : 1;
          Sequence.__super__.constructor.call(this, {}, {});
          if (this.soa.length !== this.stims.length) {
            this.soa = utils.repLen(this.soa, this.stims.length);
          }
          this.onsets = function () {
            var _i, _ref1, _results;
            _results = [];
            for (i = _i = 0, _ref1 = this.soa.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
              _results.push(_.reduce(this.soa.slice(0, +i + 1 || 9e9), function (x, acc) {
                return x + acc;
              }));
            }
            return _results;
          }.call(this);
        }
        Sequence.prototype.genseq = function (context, layer) {
          var deferred, _i, _ref1, _results, _this = this;
          deferred = Q.defer();
          _.forEach(function () {
            _results = [];
            for (var _i = 0, _ref1 = this.stims.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; 0 <= _ref1 ? _i++ : _i--) {
              _results.push(_i);
            }
            return _results;
          }.apply(this), function (i) {
            var ev, stim;
            ev = new Timeout({ duration: _this.onsets[i] });
            stim = _this.stims[i];
            return ev.activate(context).then(function () {
              if (!_this.stopped) {
                if (_this.clear) {
                  context.clearContent();
                }
                stim.render(context, layer);
                context.draw();
              }
              if (i === _this.stims.length - 1) {
                return deferred.resolve(1);
              }
            });
          });
          return deferred.promise;
        };
        Sequence.prototype.render = function (context, layer) {
          var i, result, _i, _ref1, _this = this;
          result = Q.resolve(0);
          for (i = _i = 0, _ref1 = this.times; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
            result = result.then(function () {
              return _this.genseq(context, layer);
            });
          }
          return result.then(function () {
            return context.clearContent();
          });
        };
        return Sequence;
      }(Stimulus);
      exports.Paragraph = Paragraph = function (_super) {
        __extends(Paragraph, _super);
        function Paragraph(spec) {
          if (spec == null) {
            spec = {};
          }
          Paragraph.__super__.constructor.call(this, spec, {
            content: '',
            x: 50,
            y: 50,
            width: 600,
            fill: 'black',
            fontSize: 18,
            fontFamily: 'Arial',
            lineHeight: 1,
            textAlign: 'center',
            position: null
          });
        }
        return Paragraph;
      }(Stimulus);
      exports.HtmlRange = HtmlRange = function (_super) {
        __extends(HtmlRange, _super);
        function HtmlRange(spec) {
          if (spec == null) {
            spec = {};
          }
          HtmlRange.__super__.constructor.call(this, spec, {
            min: 0,
            max: 100,
            value: 0,
            step: 1,
            height: 100,
            width: 300
          });
          this.html = $('<div></div>');
          this.input = $("<input type='range'>");
          this.input.attr({
            min: this.spec.min,
            max: this.spec.max,
            value: this.spec.value,
            step: this.spec.step
          });
          this.input.css({ width: this.spec.width });
          this.html.append(this.input);
        }
        HtmlRange.prototype.render = function (context, layer) {
          return context.appendHtml(this.html);
        };
        return HtmlRange;
      }(Stimulus);
      exports.MultipleChoice = MultipleChoice = function (_super) {
        __extends(MultipleChoice, _super);
        function MultipleChoice(spec) {
          if (spec == null) {
            spec = {};
          }
          MultipleChoice.__super__.constructor.call(this, spec, {
            question: 'What is your name?',
            options: [
              'Bill',
              'John',
              'Fred'
            ],
            x: 10,
            y: 10,
            fill: 'black',
            fontSize: 24,
            fontFamily: 'Arial',
            textAlign: 'center',
            position: null
          });
        }
        MultipleChoice.prototype.render = function (context, layer) {
          var choice, i, questionText, _i, _ref1, _results;
          questionText = new Kinetic.Text({
            x: this.spec.x,
            y: this.spec.y,
            text: this.spec.question,
            fontSize: this.spec.fontSize,
            fontFamily: this.spec.fontFamily,
            fill: this.spec.fill
          });
          layer.add(questionText);
          _results = [];
          for (i = _i = 0, _ref1 = this.spec.options.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
            choice = new Kinetic.Text({
              x: this.spec.x + 5,
              y: questionText.getHeight() * (i + 1) + 30,
              text: i + 1 + ') ' + this.spec.options[i],
              fontSize: this.spec.fontSize,
              fontFamily: this.spec.fontFamily,
              fill: this.spec.fill,
              padding: 20,
              align: 'left'
            });
            _results.push(layer.add(choice));
          }
          return _results;
        };
        return MultipleChoice;
      }(Stimulus);
      exports.KineticContext = KineticContext = function (_super) {
        __extends(KineticContext, _super);
        function KineticContext(stage) {
          this.stage = stage;
          KineticContext.__super__.constructor.call(this, new KineticStimFactory);
          this.contentLayer = new Kinetic.Layer({ clearBeforeDraw: true });
          this.backgroundLayer = new Kinetic.Layer({ clearBeforeDraw: true });
          this.background = new Background([], { fill: 'white' });
          this.stage.add(this.backgroundLayer);
          this.stage.add(this.contentLayer);
          this.insertHTMLDiv();
        }
        KineticContext.prototype.insertHTMLDiv = function () {
          KineticContext.__super__.insertHTMLDiv.apply(this, arguments);
          return $('.kineticjs-content').css('position', 'absolute');
        };
        KineticContext.prototype.setBackground = function (newBackground) {
          this.background = newBackground;
          this.backgroundLayer.removeChildren();
          return this.background.render(this, this.backgroundLayer);
        };
        KineticContext.prototype.drawBackground = function () {
          return this.backgroundLayer.draw();
        };
        KineticContext.prototype.clearBackground = function () {
          return this.backgroundLayer.removeChildren();
        };
        KineticContext.prototype.clearContent = function (draw) {
          if (draw == null) {
            draw = false;
          }
          this.clearHtml();
          this.backgroundLayer.draw();
          this.contentLayer.removeChildren();
          if (draw) {
            return this.draw();
          }
        };
        KineticContext.prototype.draw = function () {
          $('#container').focus();
          return this.contentLayer.draw();
        };
        KineticContext.prototype.width = function () {
          return this.stage.getWidth();
        };
        KineticContext.prototype.height = function () {
          return this.stage.getHeight();
        };
        KineticContext.prototype.offsetX = function () {
          return this.stage.getOffsetX();
        };
        KineticContext.prototype.offsetY = function () {
          return this.stage.getOffsetY();
        };
        KineticContext.prototype.keydownStream = function () {
          return $('body').asEventStream('keydown');
        };
        KineticContext.prototype.keypressStream = function () {
          return $('body').asEventStream('keypress');
        };
        KineticContext.prototype.mousepressStream = function () {
          var MouseBus;
          MouseBus = function () {
            function MouseBus() {
              var _this = this;
              this.stream = new Bacon.Bus;
              this.handler = function (x) {
                return _this.stream.push(x);
              };
              this.stage.on('mousedown', this.handler);
            }
            MouseBus.prototype.stop = function () {
              this.stage.off('mousedown', this.handler);
              return this.stream.end();
            };
            return MouseBus;
          }();
          return new MouseBus;
        };
        return KineticContext;
      }(Psy.ExperimentContext);
      exports.KineticStimFactory = KineticStimFactory = function (_super) {
        __extends(KineticStimFactory, _super);
        function KineticStimFactory() {
          _ref1 = KineticStimFactory.__super__.constructor.apply(this, arguments);
          return _ref1;
        }
        KineticStimFactory.prototype.makeLayout = function (name, params, context) {
          switch (name) {
          case 'Grid':
            return new GridLayout(params[0], params[1], {
              x: 0,
              y: 0,
              width: context.width(),
              height: context.height()
            });
          }
        };
        KineticStimFactory.prototype.makeInstructions = function (spec) {
          return new Instructions(spec);
        };
        KineticStimFactory.prototype.makeStimulus = function (name, params, context) {
          var callee, i, layoutName, layoutParams, names, props, stims;
          callee = arguments.callee;
          switch (name) {
          case 'FixationCross':
            return new FixationCross(params);
          case 'Clear':
            return new Clear(params);
          case 'Group':
            names = _.map(params.stims, function (stim) {
              return _.keys(stim)[0];
            });
            props = _.map(params.stims, function (stim) {
              return _.values(stim)[0];
            });
            stims = function () {
              var _i, _ref2, _results;
              _results = [];
              for (i = _i = 0, _ref2 = names.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
                _results.push(callee(names[i], props[i]));
              }
              return _results;
            }();
            layoutName = _.keys(params.layout)[0];
            layoutParams = _.values(params.layout)[0];
            return new Group(stims, this.makeLayout(layoutName, layoutParams, context));
          case 'Instructions':
            return new Instructions(params);
          case 'Rectangle':
            return new Rectangle(params);
          case 'Text':
            return new Text(params);
          case 'HtmlIcon':
            return new HtmlIcon(params);
          default:
            throw 'No Stimulus type of name ' + name;
          }
        };
        KineticStimFactory.prototype.makeResponse = function (name, params, context) {
          console.log('making response', name);
          switch (name) {
          case 'KeyPress':
            return new KeyPressResponse(params);
          case 'SpaceKey':
            return new SpaceKeyResponse(params);
          case 'Timeout':
            return new Timeout(params);
          default:
            throw new Error('No Response type of name ' + name);
          }
        };
        KineticStimFactory.prototype.makeEvent = function (stim, response) {
          return new Psy.Event(stim, response);
        };
        return KineticStimFactory;
      }(Psy.StimFactory);
    }.call(this));
  });
  require.define('/../node_modules/teacup/lib/teacup.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Teacup, doctypes, elements, merge_elements, tagName, _fn, _fn1, _fn2, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, __slice = [].slice, __indexOf = [].indexOf || function (item) {
          for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
              return i;
          }
          return -1;
        };
      doctypes = {
        'default': '<!DOCTYPE html>',
        '5': '<!DOCTYPE html>',
        'xml': '<?xml version="1.0" encoding="utf-8" ?>',
        'transitional': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">',
        'strict': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">',
        'frameset': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">',
        '1.1': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">',
        'basic': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">',
        'mobile': '<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN" "http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">',
        'ce': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "ce-html-1.0-transitional.dtd">'
      };
      elements = {
        regular: 'a abbr address article aside audio b bdi bdo blockquote body button canvas caption cite code colgroup datalist dd del details dfn div dl dt em fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hgroup html i iframe ins kbd label legend li map mark menu meter nav noscript object ol optgroup option output p pre progress q rp rt ruby s samp section select small span strong sub summary sup table tbody td textarea tfoot th thead time title tr u ul video',
        raw: 'script style',
        'void': 'area base br col command embed hr img input keygen link meta param source track wbr',
        obsolete: 'applet acronym bgsound dir frameset noframes isindex listing nextid noembed plaintext rb strike xmp big blink center font marquee multicol nobr spacer tt',
        obsolete_void: 'basefont frame'
      };
      merge_elements = function () {
        var a, args, element, result, _i, _j, _len, _len1, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        result = [];
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          a = args[_i];
          _ref = elements[a].split(' ');
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            element = _ref[_j];
            if (__indexOf.call(result, element) < 0) {
              result.push(element);
            }
          }
        }
        return result;
      };
      Teacup = function () {
        function Teacup() {
          this.htmlOut = null;
        }
        Teacup.prototype.resetBuffer = function (html) {
          var previous;
          if (html == null) {
            html = null;
          }
          previous = this.htmlOut;
          this.htmlOut = html;
          return previous;
        };
        Teacup.prototype.render = function () {
          var args, previous, result, template;
          template = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          previous = this.resetBuffer('');
          try {
            template.apply(null, args);
          } finally {
            result = this.resetBuffer(previous);
          }
          return result;
        };
        Teacup.prototype.cede = function () {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return this.render.apply(this, args);
        };
        Teacup.prototype.renderable = function (template) {
          var teacup;
          teacup = this;
          return function () {
            var args, result;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            if (teacup.htmlOut === null) {
              teacup.htmlOut = '';
              try {
                template.apply(this, args);
              } finally {
                result = teacup.resetBuffer();
              }
              return result;
            } else {
              return template.apply(this, args);
            }
          };
        };
        Teacup.prototype.renderAttr = function (name, value) {
          var k, v;
          if (value == null) {
            return ' ' + name;
          }
          if (value === false) {
            return '';
          }
          if (name === 'data' && typeof value === 'object') {
            return function () {
              var _results;
              _results = [];
              for (k in value) {
                v = value[k];
                _results.push(this.renderAttr('data-' + k, v));
              }
              return _results;
            }.call(this).join('');
          }
          if (value === true) {
            value = name;
          }
          return ' ' + name + '=' + this.quote(this.escape(value.toString()));
        };
        Teacup.prototype.attrOrder = [
          'id',
          'class'
        ];
        Teacup.prototype.renderAttrs = function (obj) {
          var name, result, value, _i, _len, _ref;
          result = '';
          _ref = this.attrOrder;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            name = _ref[_i];
            if (!(name in obj)) {
              continue;
            }
            result += this.renderAttr(name, obj[name]);
            delete obj[name];
          }
          for (name in obj) {
            value = obj[name];
            result += this.renderAttr(name, value);
          }
          return result;
        };
        Teacup.prototype.renderContents = function (contents) {
          if (contents == null) {
          } else if (typeof contents === 'function') {
            return contents.call(this);
          } else {
            return this.text(contents);
          }
        };
        Teacup.prototype.isSelector = function (string) {
          var _ref;
          return string.length > 1 && ((_ref = string[0]) === '#' || _ref === '.');
        };
        Teacup.prototype.parseSelector = function (selector) {
          var classes, id, klass, token, _i, _len, _ref, _ref1;
          id = null;
          classes = [];
          _ref = selector.split('.');
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            token = _ref[_i];
            if (id) {
              classes.push(token);
            } else {
              _ref1 = token.split('#'), klass = _ref1[0], id = _ref1[1];
              if (klass !== '') {
                classes.push(token);
              }
            }
          }
          return {
            id: id,
            classes: classes
          };
        };
        Teacup.prototype.normalizeArgs = function (args) {
          var arg, attrs, classes, contents, id, index, selector, _i, _len;
          attrs = {};
          selector = null;
          contents = null;
          for (index = _i = 0, _len = args.length; _i < _len; index = ++_i) {
            arg = args[index];
            if (arg != null) {
              switch (typeof arg) {
              case 'string':
                if (index === 0 && this.isSelector(arg)) {
                  selector = this.parseSelector(arg);
                } else {
                  contents = arg;
                }
                break;
              case 'function':
              case 'number':
              case 'boolean':
                contents = arg;
                break;
              case 'object':
                if (arg.constructor === Object) {
                  attrs = arg;
                } else {
                  contents = arg;
                }
                break;
              default:
                contents = arg;
              }
            }
          }
          if (selector != null) {
            id = selector.id, classes = selector.classes;
            if (id != null) {
              attrs.id = id;
            }
            if (classes != null ? classes.length : void 0) {
              attrs['class'] = classes.join(' ');
            }
          }
          return {
            attrs: attrs,
            contents: contents
          };
        };
        Teacup.prototype.tag = function () {
          var args, attrs, contents, tagName, _ref;
          tagName = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          _ref = this.normalizeArgs(args), attrs = _ref.attrs, contents = _ref.contents;
          this.raw('<' + tagName + this.renderAttrs(attrs) + '>');
          this.renderContents(contents);
          return this.raw('</' + tagName + '>');
        };
        Teacup.prototype.rawTag = function () {
          var args, attrs, contents, tagName, _ref;
          tagName = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          _ref = this.normalizeArgs(args), attrs = _ref.attrs, contents = _ref.contents;
          this.raw('<' + tagName + this.renderAttrs(attrs) + '>');
          this.raw(contents);
          return this.raw('</' + tagName + '>');
        };
        Teacup.prototype.selfClosingTag = function () {
          var args, attrs, contents, tag, _ref;
          tag = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          _ref = this.normalizeArgs(args), attrs = _ref.attrs, contents = _ref.contents;
          if (contents) {
            throw new Error('Teacup: <' + tag + '/> must not have content.  Attempted to nest ' + contents);
          }
          return this.raw('<' + tag + this.renderAttrs(attrs) + ' />');
        };
        Teacup.prototype.coffeescript = function (fn) {
          return this.raw('<script type="text/javascript">(function() {\n  var __slice = [].slice,\n      __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n      __hasProp = {}.hasOwnProperty,\n      __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n  (' + fn.toString() + ')();\n})();</script>');
        };
        Teacup.prototype.comment = function (text) {
          return this.raw('<!--' + this.escape(text) + '-->');
        };
        Teacup.prototype.doctype = function (type) {
          if (type == null) {
            type = 5;
          }
          return this.raw(doctypes[type]);
        };
        Teacup.prototype.ie = function (condition, contents) {
          this.raw('<!--[if ' + this.escape(condition) + ']>');
          this.renderContents(contents);
          return this.raw('<![endif]-->');
        };
        Teacup.prototype.text = function (s) {
          if (this.htmlOut == null) {
            throw new Error("Teacup: can't call a tag function outside a rendering context");
          }
          return this.htmlOut += s != null && this.escape(s.toString()) || '';
        };
        Teacup.prototype.raw = function (s) {
          if (s == null) {
            return;
          }
          return this.htmlOut += s;
        };
        Teacup.prototype.escape = function (text) {
          return text.toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        };
        Teacup.prototype.quote = function (value) {
          return '"' + value + '"';
        };
        Teacup.prototype.tags = function () {
          var bound, boundMethodNames, method, _fn, _i, _len, _this = this;
          bound = {};
          boundMethodNames = [].concat('cede coffeescript comment doctype escape ie raw render renderable script tag text'.split(' '), merge_elements('regular', 'obsolete', 'raw', 'void', 'obsolete_void'));
          _fn = function (method) {
            return bound[method] = function () {
              var args;
              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              return _this[method].apply(_this, args);
            };
          };
          for (_i = 0, _len = boundMethodNames.length; _i < _len; _i++) {
            method = boundMethodNames[_i];
            _fn(method);
          }
          return bound;
        };
        return Teacup;
      }();
      _ref = merge_elements('regular', 'obsolete');
      _fn = function (tagName) {
        return Teacup.prototype[tagName] = function () {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return this.tag.apply(this, [tagName].concat(__slice.call(args)));
        };
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tagName = _ref[_i];
        _fn(tagName);
      }
      _ref1 = merge_elements('raw');
      _fn1 = function (tagName) {
        return Teacup.prototype[tagName] = function () {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return this.rawTag.apply(this, [tagName].concat(__slice.call(args)));
        };
      };
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        tagName = _ref1[_j];
        _fn1(tagName);
      }
      _ref2 = merge_elements('void', 'obsolete_void');
      _fn2 = function (tagName) {
        return Teacup.prototype[tagName] = function () {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return this.selfClosingTag.apply(this, [tagName].concat(__slice.call(args)));
        };
      };
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        tagName = _ref2[_k];
        _fn2(tagName);
      }
      if (typeof module !== 'undefined' && module !== null ? module.exports : void 0) {
        module.exports = new Teacup().tags();
        module.exports.Teacup = Teacup;
      } else if (typeof define === 'function' && define.amd) {
        define('teacup', [], function () {
          return new Teacup().tags();
        });
      } else {
        window.teacup = new Teacup().tags();
        window.teacup.Teacup = Teacup;
      }
    }.call(this));
  });
  require.define('/lib/Bacon.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Bacon, Bus, Dispatcher, End, Error, Event, EventStream, Initial, Next, None, Observable, Property, PropertyDispatcher, Some, addPropertyInitValueToStream, assert, assertArray, assertEvent, assertFunction, assertString, cloneArray, cloneObject, end, former, indexOf, initial, isEvent, isFieldKey, isFunction, latter, makeFunction, methodCall, next, nop, partiallyApplied, remove, sendWrapped, toCombinator, toEvent, toFieldExtractor, toFieldKey, toOption, toSimpleExtractor, _, _ref, __slice = [].slice, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        }, __bind = function (fn, me) {
          return function () {
            return fn.apply(me, arguments);
          };
        };
      (exports || this).Bacon = Bacon = {};
      Bacon.asEventStream = function (eventName, selector, eventTransformer) {
        var element;
        if (eventTransformer == null) {
          eventTransformer = _.id;
        }
        if (isFunction(selector)) {
          eventTransformer = selector;
          selector = null;
        }
        element = this;
        return new EventStream(function (sink) {
          var handler, unbind;
          handler = function () {
            var args, reply;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            reply = sink(next(eventTransformer.apply(null, args)));
            if (reply === Bacon.noMore) {
              return unbind();
            }
          };
          unbind = function () {
            return element.off(eventName, selector, handler);
          };
          element.on(eventName, selector, handler);
          return unbind;
        });
      };
      if (typeof window !== 'undefined' && window !== null) {
        if ((_ref = window.jQuery || window.Zepto) != null) {
          _ref.fn.asEventStream = Bacon.asEventStream;
        }
      }
      Bacon.fromPromise = function (promise) {
        return new EventStream(function (sink) {
          var onError, onSuccess;
          onSuccess = function (value) {
            sink(next(value));
            return sink(end());
          };
          onError = function (e) {
            sink(new Error(e));
            return sink(end());
          };
          promise.then(onSuccess, onError);
          return nop;
        });
      };
      Bacon.noMore = ['<no-more>'];
      Bacon.more = ['<more>'];
      Bacon.later = function (delay, value) {
        return Bacon.sequentially(delay, [value]);
      };
      Bacon.sequentially = function (delay, values) {
        var index, poll;
        index = -1;
        poll = function () {
          var valueEvent;
          index++;
          valueEvent = toEvent(values[index]);
          if (index < values.length - 1) {
            return valueEvent;
          } else {
            return [
              valueEvent,
              end()
            ];
          }
        };
        return Bacon.fromPoll(delay, poll);
      };
      Bacon.repeatedly = function (delay, values) {
        var index, poll;
        index = -1;
        poll = function () {
          index++;
          return toEvent(values[index % values.length]);
        };
        return Bacon.fromPoll(delay, poll);
      };
      Bacon.fromCallback = function () {
        var args, f;
        f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        f = makeFunction(f, args);
        return new EventStream(function (sink) {
          var handler;
          handler = function (value) {
            sink(next(value));
            return sink(end());
          };
          f(handler);
          return nop;
        });
      };
      Bacon.fromPoll = function (delay, poll) {
        return new EventStream(function (sink) {
          var handler, id, unbind;
          id = void 0;
          handler = function () {
            var event, events, reply, _i, _len, _results;
            events = _.toArray(poll());
            _results = [];
            for (_i = 0, _len = events.length; _i < _len; _i++) {
              event = events[_i];
              reply = sink(event);
              if (reply === Bacon.noMore || event.isEnd()) {
                _results.push(unbind());
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          };
          unbind = function () {
            return clearInterval(id);
          };
          id = setInterval(handler, delay);
          return unbind;
        });
      };
      Bacon.fromEventTarget = function (target, eventName, eventTransformer) {
        if (eventTransformer == null) {
          eventTransformer = _.id;
        }
        return new EventStream(function (sink) {
          var handler, unbind;
          handler = function () {
            var args, reply;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            reply = sink(next(eventTransformer.apply(null, args)));
            if (reply === Bacon.noMore) {
              return unbind();
            }
          };
          if (target.addEventListener) {
            unbind = function () {
              return target.removeEventListener(eventName, handler, false);
            };
            target.addEventListener(eventName, handler, false);
          } else {
            unbind = function () {
              return target.removeListener(eventName, handler);
            };
            target.addListener(eventName, handler);
          }
          return unbind;
        });
      };
      Bacon.interval = function (delay, value) {
        var poll;
        if (value == null) {
          value = {};
        }
        poll = function () {
          return next(value);
        };
        return Bacon.fromPoll(delay, poll);
      };
      Bacon.constant = function (value) {
        return new Property(sendWrapped([value], initial));
      };
      Bacon.never = function () {
        return Bacon.fromArray([]);
      };
      Bacon.once = function (value) {
        return Bacon.fromArray([value]);
      };
      Bacon.fromArray = function (values) {
        return new EventStream(sendWrapped(values, next));
      };
      sendWrapped = function (values, wrapper) {
        return function (sink) {
          var value, _i, _len;
          for (_i = 0, _len = values.length; _i < _len; _i++) {
            value = values[_i];
            sink(wrapper(value));
          }
          sink(end());
          return nop;
        };
      };
      Bacon.combineAll = function (streams, f) {
        var next, stream, _i, _len, _ref1;
        assertArray(streams);
        stream = _.head(streams);
        _ref1 = _.tail(streams);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          next = _ref1[_i];
          stream = f(stream, next);
        }
        return stream;
      };
      Bacon.mergeAll = function (streams) {
        return Bacon.combineAll(streams, function (s1, s2) {
          return s1.merge(s2);
        });
      };
      Bacon.combineAsArray = function () {
        var more, next, stream, streams, _i, _len, _ref1;
        streams = arguments[0], more = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (!(streams instanceof Array)) {
          streams = [streams].concat(more);
        }
        if (streams.length) {
          stream = _.head(streams).toProperty().map(function (x) {
            return [x];
          });
          _ref1 = _.tail(streams);
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            next = _ref1[_i];
            stream = stream.combine(next, function (xs, x) {
              return xs.concat([x]);
            });
          }
          return stream;
        } else {
          return Bacon.constant([]);
        }
      };
      Bacon.combineWith = function (streams, f) {
        return Bacon.combineAll(streams, function (s1, s2) {
          return s1.toProperty().combine(s2, f);
        });
      };
      Bacon.combineTemplate = function (template) {
        var applyStreamValue, combinator, compile, compileTemplate, constantValue, current, funcs, mkContext, setValue, streams;
        funcs = [];
        streams = [];
        current = function (ctxStack) {
          return ctxStack[ctxStack.length - 1];
        };
        setValue = function (ctxStack, key, value) {
          return current(ctxStack)[key] = value;
        };
        applyStreamValue = function (key, index) {
          return function (ctxStack, values) {
            return setValue(ctxStack, key, values[index]);
          };
        };
        constantValue = function (key, value) {
          return function (ctxStack, values) {
            return setValue(ctxStack, key, value);
          };
        };
        mkContext = function (template) {
          if (template instanceof Array) {
            return [];
          } else {
            return {};
          }
        };
        compile = function (key, value) {
          var popContext, pushContext;
          if (value instanceof Observable) {
            streams.push(value);
            return funcs.push(applyStreamValue(key, streams.length - 1));
          } else if (typeof value === 'object') {
            pushContext = function (key) {
              return function (ctxStack, values) {
                var newContext;
                newContext = mkContext(value);
                setValue(ctxStack, key, newContext);
                return ctxStack.push(newContext);
              };
            };
            popContext = function (ctxStack, values) {
              return ctxStack.pop();
            };
            funcs.push(pushContext(key));
            compileTemplate(value);
            return funcs.push(popContext);
          } else {
            return funcs.push(constantValue(key, value));
          }
        };
        compileTemplate = function (template) {
          return _.each(template, compile);
        };
        compileTemplate(template);
        combinator = function (values) {
          var ctxStack, f, rootContext, _i, _len;
          rootContext = mkContext(template);
          ctxStack = [rootContext];
          for (_i = 0, _len = funcs.length; _i < _len; _i++) {
            f = funcs[_i];
            f(ctxStack, values);
          }
          return rootContext;
        };
        return Bacon.combineAsArray(streams).map(combinator);
      };
      Event = function () {
        function Event() {
        }
        Event.prototype.isEvent = function () {
          return true;
        };
        Event.prototype.isEnd = function () {
          return false;
        };
        Event.prototype.isInitial = function () {
          return false;
        };
        Event.prototype.isNext = function () {
          return false;
        };
        Event.prototype.isError = function () {
          return false;
        };
        Event.prototype.hasValue = function () {
          return false;
        };
        Event.prototype.filter = function (f) {
          return true;
        };
        Event.prototype.getOriginalEvent = function () {
          if (this.sourceEvent != null) {
            return this.sourceEvent.getOriginalEvent();
          } else {
            return this;
          }
        };
        Event.prototype.onDone = function (listener) {
          return listener();
        };
        return Event;
      }();
      Next = function (_super) {
        __extends(Next, _super);
        function Next(value, sourceEvent) {
          this.value = isFunction(value) ? value : _.always(value);
        }
        Next.prototype.isNext = function () {
          return true;
        };
        Next.prototype.hasValue = function () {
          return true;
        };
        Next.prototype.fmap = function (f) {
          return this.apply(f(this.value()));
        };
        Next.prototype.apply = function (value) {
          return next(value, this.getOriginalEvent());
        };
        Next.prototype.filter = function (f) {
          return f(this.value());
        };
        Next.prototype.describe = function () {
          return this.value();
        };
        return Next;
      }(Event);
      Initial = function (_super) {
        __extends(Initial, _super);
        function Initial() {
          return Initial.__super__.constructor.apply(this, arguments);
        }
        Initial.prototype.isInitial = function () {
          return true;
        };
        Initial.prototype.isNext = function () {
          return false;
        };
        Initial.prototype.apply = function (value) {
          return initial(value, this.getOriginalEvent());
        };
        Initial.prototype.toNext = function () {
          return new Next(this.value, this.getOriginalEvent());
        };
        return Initial;
      }(Next);
      End = function (_super) {
        __extends(End, _super);
        function End() {
          return End.__super__.constructor.apply(this, arguments);
        }
        End.prototype.isEnd = function () {
          return true;
        };
        End.prototype.fmap = function () {
          return this;
        };
        End.prototype.apply = function () {
          return this;
        };
        End.prototype.describe = function () {
          return '<end>';
        };
        return End;
      }(Event);
      Error = function (_super) {
        __extends(Error, _super);
        function Error(error) {
          this.error = error;
        }
        Error.prototype.isError = function () {
          return true;
        };
        Error.prototype.fmap = function () {
          return this;
        };
        Error.prototype.apply = function () {
          return this;
        };
        Error.prototype.describe = function () {
          return '<error> ' + this.error;
        };
        return Error;
      }(Event);
      Observable = function () {
        function Observable() {
          this.flatMapLatest = __bind(this.flatMapLatest, this);
          this.scan = __bind(this.scan, this);
          this.takeUntil = __bind(this.takeUntil, this);
          this.assign = this.onValue;
        }
        Observable.prototype.onValue = function () {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          f = makeFunction(f, args);
          return this.subscribe(function (event) {
            if (event.hasValue()) {
              return f(event.value());
            }
          });
        };
        Observable.prototype.onValues = function (f) {
          return this.onValue(function (args) {
            return f.apply(null, args);
          });
        };
        Observable.prototype.onError = function () {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          f = makeFunction(f, args);
          return this.subscribe(function (event) {
            if (event.isError()) {
              return f(event.error);
            }
          });
        };
        Observable.prototype.onEnd = function () {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          f = makeFunction(f, args);
          return this.subscribe(function (event) {
            if (event.isEnd()) {
              return f();
            }
          });
        };
        Observable.prototype.errors = function () {
          return this.filter(function () {
            return false;
          });
        };
        Observable.prototype.filter = function () {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          f = makeFunction(f, args);
          return this.withHandler(function (event) {
            if (event.filter(f)) {
              return this.push(event);
            } else {
              return Bacon.more;
            }
          });
        };
        Observable.prototype.takeWhile = function () {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          f = makeFunction(f, args);
          return this.withHandler(function (event) {
            if (event.filter(f)) {
              return this.push(event);
            } else {
              this.push(end());
              return Bacon.noMore;
            }
          });
        };
        Observable.prototype.endOnError = function () {
          return this.withHandler(function (event) {
            if (event.isError()) {
              this.push(event);
              return this.push(end());
            } else {
              return this.push(event);
            }
          });
        };
        Observable.prototype.take = function (count) {
          assert('take: count must >= 1', count >= 1);
          return this.withHandler(function (event) {
            if (!event.hasValue()) {
              return this.push(event);
            } else if (count === 1) {
              this.push(event);
              this.push(end());
              return Bacon.noMore;
            } else {
              count--;
              return this.push(event);
            }
          });
        };
        Observable.prototype.map = function () {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          f = makeFunction(f, args);
          return this.withHandler(function (event) {
            return this.push(event.fmap(f));
          });
        };
        Observable.prototype.mapError = function () {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          f = makeFunction(f, args);
          return this.withHandler(function (event) {
            if (event.isError()) {
              return this.push(next(f(event.error)));
            } else {
              return this.push(event);
            }
          });
        };
        Observable.prototype.doAction = function () {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          f = makeFunction(f, args);
          return this.withHandler(function (event) {
            if (event.hasValue()) {
              f(event.value());
            }
            return this.push(event);
          });
        };
        Observable.prototype.takeUntil = function (stopper) {
          var src;
          src = this;
          return this.withSubscribe(function (sink) {
            var srcSink, stopperSink, unsubBoth, unsubSrc, unsubStopper, unsubscribed;
            unsubscribed = false;
            unsubSrc = nop;
            unsubStopper = nop;
            unsubBoth = function () {
              unsubSrc();
              unsubStopper();
              return unsubscribed = true;
            };
            srcSink = function (event) {
              if (event.isEnd()) {
                unsubStopper();
                sink(event);
                return Bacon.noMore;
              } else {
                event.getOriginalEvent().onDone(function () {
                  var reply;
                  if (!unsubscribed) {
                    reply = sink(event);
                    if (reply === Bacon.noMore) {
                      return unsubBoth();
                    }
                  }
                });
                return Bacon.more;
              }
            };
            stopperSink = function (event) {
              if (event.isError()) {
                return Bacon.more;
              } else if (event.isEnd()) {
                return Bacon.noMore;
              } else {
                unsubSrc();
                sink(end());
                return Bacon.noMore;
              }
            };
            unsubSrc = src.subscribe(srcSink);
            if (!unsubscribed) {
              unsubStopper = stopper.subscribe(stopperSink);
            }
            return unsubBoth;
          });
        };
        Observable.prototype.skip = function (count) {
          assert('skip: count must >= 0', count >= 0);
          return this.withHandler(function (event) {
            if (!event.hasValue()) {
              return this.push(event);
            } else if (count > 0) {
              count--;
              return Bacon.more;
            } else {
              return this.push(event);
            }
          });
        };
        Observable.prototype.distinctUntilChanged = function () {
          return this.skipDuplicates();
        };
        Observable.prototype.skipDuplicates = function (isEqual) {
          if (isEqual == null) {
            isEqual = function (a, b) {
              return a === b;
            };
          }
          return this.withStateMachine(None, function (prev, event) {
            if (!event.hasValue()) {
              return [
                prev,
                [event]
              ];
            } else if (prev === None || !isEqual(prev.get(), event.value())) {
              return [
                new Some(event.value()),
                [event]
              ];
            } else {
              return [
                prev,
                []
              ];
            }
          });
        };
        Observable.prototype.withStateMachine = function (initState, f) {
          var state;
          state = initState;
          return this.withHandler(function (event) {
            var fromF, newState, output, outputs, reply, _i, _len;
            fromF = f(state, event);
            assertArray(fromF);
            newState = fromF[0], outputs = fromF[1];
            assertArray(outputs);
            state = newState;
            reply = Bacon.more;
            for (_i = 0, _len = outputs.length; _i < _len; _i++) {
              output = outputs[_i];
              reply = this.push(output);
              if (reply === Bacon.noMore) {
                return reply;
              }
            }
            return reply;
          });
        };
        Observable.prototype.scan = function (seed, f) {
          var acc, subscribe, _this = this;
          f = toCombinator(f);
          acc = toOption(seed);
          subscribe = function (sink) {
            var initSent, unsub;
            initSent = false;
            unsub = _this.subscribe(function (event) {
              if (event.hasValue()) {
                if (initSent && event.isInitial()) {
                  return Bacon.more;
                } else {
                  initSent = true;
                  acc = new Some(f(acc.getOrElse(void 0), event.value()));
                  return sink(event.apply(acc.get()));
                }
              } else {
                if (event.isEnd()) {
                  initSent = true;
                }
                return sink(event);
              }
            });
            if (!initSent) {
              acc.forEach(function (value) {
                var reply;
                reply = sink(initial(value));
                if (reply === Bacon.noMore) {
                  unsub();
                  return unsub = nop;
                }
              });
            }
            return unsub;
          };
          return new Property(new PropertyDispatcher(subscribe).subscribe);
        };
        Observable.prototype.diff = function (start, f) {
          f = toCombinator(f);
          return this.scan([start], function (prevTuple, next) {
            return [
              next,
              f(prevTuple[0], next)
            ];
          }).filter(function (tuple) {
            return tuple.length === 2;
          }).map(function (tuple) {
            return tuple[1];
          });
        };
        Observable.prototype.flatMap = function (f) {
          var root;
          root = this;
          return new EventStream(function (sink) {
            var checkEnd, children, rootEnd, spawner, unbind, unsubRoot;
            children = [];
            rootEnd = false;
            unsubRoot = function () {
            };
            unbind = function () {
              var unsubChild, _i, _len;
              unsubRoot();
              for (_i = 0, _len = children.length; _i < _len; _i++) {
                unsubChild = children[_i];
                unsubChild();
              }
              return children = [];
            };
            checkEnd = function () {
              if (rootEnd && children.length === 0) {
                return sink(end());
              }
            };
            spawner = function (event) {
              var child, childEnded, handler, removeChild, unsubChild;
              if (event.isEnd()) {
                rootEnd = true;
                return checkEnd();
              } else if (event.isError()) {
                return sink(event);
              } else {
                child = f(event.value());
                unsubChild = void 0;
                childEnded = false;
                removeChild = function () {
                  if (unsubChild != null) {
                    remove(unsubChild, children);
                  }
                  return checkEnd();
                };
                handler = function (event) {
                  var reply;
                  if (event.isEnd()) {
                    removeChild();
                    childEnded = true;
                    return Bacon.noMore;
                  } else {
                    if (event instanceof Initial) {
                      event = event.toNext();
                    }
                    reply = sink(event);
                    if (reply === Bacon.noMore) {
                      unbind();
                    }
                    return reply;
                  }
                };
                unsubChild = child.subscribe(handler);
                if (!childEnded) {
                  return children.push(unsubChild);
                }
              }
            };
            unsubRoot = root.subscribe(spawner);
            return unbind;
          });
        };
        Observable.prototype.flatMapLatest = function (f) {
          var stream, _this = this;
          stream = this.toEventStream();
          return stream.flatMap(function (value) {
            return f(value).takeUntil(stream);
          });
        };
        Observable.prototype.not = function () {
          return this.map(function (x) {
            return !x;
          });
        };
        Observable.prototype.log = function () {
          this.subscribe(function (event) {
            return console.log(event.describe());
          });
          return this;
        };
        Observable.prototype.slidingWindow = function (n) {
          return this.scan([], function (window, value) {
            return window.concat([value]).slice(-n);
          });
        };
        return Observable;
      }();
      EventStream = function (_super) {
        __extends(EventStream, _super);
        function EventStream(subscribe) {
          var dispatcher;
          EventStream.__super__.constructor.call(this);
          assertFunction(subscribe);
          dispatcher = new Dispatcher(subscribe);
          this.subscribe = dispatcher.subscribe;
          this.hasSubscribers = dispatcher.hasSubscribers;
        }
        EventStream.prototype.map = function () {
          var args, p;
          p = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (p instanceof Property) {
            return p.sampledBy(this, former);
          } else {
            return EventStream.__super__.map.apply(this, [p].concat(__slice.call(args)));
          }
        };
        EventStream.prototype.filter = function () {
          var args, p;
          p = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (p instanceof Property) {
            return p.sampledBy(this, function (p, s) {
              return [
                p,
                s
              ];
            }).filter(function (_arg) {
              var p, s;
              p = _arg[0], s = _arg[1];
              return p;
            }).map(function (_arg) {
              var p, s;
              p = _arg[0], s = _arg[1];
              return s;
            });
          } else {
            return EventStream.__super__.filter.apply(this, [p].concat(__slice.call(args)));
          }
        };
        EventStream.prototype.delay = function (delay) {
          return this.flatMap(function (value) {
            return Bacon.later(delay, value);
          });
        };
        EventStream.prototype.throttle = function (delay) {
          return this.flatMapLatest(function (value) {
            return Bacon.later(delay, value);
          });
        };
        EventStream.prototype.throttle2 = function (delay) {
          return this.bufferWithTime(delay).map(function (values) {
            return values[values.length - 1];
          });
        };
        EventStream.prototype.bufferWithTime = function (delay) {
          var schedule, _this = this;
          schedule = function (buffer) {
            return buffer.schedule();
          };
          return this.buffer(delay, schedule, schedule);
        };
        EventStream.prototype.bufferWithCount = function (count) {
          var flushOnCount;
          flushOnCount = function (buffer) {
            if (buffer.values.length === count) {
              return buffer.flush();
            }
          };
          return this.buffer(0, flushOnCount);
        };
        EventStream.prototype.buffer = function (delay, onInput, onFlush) {
          var buffer, delayMs, reply;
          if (onInput == null) {
            onInput = function () {
            };
          }
          if (onFlush == null) {
            onFlush = function () {
            };
          }
          buffer = {
            scheduled: false,
            end: null,
            values: [],
            flush: function () {
              var reply;
              this.scheduled = false;
              if (this.values.length > 0) {
                reply = this.push(next(this.values));
                this.values = [];
                if (this.end != null) {
                  return this.push(this.end);
                } else if (reply !== Bacon.noMore) {
                  return onFlush(this);
                }
              } else {
                if (this.end != null) {
                  return this.push(this.end);
                }
              }
            },
            schedule: function () {
              var _this = this;
              if (!this.scheduled) {
                this.scheduled = true;
                return delay(function () {
                  return _this.flush();
                });
              }
            }
          };
          reply = Bacon.more;
          if (!isFunction(delay)) {
            delayMs = delay;
            delay = function (f) {
              return setTimeout(f, delayMs);
            };
          }
          return this.withHandler(function (event) {
            buffer.push = this.push;
            if (event.isError()) {
              reply = this.push(event);
            } else if (event.isEnd()) {
              buffer.end = event;
              if (!buffer.scheduled) {
                buffer.flush();
              }
            } else {
              buffer.values.push(event.value());
              onInput(buffer);
            }
            return reply;
          });
        };
        EventStream.prototype.merge = function (right) {
          var left;
          left = this;
          return new EventStream(function (sink) {
            var ends, smartSink, unsubBoth, unsubLeft, unsubRight, unsubscribed;
            unsubLeft = nop;
            unsubRight = nop;
            unsubscribed = false;
            unsubBoth = function () {
              unsubLeft();
              unsubRight();
              return unsubscribed = true;
            };
            ends = 0;
            smartSink = function (event) {
              var reply;
              if (event.isEnd()) {
                ends++;
                if (ends === 2) {
                  return sink(end());
                } else {
                  return Bacon.more;
                }
              } else {
                reply = sink(event);
                if (reply === Bacon.noMore) {
                  unsubBoth();
                }
                return reply;
              }
            };
            unsubLeft = left.subscribe(smartSink);
            if (!unsubscribed) {
              unsubRight = right.subscribe(smartSink);
            }
            return unsubBoth;
          });
        };
        EventStream.prototype.toProperty = function (initValue) {
          if (arguments.length === 0) {
            initValue = None;
          }
          return this.scan(initValue, latter);
        };
        EventStream.prototype.toEventStream = function () {
          return this;
        };
        EventStream.prototype.concat = function (right) {
          var left;
          left = this;
          return new EventStream(function (sink) {
            var unsub;
            unsub = left.subscribe(function (e) {
              if (e.isEnd()) {
                return unsub = right.subscribe(sink);
              } else {
                return sink(e);
              }
            });
            return function () {
              return unsub();
            };
          });
        };
        EventStream.prototype.awaiting = function (other) {
          return this.map(true).merge(other.map(false)).toProperty(false);
        };
        EventStream.prototype.startWith = function (seed) {
          return Bacon.once(seed).concat(this);
        };
        EventStream.prototype.mapEnd = function () {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          f = makeFunction(f, args);
          return this.withHandler(function (event) {
            if (event.isEnd()) {
              this.push(next(f(event)));
              this.push(end());
              return Bacon.noMore;
            } else {
              return this.push(event);
            }
          });
        };
        EventStream.prototype.withHandler = function (handler) {
          var dispatcher;
          dispatcher = new Dispatcher(this.subscribe, handler);
          return new EventStream(dispatcher.subscribe);
        };
        EventStream.prototype.withSubscribe = function (subscribe) {
          return new EventStream(subscribe);
        };
        return EventStream;
      }(Observable);
      Property = function (_super) {
        __extends(Property, _super);
        function Property(subscribe) {
          var combine, _this = this;
          this.subscribe = subscribe;
          this.toEventStream = __bind(this.toEventStream, this);
          this.toProperty = __bind(this.toProperty, this);
          this.changes = __bind(this.changes, this);
          this.sample = __bind(this.sample, this);
          Property.__super__.constructor.call(this);
          combine = function (other, leftSink, rightSink) {
            var myVal, otherVal;
            myVal = None;
            otherVal = None;
            return new Property(function (sink) {
              var checkEnd, combiningSink, initialSent, myEnd, mySink, otherEnd, otherSink, unsubBoth, unsubMe, unsubOther, unsubscribed;
              unsubscribed = false;
              unsubMe = nop;
              unsubOther = nop;
              unsubBoth = function () {
                unsubMe();
                unsubOther();
                return unsubscribed = true;
              };
              myEnd = false;
              otherEnd = false;
              checkEnd = function () {
                var reply;
                if (myEnd && otherEnd) {
                  reply = sink(end());
                  if (reply === Bacon.noMore) {
                    unsubBoth();
                  }
                  return reply;
                }
              };
              initialSent = false;
              combiningSink = function (markEnd, setValue, thisSink) {
                return function (event) {
                  var reply;
                  if (event.isEnd()) {
                    markEnd();
                    checkEnd();
                    return Bacon.noMore;
                  } else if (event.isError()) {
                    reply = sink(event);
                    if (reply === Bacon.noMore) {
                      unsubBoth();
                    }
                    return reply;
                  } else {
                    setValue(new Some(event.value()));
                    if (myVal.isDefined && otherVal.isDefined) {
                      if (initialSent && event.isInitial()) {
                        return Bacon.more;
                      } else {
                        initialSent = true;
                        reply = thisSink(sink, event, myVal.value, otherVal.value);
                        if (reply === Bacon.noMore) {
                          unsubBoth();
                        }
                        return reply;
                      }
                    } else {
                      return Bacon.more;
                    }
                  }
                };
              };
              mySink = combiningSink(function () {
                return myEnd = true;
              }, function (value) {
                return myVal = value;
              }, leftSink);
              otherSink = combiningSink(function () {
                return otherEnd = true;
              }, function (value) {
                return otherVal = value;
              }, rightSink);
              unsubMe = _this.subscribe(mySink);
              if (!unsubscribed) {
                unsubOther = other.subscribe(otherSink);
              }
              return unsubBoth;
            });
          };
          this.combine = function (other, f) {
            var combinator, combineAndPush;
            combinator = toCombinator(f);
            combineAndPush = function (sink, event, myVal, otherVal) {
              return sink(event.apply(combinator(myVal, otherVal)));
            };
            return combine(other, combineAndPush, combineAndPush);
          };
          this.sampledBy = function (sampler, combinator) {
            var pushPropertyValue;
            if (combinator == null) {
              combinator = former;
            }
            combinator = toCombinator(combinator);
            pushPropertyValue = function (sink, event, propertyVal, streamVal) {
              return sink(event.apply(combinator(propertyVal, streamVal)));
            };
            return combine(sampler, nop, pushPropertyValue).changes().takeUntil(sampler.filter(false).mapEnd());
          };
        }
        Property.prototype.sample = function (interval) {
          return this.sampledBy(Bacon.interval(interval, {}));
        };
        Property.prototype.changes = function () {
          var _this = this;
          return new EventStream(function (sink) {
            return _this.subscribe(function (event) {
              if (!event.isInitial()) {
                return sink(event);
              }
            });
          });
        };
        Property.prototype.withHandler = function (handler) {
          return new Property(new PropertyDispatcher(this.subscribe, handler).subscribe);
        };
        Property.prototype.withSubscribe = function (subscribe) {
          return new Property(new PropertyDispatcher(subscribe).subscribe);
        };
        Property.prototype.toProperty = function () {
          return this;
        };
        Property.prototype.toEventStream = function () {
          var _this = this;
          return new EventStream(function (sink) {
            return _this.subscribe(function (event) {
              if (event.isInitial()) {
                event = event.toNext();
              }
              return sink(event);
            });
          });
        };
        Property.prototype.and = function (other) {
          return this.combine(other, function (x, y) {
            return x && y;
          });
        };
        Property.prototype.or = function (other) {
          return this.combine(other, function (x, y) {
            return x || y;
          });
        };
        Property.prototype.decode = function (cases) {
          return this.combine(Bacon.combineTemplate(cases), function (key, values) {
            return values[key];
          });
        };
        Property.prototype.delay = function (delay) {
          return this.delayChanges(function (changes) {
            return changes.delay(delay);
          });
        };
        Property.prototype.throttle = function (delay) {
          return this.delayChanges(function (changes) {
            return changes.throttle(delay);
          });
        };
        Property.prototype.throttle2 = function (delay) {
          return this.delayChanges(function (changes) {
            return changes.throttle2(delay);
          });
        };
        Property.prototype.delayChanges = function (f) {
          return addPropertyInitValueToStream(this, f(this.changes()));
        };
        return Property;
      }(Observable);
      addPropertyInitValueToStream = function (property, stream) {
        var getInitValue;
        getInitValue = function (property) {
          var value;
          value = None;
          property.subscribe(function (event) {
            if (event.isInitial()) {
              value = new Some(event.value());
            }
            return Bacon.noMore;
          });
          return value;
        };
        return stream.toProperty(getInitValue(property));
      };
      Dispatcher = function () {
        function Dispatcher(subscribe, handleEvent) {
          var ended, removeSink, sinks, unsubscribeFromSource, _this = this;
          if (subscribe == null) {
            subscribe = function () {
              return nop;
            };
          }
          sinks = [];
          ended = false;
          this.hasSubscribers = function () {
            return sinks.length > 0;
          };
          unsubscribeFromSource = nop;
          removeSink = function (sink) {
            return remove(sink, sinks);
          };
          this.push = function (event) {
            var done, reply, sink, waiters, _i, _len, _ref1;
            waiters = void 0;
            done = function () {
              var w, ws, _i, _len;
              if (waiters != null) {
                ws = waiters;
                waiters = void 0;
                for (_i = 0, _len = ws.length; _i < _len; _i++) {
                  w = ws[_i];
                  w();
                }
              }
              return event.onDone = Event.prototype.onDone;
            };
            event.onDone = function (listener) {
              if (waiters != null && !_.contains(waiters, listener)) {
                return waiters.push(listener);
              } else {
                return waiters = [listener];
              }
            };
            assertEvent(event);
            _ref1 = cloneArray(sinks);
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              sink = _ref1[_i];
              reply = sink(event);
              if (reply === Bacon.noMore || event.isEnd()) {
                removeSink(sink);
              }
            }
            done();
            if (_this.hasSubscribers()) {
              return Bacon.more;
            } else {
              return Bacon.noMore;
            }
          };
          if (handleEvent == null) {
            handleEvent = function (event) {
              return this.push(event);
            };
          }
          this.handleEvent = function (event) {
            assertEvent(event);
            if (event.isEnd()) {
              ended = true;
            }
            return handleEvent.apply(_this, [event]);
          };
          this.subscribe = function (sink) {
            if (ended) {
              sink(end());
              return nop;
            } else {
              assertFunction(sink);
              sinks.push(sink);
              if (sinks.length === 1) {
                unsubscribeFromSource = subscribe(_this.handleEvent);
              }
              assertFunction(unsubscribeFromSource);
              return function () {
                removeSink(sink);
                if (!_this.hasSubscribers()) {
                  return unsubscribeFromSource();
                }
              };
            }
          };
        }
        return Dispatcher;
      }();
      PropertyDispatcher = function (_super) {
        __extends(PropertyDispatcher, _super);
        function PropertyDispatcher(subscribe, handleEvent) {
          var current, ended, push, _this = this;
          PropertyDispatcher.__super__.constructor.call(this, subscribe, handleEvent);
          current = None;
          push = this.push;
          subscribe = this.subscribe;
          ended = false;
          this.push = function (event) {
            if (event.isEnd()) {
              ended = true;
            }
            if (event.hasValue()) {
              current = new Some(event.value());
            }
            return push.apply(_this, [event]);
          };
          this.subscribe = function (sink) {
            var initSent, reply, shouldBounceInitialValue;
            initSent = false;
            shouldBounceInitialValue = function () {
              return _this.hasSubscribers() || ended;
            };
            reply = current.filter(shouldBounceInitialValue).map(function (val) {
              return sink(initial(val));
            });
            if (reply.getOrElse(Bacon.more) === Bacon.noMore) {
              return nop;
            } else if (ended) {
              sink(end());
              return nop;
            } else {
              return subscribe.apply(_this, [sink]);
            }
          };
        }
        return PropertyDispatcher;
      }(Dispatcher);
      Bus = function (_super) {
        __extends(Bus, _super);
        function Bus() {
          var dispatcher, ended, guardedSink, sink, subscribeAll, subscribeInput, subscribeThis, subscriptions, unsubAll, unsubscribeInput, _this = this;
          sink = void 0;
          subscriptions = [];
          ended = false;
          guardedSink = function (input) {
            return function (event) {
              if (event.isEnd()) {
                unsubscribeInput(input);
                return Bacon.noMore;
              } else {
                return sink(event);
              }
            };
          };
          unsubAll = function () {
            var sub, _i, _len;
            for (_i = 0, _len = subscriptions.length; _i < _len; _i++) {
              sub = subscriptions[_i];
              if (sub.unsub != null) {
                sub.unsub();
              }
            }
            return subscriptions = [];
          };
          subscribeInput = function (subscription) {
            return subscription.unsub = subscription.input.subscribe(guardedSink(subscription.input));
          };
          unsubscribeInput = function (input) {
            var i, sub, _i, _len;
            for (i = _i = 0, _len = subscriptions.length; _i < _len; i = ++_i) {
              sub = subscriptions[i];
              if (sub.input === input) {
                if (sub.unsub != null) {
                  sub.unsub();
                }
                subscriptions.splice(i, 1);
                return;
              }
            }
          };
          subscribeAll = function (newSink) {
            var subscription, unsubFuncs, _i, _len, _ref1;
            sink = newSink;
            unsubFuncs = [];
            _ref1 = cloneArray(subscriptions);
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              subscription = _ref1[_i];
              subscribeInput(subscription);
            }
            return unsubAll;
          };
          dispatcher = new Dispatcher(subscribeAll);
          subscribeThis = function (sink) {
            return dispatcher.subscribe(sink);
          };
          Bus.__super__.constructor.call(this, subscribeThis);
          this.plug = function (input) {
            var sub;
            if (ended) {
              return;
            }
            sub = { input: input };
            subscriptions.push(sub);
            if (sink != null) {
              subscribeInput(sub);
            }
            return function () {
              return unsubscribeInput(input);
            };
          };
          this.push = function (value) {
            if (sink != null) {
              return sink(next(value));
            }
          };
          this.error = function (error) {
            if (sink != null) {
              return sink(new Error(error));
            }
          };
          this.end = function () {
            ended = true;
            unsubAll();
            if (sink != null) {
              return sink(end());
            }
          };
        }
        return Bus;
      }(EventStream);
      Some = function () {
        function Some(value) {
          this.value = value;
        }
        Some.prototype.getOrElse = function () {
          return this.value;
        };
        Some.prototype.get = function () {
          return this.value;
        };
        Some.prototype.filter = function (f) {
          if (f(this.value)) {
            return new Some(this.value);
          } else {
            return None;
          }
        };
        Some.prototype.map = function (f) {
          return new Some(f(this.value));
        };
        Some.prototype.forEach = function (f) {
          return f(this.value);
        };
        Some.prototype.isDefined = true;
        Some.prototype.toArray = function () {
          return [this.value];
        };
        return Some;
      }();
      None = {
        getOrElse: function (value) {
          return value;
        },
        filter: function () {
          return None;
        },
        map: function () {
          return None;
        },
        forEach: function () {
        },
        isDefined: false,
        toArray: function () {
          return [];
        }
      };
      Bacon.EventStream = EventStream;
      Bacon.Property = Property;
      Bacon.Observable = Observable;
      Bacon.Bus = Bus;
      Bacon.Initial = Initial;
      Bacon.Next = Next;
      Bacon.End = End;
      Bacon.Error = Error;
      nop = function () {
      };
      latter = function (_, x) {
        return x;
      };
      former = function (x, _) {
        return x;
      };
      initial = function (value) {
        return new Initial(_.always(value));
      };
      next = function (value) {
        return new Next(_.always(value));
      };
      end = function () {
        return new End;
      };
      isEvent = function (x) {
        return x != null && x.isEvent != null && x.isEvent();
      };
      toEvent = function (x) {
        if (isEvent(x)) {
          return x;
        } else {
          return next(x);
        }
      };
      cloneArray = function (xs) {
        return xs.slice(0);
      };
      cloneObject = function (src) {
        var clone, key, value;
        clone = {};
        for (key in src) {
          value = src[key];
          clone[key] = value;
        }
        return clone;
      };
      indexOf = Array.prototype.indexOf ? function (xs, x) {
        return xs.indexOf(x);
      } : function (xs, x) {
        var i, y, _i, _len;
        for (i = _i = 0, _len = xs.length; _i < _len; i = ++_i) {
          y = xs[i];
          if (x === y) {
            return i;
          }
        }
        return -1;
      };
      remove = function (x, xs) {
        var i;
        i = indexOf(xs, x);
        if (i >= 0) {
          return xs.splice(i, 1);
        }
      };
      assert = function (message, condition) {
        if (!condition) {
          throw message;
        }
      };
      assertEvent = function (event) {
        assert('not an event : ' + event, event.isEvent != null);
        return assert('not event', event.isEvent());
      };
      assertFunction = function (f) {
        return assert('not a function : ' + f, isFunction(f));
      };
      isFunction = function (f) {
        return typeof f === 'function';
      };
      assertArray = function (xs) {
        return assert('not an array : ' + xs, xs instanceof Array);
      };
      assertString = function (x) {
        return assert('not a string : ' + x, typeof x === 'string');
      };
      methodCall = function (obj, method, args) {
        assertString(method);
        if (args === void 0) {
          args = [];
        }
        return function (value) {
          return obj[method].apply(obj, args.concat([value]));
        };
      };
      partiallyApplied = function (f, args) {
        return function (value) {
          return f.apply(null, args.concat([value]));
        };
      };
      makeFunction = function (f, args) {
        if (isFunction(f)) {
          if (args.length) {
            return partiallyApplied(f, args);
          } else {
            return f;
          }
        } else if (isFieldKey(f)) {
          return toFieldExtractor(f, args);
        } else if (typeof f === 'object' && args.length) {
          return methodCall(f, _.head(args), _.tail(args));
        } else {
          return _.always(f);
        }
      };
      isFieldKey = function (f) {
        return typeof f === 'string' && f.length > 1 && f.charAt(0) === '.';
      };
      Bacon.isFieldKey = isFieldKey;
      toFieldExtractor = function (f, args) {
        var partFuncs, parts;
        parts = f.slice(1).split('.');
        partFuncs = _.map(toSimpleExtractor(args), parts);
        return function (value) {
          var _i, _len;
          for (_i = 0, _len = partFuncs.length; _i < _len; _i++) {
            f = partFuncs[_i];
            value = f(value);
          }
          return value;
        };
      };
      toSimpleExtractor = function (args) {
        return function (key) {
          return function (value) {
            var fieldValue;
            fieldValue = value[key];
            if (isFunction(fieldValue)) {
              return fieldValue.apply(value, args);
            } else {
              return fieldValue;
            }
          };
        };
      };
      toFieldKey = function (f) {
        return f.slice(1);
      };
      toCombinator = function (f) {
        var key;
        if (isFunction(f)) {
          return f;
        } else if (isFieldKey(f)) {
          key = toFieldKey(f);
          return function (left, right) {
            return left[key](right);
          };
        } else {
          return assert('not a function or a field key: ' + f, false);
        }
      };
      toOption = function (v) {
        if (v instanceof Some || v === None) {
          return v;
        } else {
          return new Some(v);
        }
      };
      if (typeof define !== 'undefined' && define !== null && define.amd != null) {
        if (typeof define === 'function') {
          define(function () {
            return Bacon;
          });
        }
      }
      _ = {
        head: function (xs) {
          return xs[0];
        },
        always: function (x) {
          return function () {
            return x;
          };
        },
        empty: function (xs) {
          return xs.length === 0;
        },
        tail: function (xs) {
          return xs.slice(1, xs.length);
        },
        filter: function (f, xs) {
          var filtered, x, _i, _len;
          filtered = [];
          for (_i = 0, _len = xs.length; _i < _len; _i++) {
            x = xs[_i];
            if (f(x)) {
              filtered.push(x);
            }
          }
          return filtered;
        },
        map: function (f, xs) {
          var x, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = xs.length; _i < _len; _i++) {
            x = xs[_i];
            _results.push(f(x));
          }
          return _results;
        },
        each: function (xs, f) {
          var key, value, _results;
          _results = [];
          for (key in xs) {
            value = xs[key];
            _results.push(f(key, value));
          }
          return _results;
        },
        toArray: function (xs) {
          if (xs instanceof Array) {
            return xs;
          } else {
            return [xs];
          }
        },
        contains: function (xs, x) {
          return indexOf(xs, x) !== -1;
        },
        id: function (x) {
          return x;
        },
        last: function (xs) {
          return xs[xs.length - 1];
        }
      };
      Bacon._ = _;
    }.call(this));
  });
  require.define('/../node_modules/markdown/lib/index.js', function (module, exports, __dirname, __filename) {
    exports.markdown = require('/../node_modules/markdown/lib/markdown.js', module);
    exports.parse = exports.markdown.toHTML;
  });
  require.define('/../node_modules/markdown/lib/markdown.js', function (module, exports, __dirname, __filename) {
    (function (expose) {
      var Markdown = expose.Markdown = function (dialect) {
          switch (typeof dialect) {
          case 'undefined':
            this.dialect = Markdown.dialects.Gruber;
            break;
          case 'object':
            this.dialect = dialect;
            break;
          default:
            if (dialect in Markdown.dialects) {
              this.dialect = Markdown.dialects[dialect];
            } else {
              throw new Error("Unknown Markdown dialect '" + String(dialect) + "'");
            }
            break;
          }
          this.em_state = [];
          this.strong_state = [];
          this.debug_indent = '';
        };
      expose.parse = function (source, dialect) {
        var md = new Markdown(dialect);
        return md.toTree(source);
      };
      expose.toHTML = function toHTML(source, dialect, options) {
        var input = expose.toHTMLTree(source, dialect, options);
        return expose.renderJsonML(input);
      };
      expose.toHTMLTree = function toHTMLTree(input, dialect, options) {
        if (typeof input === 'string')
          input = this.parse(input, dialect);
        var attrs = extract_attr(input), refs = {};
        if (attrs && attrs.references) {
          refs = attrs.references;
        }
        var html = convert_tree_to_html(input, refs, options);
        merge_text_nodes(html);
        return html;
      };
      function mk_block_toSource() {
        return 'Markdown.mk_block( ' + uneval(this.toString()) + ', ' + uneval(this.trailing) + ', ' + uneval(this.lineNumber) + ' )';
      }
      function mk_block_inspect() {
        var util = require('util', module);
        return 'Markdown.mk_block( ' + util.inspect(this.toString()) + ', ' + util.inspect(this.trailing) + ', ' + util.inspect(this.lineNumber) + ' )';
      }
      var mk_block = Markdown.mk_block = function (block, trail, line) {
          if (arguments.length == 1)
            trail = '\n\n';
          var s = new String(block);
          s.trailing = trail;
          s.inspect = mk_block_inspect;
          s.toSource = mk_block_toSource;
          if (line != undefined)
            s.lineNumber = line;
          return s;
        };
      function count_lines(str) {
        var n = 0, i = -1;
        while ((i = str.indexOf('\n', i + 1)) !== -1)
          n++;
        return n;
      }
      Markdown.prototype.split_blocks = function splitBlocks(input, startLine) {
        input = input.replace(/(\r\n|\n|\r)/g, '\n');
        var re = /([\s\S]+?)($|\n#|\n(?:\s*\n|$)+)/g, blocks = [], m;
        var line_no = 1;
        if ((m = /^(\s*\n)/.exec(input)) != null) {
          line_no += count_lines(m[0]);
          re.lastIndex = m[0].length;
        }
        while ((m = re.exec(input)) !== null) {
          if (m[2] == '\n#') {
            m[2] = '\n';
            re.lastIndex--;
          }
          blocks.push(mk_block(m[1], m[2], line_no));
          line_no += count_lines(m[0]);
        }
        return blocks;
      };
      Markdown.prototype.processBlock = function processBlock(block, next) {
        var cbs = this.dialect.block, ord = cbs.__order__;
        if ('__call__' in cbs) {
          return cbs.__call__.call(this, block, next);
        }
        for (var i = 0; i < ord.length; i++) {
          var res = cbs[ord[i]].call(this, block, next);
          if (res) {
            if (!isArray(res) || res.length > 0 && !isArray(res[0]))
              this.debug(ord[i], "didn't return a proper array");
            return res;
          }
        }
        return [];
      };
      Markdown.prototype.processInline = function processInline(block) {
        return this.dialect.inline.__call__.call(this, String(block));
      };
      Markdown.prototype.toTree = function toTree(source, custom_root) {
        var blocks = source instanceof Array ? source : this.split_blocks(source);
        var old_tree = this.tree;
        try {
          this.tree = custom_root || this.tree || ['markdown'];
          blocks:
            while (blocks.length) {
              var b = this.processBlock(blocks.shift(), blocks);
              if (!b.length)
                continue blocks;
              this.tree.push.apply(this.tree, b);
            }
          return this.tree;
        } finally {
          if (custom_root) {
            this.tree = old_tree;
          }
        }
      };
      Markdown.prototype.debug = function () {
        var args = Array.prototype.slice.call(arguments);
        args.unshift(this.debug_indent);
        if (typeof print !== 'undefined')
          print.apply(print, args);
        if (typeof console !== 'undefined' && typeof console.log !== 'undefined')
          console.log.apply(null, args);
      };
      Markdown.prototype.loop_re_over_block = function (re, block, cb) {
        var m, b = block.valueOf();
        while (b.length && (m = re.exec(b)) != null) {
          b = b.substr(m[0].length);
          cb.call(this, m);
        }
        return b;
      };
      Markdown.dialects = {};
      Markdown.dialects.Gruber = {
        block: {
          atxHeader: function atxHeader(block, next) {
            var m = block.match(/^(#{1,6})\s*(.*?)\s*#*\s*(?:\n|$)/);
            if (!m)
              return undefined;
            var header = [
                'header',
                { level: m[1].length }
              ];
            Array.prototype.push.apply(header, this.processInline(m[2]));
            if (m[0].length < block.length)
              next.unshift(mk_block(block.substr(m[0].length), block.trailing, block.lineNumber + 2));
            return [header];
          },
          setextHeader: function setextHeader(block, next) {
            var m = block.match(/^(.*)\n([-=])\2\2+(?:\n|$)/);
            if (!m)
              return undefined;
            var level = m[2] === '=' ? 1 : 2;
            var header = [
                'header',
                { level: level },
                m[1]
              ];
            if (m[0].length < block.length)
              next.unshift(mk_block(block.substr(m[0].length), block.trailing, block.lineNumber + 2));
            return [header];
          },
          code: function code(block, next) {
            var ret = [], re = /^(?: {0,3}\t| {4})(.*)\n?/, lines;
            if (!block.match(re))
              return undefined;
            block_search:
              do {
                var b = this.loop_re_over_block(re, block.valueOf(), function (m) {
                    ret.push(m[1]);
                  });
                if (b.length) {
                  next.unshift(mk_block(b, block.trailing));
                  break block_search;
                } else if (next.length) {
                  if (!next[0].match(re))
                    break block_search;
                  ret.push(block.trailing.replace(/[^\n]/g, '').substring(2));
                  block = next.shift();
                } else {
                  break block_search;
                }
              } while (true);
            return [[
                'code_block',
                ret.join('\n')
              ]];
          },
          horizRule: function horizRule(block, next) {
            var m = block.match(/^(?:([\s\S]*?)\n)?[ \t]*([-_*])(?:[ \t]*\2){2,}[ \t]*(?:\n([\s\S]*))?$/);
            if (!m) {
              return undefined;
            }
            var jsonml = [['hr']];
            if (m[1]) {
              jsonml.unshift.apply(jsonml, this.processBlock(m[1], []));
            }
            if (m[3]) {
              next.unshift(mk_block(m[3]));
            }
            return jsonml;
          },
          lists: function () {
            var any_list = '[*+-]|\\d+\\.', bullet_list = /[*+-]/, number_list = /\d+\./, is_list_re = new RegExp('^( {0,3})(' + any_list + ')[ \t]+'), indent_re = '(?: {0,3}\\t| {4})';
            function regex_for_depth(depth) {
              return new RegExp('(?:^(' + indent_re + '{0,' + depth + '} {0,3})(' + any_list + ')\\s+)|' + '(^' + indent_re + '{0,' + (depth - 1) + '}[ ]{0,4})');
            }
            function expand_tab(input) {
              return input.replace(/ {0,3}\t/g, '    ');
            }
            function add(li, loose, inline, nl) {
              if (loose) {
                li.push(['para'].concat(inline));
                return;
              }
              var add_to = li[li.length - 1] instanceof Array && li[li.length - 1][0] == 'para' ? li[li.length - 1] : li;
              if (nl && li.length > 1)
                inline.unshift(nl);
              for (var i = 0; i < inline.length; i++) {
                var what = inline[i], is_str = typeof what == 'string';
                if (is_str && add_to.length > 1 && typeof add_to[add_to.length - 1] == 'string') {
                  add_to[add_to.length - 1] += what;
                } else {
                  add_to.push(what);
                }
              }
            }
            function get_contained_blocks(depth, blocks) {
              var re = new RegExp('^(' + indent_re + '{' + depth + '}.*?\\n?)*$'), replace = new RegExp('^' + indent_re + '{' + depth + '}', 'gm'), ret = [];
              while (blocks.length > 0) {
                if (re.exec(blocks[0])) {
                  var b = blocks.shift(), x = b.replace(replace, '');
                  ret.push(mk_block(x, b.trailing, b.lineNumber));
                } else {
                  break;
                }
              }
              return ret;
            }
            function paragraphify(s, i, stack) {
              var list = s.list;
              var last_li = list[list.length - 1];
              if (last_li[1] instanceof Array && last_li[1][0] == 'para') {
                return;
              }
              if (i + 1 == stack.length) {
                last_li.push(['para'].concat(last_li.splice(1, last_li.length - 1)));
              } else {
                var sublist = last_li.pop();
                last_li.push(['para'].concat(last_li.splice(1, last_li.length - 1)), sublist);
              }
            }
            return function (block, next) {
              var m = block.match(is_list_re);
              if (!m)
                return undefined;
              function make_list(m) {
                var list = bullet_list.exec(m[2]) ? ['bulletlist'] : ['numberlist'];
                stack.push({
                  list: list,
                  indent: m[1]
                });
                return list;
              }
              var stack = [], list = make_list(m), last_li, loose = false, ret = [stack[0].list], i;
              loose_search:
                while (true) {
                  var lines = block.split(/(?=\n)/);
                  var li_accumulate = '';
                  tight_search:
                    for (var line_no = 0; line_no < lines.length; line_no++) {
                      var nl = '', l = lines[line_no].replace(/^\n/, function (n) {
                          nl = n;
                          return '';
                        });
                      var line_re = regex_for_depth(stack.length);
                      m = l.match(line_re);
                      if (m[1] !== undefined) {
                        if (li_accumulate.length) {
                          add(last_li, loose, this.processInline(li_accumulate), nl);
                          loose = false;
                          li_accumulate = '';
                        }
                        m[1] = expand_tab(m[1]);
                        var wanted_depth = Math.floor(m[1].length / 4) + 1;
                        if (wanted_depth > stack.length) {
                          list = make_list(m);
                          last_li.push(list);
                          last_li = list[1] = ['listitem'];
                        } else {
                          var found = false;
                          for (i = 0; i < stack.length; i++) {
                            if (stack[i].indent != m[1])
                              continue;
                            list = stack[i].list;
                            stack.splice(i + 1, stack.length - (i + 1));
                            found = true;
                            break;
                          }
                          if (!found) {
                            wanted_depth++;
                            if (wanted_depth <= stack.length) {
                              stack.splice(wanted_depth, stack.length - wanted_depth);
                              list = stack[wanted_depth - 1].list;
                            } else {
                              list = make_list(m);
                              last_li.push(list);
                            }
                          }
                          last_li = ['listitem'];
                          list.push(last_li);
                        }
                        nl = '';
                      }
                      if (l.length > m[0].length) {
                        li_accumulate += nl + l.substr(m[0].length);
                      }
                    }
                  if (li_accumulate.length) {
                    add(last_li, loose, this.processInline(li_accumulate), nl);
                    loose = false;
                    li_accumulate = '';
                  }
                  var contained = get_contained_blocks(stack.length, next);
                  if (contained.length > 0) {
                    forEach(stack, paragraphify, this);
                    last_li.push.apply(last_li, this.toTree(contained, []));
                  }
                  var next_block = next[0] && next[0].valueOf() || '';
                  if (next_block.match(is_list_re) || next_block.match(/^ /)) {
                    block = next.shift();
                    var hr = this.dialect.block.horizRule(block, next);
                    if (hr) {
                      ret.push.apply(ret, hr);
                      break;
                    }
                    forEach(stack, paragraphify, this);
                    loose = true;
                    continue loose_search;
                  }
                  break;
                }
              return ret;
            };
          }(),
          blockquote: function blockquote(block, next) {
            if (!block.match(/^>/m))
              return undefined;
            var jsonml = [];
            if (block[0] != '>') {
              var lines = block.split(/\n/), prev = [], line_no = block.lineNumber;
              while (lines.length && lines[0][0] != '>') {
                prev.push(lines.shift());
                line_no++;
              }
              var abutting = mk_block(prev.join('\n'), '\n', block.lineNumber);
              jsonml.push.apply(jsonml, this.processBlock(abutting, []));
              block = mk_block(lines.join('\n'), block.trailing, line_no);
            }
            while (next.length && next[0][0] == '>') {
              var b = next.shift();
              block = mk_block(block + block.trailing + b, b.trailing, block.lineNumber);
            }
            var input = block.replace(/^> ?/gm, ''), old_tree = this.tree, processedBlock = this.toTree(input, ['blockquote']), attr = extract_attr(processedBlock);
            if (attr && attr.references) {
              delete attr.references;
              if (isEmpty(attr)) {
                processedBlock.splice(1, 1);
              }
            }
            jsonml.push(processedBlock);
            return jsonml;
          },
          referenceDefn: function referenceDefn(block, next) {
            var re = /^\s*\[(.*?)\]:\s*(\S+)(?:\s+(?:(['"])(.*?)\3|\((.*?)\)))?\n?/;
            if (!block.match(re))
              return undefined;
            if (!extract_attr(this.tree)) {
              this.tree.splice(1, 0, {});
            }
            var attrs = extract_attr(this.tree);
            if (attrs.references === undefined) {
              attrs.references = {};
            }
            var b = this.loop_re_over_block(re, block, function (m) {
                if (m[2] && m[2][0] == '<' && m[2][m[2].length - 1] == '>')
                  m[2] = m[2].substring(1, m[2].length - 1);
                var ref = attrs.references[m[1].toLowerCase()] = { href: m[2] };
                if (m[4] !== undefined)
                  ref.title = m[4];
                else if (m[5] !== undefined)
                  ref.title = m[5];
              });
            if (b.length)
              next.unshift(mk_block(b, block.trailing));
            return [];
          },
          para: function para(block, next) {
            return [['para'].concat(this.processInline(block))];
          }
        }
      };
      Markdown.dialects.Gruber.inline = {
        __oneElement__: function oneElement(text, patterns_or_re, previous_nodes) {
          var m, res, lastIndex = 0;
          patterns_or_re = patterns_or_re || this.dialect.inline.__patterns__;
          var re = new RegExp('([\\s\\S]*?)(' + (patterns_or_re.source || patterns_or_re) + ')');
          m = re.exec(text);
          if (!m) {
            return [
              text.length,
              text
            ];
          } else if (m[1]) {
            return [
              m[1].length,
              m[1]
            ];
          }
          var res;
          if (m[2] in this.dialect.inline) {
            res = this.dialect.inline[m[2]].call(this, text.substr(m.index), m, previous_nodes || []);
          }
          res = res || [
            m[2].length,
            m[2]
          ];
          return res;
        },
        __call__: function inline(text, patterns) {
          var out = [], res;
          function add(x) {
            if (typeof x == 'string' && typeof out[out.length - 1] == 'string')
              out[out.length - 1] += x;
            else
              out.push(x);
          }
          while (text.length > 0) {
            res = this.dialect.inline.__oneElement__.call(this, text, patterns, out);
            text = text.substr(res.shift());
            forEach(res, add);
          }
          return out;
        },
        ']': function () {
        },
        '}': function () {
        },
        __escape__: /^\\[\\`\*_{}\[\]()#\+.!\-]/,
        '\\': function escaped(text) {
          if (this.dialect.inline.__escape__.exec(text))
            return [
              2,
              text.charAt(1)
            ];
          else
            return [
              1,
              '\\'
            ];
        },
        '![': function image(text) {
          var m = text.match(/^!\[(.*?)\][ \t]*\([ \t]*([^")]*?)(?:[ \t]+(["'])(.*?)\3)?[ \t]*\)/);
          if (m) {
            if (m[2] && m[2][0] == '<' && m[2][m[2].length - 1] == '>')
              m[2] = m[2].substring(1, m[2].length - 1);
            m[2] = this.dialect.inline.__call__.call(this, m[2], /\\/)[0];
            var attrs = {
                alt: m[1],
                href: m[2] || ''
              };
            if (m[4] !== undefined)
              attrs.title = m[4];
            return [
              m[0].length,
              [
                'img',
                attrs
              ]
            ];
          }
          m = text.match(/^!\[(.*?)\][ \t]*\[(.*?)\]/);
          if (m) {
            return [
              m[0].length,
              [
                'img_ref',
                {
                  alt: m[1],
                  ref: m[2].toLowerCase(),
                  original: m[0]
                }
              ]
            ];
          }
          return [
            2,
            '!['
          ];
        },
        '[': function link(text) {
          var orig = String(text);
          var res = Markdown.DialectHelpers.inline_until_char.call(this, text.substr(1), ']');
          if (!res)
            return [
              1,
              '['
            ];
          var consumed = 1 + res[0], children = res[1], link, attrs;
          text = text.substr(consumed);
          var m = text.match(/^\s*\([ \t]*([^"']*)(?:[ \t]+(["'])(.*?)\2)?[ \t]*\)/);
          if (m) {
            var url = m[1];
            consumed += m[0].length;
            if (url && url[0] == '<' && url[url.length - 1] == '>')
              url = url.substring(1, url.length - 1);
            if (!m[3]) {
              var open_parens = 1;
              for (var len = 0; len < url.length; len++) {
                switch (url[len]) {
                case '(':
                  open_parens++;
                  break;
                case ')':
                  if (--open_parens == 0) {
                    consumed -= url.length - len;
                    url = url.substring(0, len);
                  }
                  break;
                }
              }
            }
            url = this.dialect.inline.__call__.call(this, url, /\\/)[0];
            attrs = { href: url || '' };
            if (m[3] !== undefined)
              attrs.title = m[3];
            link = [
              'link',
              attrs
            ].concat(children);
            return [
              consumed,
              link
            ];
          }
          m = text.match(/^\s*\[(.*?)\]/);
          if (m) {
            consumed += m[0].length;
            attrs = {
              ref: (m[1] || String(children)).toLowerCase(),
              original: orig.substr(0, consumed)
            };
            link = [
              'link_ref',
              attrs
            ].concat(children);
            return [
              consumed,
              link
            ];
          }
          if (children.length == 1 && typeof children[0] == 'string') {
            attrs = {
              ref: children[0].toLowerCase(),
              original: orig.substr(0, consumed)
            };
            link = [
              'link_ref',
              attrs,
              children[0]
            ];
            return [
              consumed,
              link
            ];
          }
          return [
            1,
            '['
          ];
        },
        '<': function autoLink(text) {
          var m;
          if ((m = text.match(/^<(?:((https?|ftp|mailto):[^>]+)|(.*?@.*?\.[a-zA-Z]+))>/)) != null) {
            if (m[3]) {
              return [
                m[0].length,
                [
                  'link',
                  { href: 'mailto:' + m[3] },
                  m[3]
                ]
              ];
            } else if (m[2] == 'mailto') {
              return [
                m[0].length,
                [
                  'link',
                  { href: m[1] },
                  m[1].substr('mailto:'.length)
                ]
              ];
            } else
              return [
                m[0].length,
                [
                  'link',
                  { href: m[1] },
                  m[1]
                ]
              ];
          }
          return [
            1,
            '<'
          ];
        },
        '`': function inlineCode(text) {
          var m = text.match(/(`+)(([\s\S]*?)\1)/);
          if (m && m[2])
            return [
              m[1].length + m[2].length,
              [
                'inlinecode',
                m[3]
              ]
            ];
          else {
            return [
              1,
              '`'
            ];
          }
        },
        '  \n': function lineBreak(text) {
          return [
            3,
            ['linebreak']
          ];
        }
      };
      function strong_em(tag, md) {
        var state_slot = tag + '_state', other_slot = tag == 'strong' ? 'em_state' : 'strong_state';
        function CloseTag(len) {
          this.len_after = len;
          this.name = 'close_' + md;
        }
        return function (text, orig_match) {
          if (this[state_slot][0] == md) {
            this[state_slot].shift();
            return [
              text.length,
              new CloseTag(text.length - md.length)
            ];
          } else {
            var other = this[other_slot].slice(), state = this[state_slot].slice();
            this[state_slot].unshift(md);
            var res = this.processInline(text.substr(md.length));
            var last = res[res.length - 1];
            var check = this[state_slot].shift();
            if (last instanceof CloseTag) {
              res.pop();
              var consumed = text.length - last.len_after;
              return [
                consumed,
                [tag].concat(res)
              ];
            } else {
              this[other_slot] = other;
              this[state_slot] = state;
              return [
                md.length,
                md
              ];
            }
          }
        };
      }
      Markdown.dialects.Gruber.inline['**'] = strong_em('strong', '**');
      Markdown.dialects.Gruber.inline['__'] = strong_em('strong', '__');
      Markdown.dialects.Gruber.inline['*'] = strong_em('em', '*');
      Markdown.dialects.Gruber.inline['_'] = strong_em('em', '_');
      Markdown.buildBlockOrder = function (d) {
        var ord = [];
        for (var i in d) {
          if (i == '__order__' || i == '__call__')
            continue;
          ord.push(i);
        }
        d.__order__ = ord;
      };
      Markdown.buildInlinePatterns = function (d) {
        var patterns = [];
        for (var i in d) {
          if (i.match(/^__.*__$/))
            continue;
          var l = i.replace(/([\\.*+?|()\[\]{}])/g, '\\$1').replace(/\n/, '\\n');
          patterns.push(i.length == 1 ? l : '(?:' + l + ')');
        }
        patterns = patterns.join('|');
        d.__patterns__ = patterns;
        var fn = d.__call__;
        d.__call__ = function (text, pattern) {
          if (pattern != undefined) {
            return fn.call(this, text, pattern);
          } else {
            return fn.call(this, text, patterns);
          }
        };
      };
      Markdown.DialectHelpers = {};
      Markdown.DialectHelpers.inline_until_char = function (text, want) {
        var consumed = 0, nodes = [];
        while (true) {
          if (text.charAt(consumed) == want) {
            consumed++;
            return [
              consumed,
              nodes
            ];
          }
          if (consumed >= text.length) {
            return null;
          }
          var res = this.dialect.inline.__oneElement__.call(this, text.substr(consumed));
          consumed += res[0];
          nodes.push.apply(nodes, res.slice(1));
        }
      };
      Markdown.subclassDialect = function (d) {
        function Block() {
        }
        Block.prototype = d.block;
        function Inline() {
        }
        Inline.prototype = d.inline;
        return {
          block: new Block,
          inline: new Inline
        };
      };
      Markdown.buildBlockOrder(Markdown.dialects.Gruber.block);
      Markdown.buildInlinePatterns(Markdown.dialects.Gruber.inline);
      Markdown.dialects.Maruku = Markdown.subclassDialect(Markdown.dialects.Gruber);
      Markdown.dialects.Maruku.processMetaHash = function processMetaHash(meta_string) {
        var meta = split_meta_hash(meta_string), attr = {};
        for (var i = 0; i < meta.length; ++i) {
          if (/^#/.test(meta[i])) {
            attr.id = meta[i].substring(1);
          } else if (/^\./.test(meta[i])) {
            if (attr['class']) {
              attr['class'] = attr['class'] + meta[i].replace(/./, ' ');
            } else {
              attr['class'] = meta[i].substring(1);
            }
          } else if (/\=/.test(meta[i])) {
            var s = meta[i].split(/\=/);
            attr[s[0]] = s[1];
          }
        }
        return attr;
      };
      function split_meta_hash(meta_string) {
        var meta = meta_string.split(''), parts = [''], in_quotes = false;
        while (meta.length) {
          var letter = meta.shift();
          switch (letter) {
          case ' ':
            if (in_quotes) {
              parts[parts.length - 1] += letter;
            } else {
              parts.push('');
            }
            break;
          case "'":
          case '"':
            in_quotes = !in_quotes;
            break;
          case '\\':
            letter = meta.shift();
          default:
            parts[parts.length - 1] += letter;
            break;
          }
        }
        return parts;
      }
      Markdown.dialects.Maruku.block.document_meta = function document_meta(block, next) {
        if (block.lineNumber > 1)
          return undefined;
        if (!block.match(/^(?:\w+:.*\n)*\w+:.*$/))
          return undefined;
        if (!extract_attr(this.tree)) {
          this.tree.splice(1, 0, {});
        }
        var pairs = block.split(/\n/);
        for (p in pairs) {
          var m = pairs[p].match(/(\w+):\s*(.*)$/), key = m[1].toLowerCase(), value = m[2];
          this.tree[1][key] = value;
        }
        return [];
      };
      Markdown.dialects.Maruku.block.block_meta = function block_meta(block, next) {
        var m = block.match(/(^|\n) {0,3}\{:\s*((?:\\\}|[^\}])*)\s*\}$/);
        if (!m)
          return undefined;
        var attr = this.dialect.processMetaHash(m[2]);
        var hash;
        if (m[1] === '') {
          var node = this.tree[this.tree.length - 1];
          hash = extract_attr(node);
          if (typeof node === 'string')
            return undefined;
          if (!hash) {
            hash = {};
            node.splice(1, 0, hash);
          }
          for (a in attr) {
            hash[a] = attr[a];
          }
          return [];
        }
        var b = block.replace(/\n.*$/, ''), result = this.processBlock(b, []);
        hash = extract_attr(result[0]);
        if (!hash) {
          hash = {};
          result[0].splice(1, 0, hash);
        }
        for (a in attr) {
          hash[a] = attr[a];
        }
        return result;
      };
      Markdown.dialects.Maruku.block.definition_list = function definition_list(block, next) {
        var tight = /^((?:[^\s:].*\n)+):\s+([\s\S]+)$/, list = ['dl'], i, m;
        if (m = block.match(tight)) {
          var blocks = [block];
          while (next.length && tight.exec(next[0])) {
            blocks.push(next.shift());
          }
          for (var b = 0; b < blocks.length; ++b) {
            var m = blocks[b].match(tight), terms = m[1].replace(/\n$/, '').split(/\n/), defns = m[2].split(/\n:\s+/);
            for (i = 0; i < terms.length; ++i) {
              list.push([
                'dt',
                terms[i]
              ]);
            }
            for (i = 0; i < defns.length; ++i) {
              list.push(['dd'].concat(this.processInline(defns[i].replace(/(\n)\s+/, '$1'))));
            }
          }
        } else {
          return undefined;
        }
        return [list];
      };
      Markdown.dialects.Maruku.block.table = function table(block, next) {
        var _split_on_unescaped = function (s, ch) {
          ch = ch || '\\s';
          if (ch.match(/^[\\|\[\]{}?*.+^$]$/)) {
            ch = '\\' + ch;
          }
          var res = [], r = new RegExp('^((?:\\\\.|[^\\\\' + ch + '])*)' + ch + '(.*)'), m;
          while (m = s.match(r)) {
            res.push(m[1]);
            s = m[2];
          }
          res.push(s);
          return res;
        };
        var leading_pipe = /^ {0,3}\|(.+)\n {0,3}\|\s*([\-:]+[\-| :]*)\n((?:\s*\|.*(?:\n|$))*)(?=\n|$)/, no_leading_pipe = /^ {0,3}(\S(?:\\.|[^\\|])*\|.*)\n {0,3}([\-:]+\s*\|[\-| :]*)\n((?:(?:\\.|[^\\|])*\|.*(?:\n|$))*)(?=\n|$)/, i, m;
        if (m = block.match(leading_pipe)) {
          m[3] = m[3].replace(/^\s*\|/gm, '');
        } else if (!(m = block.match(no_leading_pipe))) {
          return undefined;
        }
        var table = [
            'table',
            [
              'thead',
              ['tr']
            ],
            ['tbody']
          ];
        m[2] = m[2].replace(/\|\s*$/, '').split('|');
        var html_attrs = [];
        forEach(m[2], function (s) {
          if (s.match(/^\s*-+:\s*$/))
            html_attrs.push({ align: 'right' });
          else if (s.match(/^\s*:-+\s*$/))
            html_attrs.push({ align: 'left' });
          else if (s.match(/^\s*:-+:\s*$/))
            html_attrs.push({ align: 'center' });
          else
            html_attrs.push({});
        });
        m[1] = _split_on_unescaped(m[1].replace(/\|\s*$/, ''), '|');
        for (i = 0; i < m[1].length; i++) {
          table[1][1].push([
            'th',
            html_attrs[i] || {}
          ].concat(this.processInline(m[1][i].trim())));
        }
        forEach(m[3].replace(/\|\s*$/gm, '').split('\n'), function (row) {
          var html_row = ['tr'];
          row = _split_on_unescaped(row, '|');
          for (i = 0; i < row.length; i++) {
            html_row.push([
              'td',
              html_attrs[i] || {}
            ].concat(this.processInline(row[i].trim())));
          }
          table[2].push(html_row);
        }, this);
        return [table];
      };
      Markdown.dialects.Maruku.inline['{:'] = function inline_meta(text, matches, out) {
        if (!out.length) {
          return [
            2,
            '{:'
          ];
        }
        var before = out[out.length - 1];
        if (typeof before === 'string') {
          return [
            2,
            '{:'
          ];
        }
        var m = text.match(/^\{:\s*((?:\\\}|[^\}])*)\s*\}/);
        if (!m) {
          return [
            2,
            '{:'
          ];
        }
        var meta = this.dialect.processMetaHash(m[1]), attr = extract_attr(before);
        if (!attr) {
          attr = {};
          before.splice(1, 0, attr);
        }
        for (var k in meta) {
          attr[k] = meta[k];
        }
        return [
          m[0].length,
          ''
        ];
      };
      Markdown.dialects.Maruku.inline.__escape__ = /^\\[\\`\*_{}\[\]()#\+.!\-|:]/;
      Markdown.buildBlockOrder(Markdown.dialects.Maruku.block);
      Markdown.buildInlinePatterns(Markdown.dialects.Maruku.inline);
      var isArray = Array.isArray || function (obj) {
          return Object.prototype.toString.call(obj) == '[object Array]';
        };
      var forEach;
      if (Array.prototype.forEach) {
        forEach = function (arr, cb, thisp) {
          return arr.forEach(cb, thisp);
        };
      } else {
        forEach = function (arr, cb, thisp) {
          for (var i = 0; i < arr.length; i++) {
            cb.call(thisp || arr, arr[i], i, arr);
          }
        };
      }
      var isEmpty = function (obj) {
        for (var key in obj) {
          if (hasOwnProperty.call(obj, key)) {
            return false;
          }
        }
        return true;
      };
      function extract_attr(jsonml) {
        return isArray(jsonml) && jsonml.length > 1 && typeof jsonml[1] === 'object' && !isArray(jsonml[1]) ? jsonml[1] : undefined;
      }
      expose.renderJsonML = function (jsonml, options) {
        options = options || {};
        options.root = options.root || false;
        var content = [];
        if (options.root) {
          content.push(render_tree(jsonml));
        } else {
          jsonml.shift();
          if (jsonml.length && typeof jsonml[0] === 'object' && !(jsonml[0] instanceof Array)) {
            jsonml.shift();
          }
          while (jsonml.length) {
            content.push(render_tree(jsonml.shift()));
          }
        }
        return content.join('\n\n');
      };
      function escapeHTML(text) {
        return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
      }
      function render_tree(jsonml) {
        if (typeof jsonml === 'string') {
          return escapeHTML(jsonml);
        }
        var tag = jsonml.shift(), attributes = {}, content = [];
        if (jsonml.length && typeof jsonml[0] === 'object' && !(jsonml[0] instanceof Array)) {
          attributes = jsonml.shift();
        }
        while (jsonml.length) {
          content.push(render_tree(jsonml.shift()));
        }
        var tag_attrs = '';
        for (var a in attributes) {
          tag_attrs += ' ' + a + '="' + escapeHTML(attributes[a]) + '"';
        }
        if (tag == 'img' || tag == 'br' || tag == 'hr') {
          return '<' + tag + tag_attrs + '/>';
        } else {
          return '<' + tag + tag_attrs + '>' + content.join('') + '</' + tag + '>';
        }
      }
      function convert_tree_to_html(tree, references, options) {
        var i;
        options = options || {};
        var jsonml = tree.slice(0);
        if (typeof options.preprocessTreeNode === 'function') {
          jsonml = options.preprocessTreeNode(jsonml, references);
        }
        var attrs = extract_attr(jsonml);
        if (attrs) {
          jsonml[1] = {};
          for (i in attrs) {
            jsonml[1][i] = attrs[i];
          }
          attrs = jsonml[1];
        }
        if (typeof jsonml === 'string') {
          return jsonml;
        }
        switch (jsonml[0]) {
        case 'header':
          jsonml[0] = 'h' + jsonml[1].level;
          delete jsonml[1].level;
          break;
        case 'bulletlist':
          jsonml[0] = 'ul';
          break;
        case 'numberlist':
          jsonml[0] = 'ol';
          break;
        case 'listitem':
          jsonml[0] = 'li';
          break;
        case 'para':
          jsonml[0] = 'p';
          break;
        case 'markdown':
          jsonml[0] = 'html';
          if (attrs)
            delete attrs.references;
          break;
        case 'code_block':
          jsonml[0] = 'pre';
          i = attrs ? 2 : 1;
          var code = ['code'];
          code.push.apply(code, jsonml.splice(i, jsonml.length - i));
          jsonml[i] = code;
          break;
        case 'inlinecode':
          jsonml[0] = 'code';
          break;
        case 'img':
          jsonml[1].src = jsonml[1].href;
          delete jsonml[1].href;
          break;
        case 'linebreak':
          jsonml[0] = 'br';
          break;
        case 'link':
          jsonml[0] = 'a';
          break;
        case 'link_ref':
          jsonml[0] = 'a';
          var ref = references[attrs.ref];
          if (ref) {
            delete attrs.ref;
            attrs.href = ref.href;
            if (ref.title) {
              attrs.title = ref.title;
            }
            delete attrs.original;
          } else {
            return attrs.original;
          }
          break;
        case 'img_ref':
          jsonml[0] = 'img';
          var ref = references[attrs.ref];
          if (ref) {
            delete attrs.ref;
            attrs.src = ref.href;
            if (ref.title) {
              attrs.title = ref.title;
            }
            delete attrs.original;
          } else {
            return attrs.original;
          }
          break;
        }
        i = 1;
        if (attrs) {
          for (var key in jsonml[1]) {
            i = 2;
            break;
          }
          if (i === 1) {
            jsonml.splice(i, 1);
          }
        }
        for (; i < jsonml.length; ++i) {
          jsonml[i] = convert_tree_to_html(jsonml[i], references, options);
        }
        return jsonml;
      }
      function merge_text_nodes(jsonml) {
        var i = extract_attr(jsonml) ? 2 : 1;
        while (i < jsonml.length) {
          if (typeof jsonml[i] === 'string') {
            if (i + 1 < jsonml.length && typeof jsonml[i + 1] === 'string') {
              jsonml[i] += jsonml.splice(i + 1, 1)[0];
            } else {
              ++i;
            }
          } else {
            merge_text_nodes(jsonml[i]);
            ++i;
          }
        }
      }
    }(function () {
      if (typeof exports === 'undefined') {
        window.markdown = {};
        return window.markdown;
      } else {
        return exports;
      }
    }()));
  });
  require.define('/../node_modules/marked/lib/marked.js', function (module, exports, __dirname, __filename) {
    ;
    (function () {
      var block = {
          newline: /^\n+/,
          code: /^( {4}[^\n]+\n*)+/,
          fences: noop,
          hr: /^( *[-*_]){3,} *(?:\n+|$)/,
          heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
          nptable: noop,
          lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
          blockquote: /^( *>[^\n]+(\n[^\n]+)*\n*)+/,
          list: /^( *)(bull) [\s\S]+?(?:hr|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
          html: /^ *(?:comment|closed|closing) *(?:\n{2,}|\s*$)/,
          def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
          table: noop,
          paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
          text: /^[^\n]+/
        };
      block.bullet = /(?:[*+-]|\d+\.)/;
      block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
      block.item = replace(block.item, 'gm')(/bull/g, block.bullet)();
      block.list = replace(block.list)(/bull/g, block.bullet)('hr', /\n+(?=(?: *[-*_]){3,} *(?:\n+|$))/)();
      block._tag = '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code' + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo' + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|@)\\b';
      block.html = replace(block.html)('comment', /<!--[\s\S]*?-->/)('closed', /<(tag)[\s\S]+?<\/\1>/)('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)(/tag/g, block._tag)();
      block.paragraph = replace(block.paragraph)('hr', block.hr)('heading', block.heading)('lheading', block.lheading)('blockquote', block.blockquote)('tag', '<' + block._tag)('def', block.def)();
      block.normal = merge({}, block);
      block.gfm = merge({}, block.normal, {
        fences: /^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,
        paragraph: /^/
      });
      block.gfm.paragraph = replace(block.paragraph)('(?!', '(?!' + block.gfm.fences.source.replace('\\1', '\\2') + '|' + block.list.source.replace('\\1', '\\3') + '|')();
      block.tables = merge({}, block.gfm, {
        nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
        table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
      });
      function Lexer(options) {
        this.tokens = [];
        this.tokens.links = {};
        this.options = options || marked.defaults;
        this.rules = block.normal;
        if (this.options.gfm) {
          if (this.options.tables) {
            this.rules = block.tables;
          } else {
            this.rules = block.gfm;
          }
        }
      }
      Lexer.rules = block;
      Lexer.lex = function (src, options) {
        var lexer = new Lexer(options);
        return lexer.lex(src);
      };
      Lexer.prototype.lex = function (src) {
        src = src.replace(/\r\n|\r/g, '\n').replace(/\t/g, '    ').replace(/\u00a0/g, ' ').replace(/\u2424/g, '\n');
        return this.token(src, true);
      };
      Lexer.prototype.token = function (src, top) {
        var src = src.replace(/^ +$/gm, ''), next, loose, cap, bull, b, item, space, i, l;
        while (src) {
          if (cap = this.rules.newline.exec(src)) {
            src = src.substring(cap[0].length);
            if (cap[0].length > 1) {
              this.tokens.push({ type: 'space' });
            }
          }
          if (cap = this.rules.code.exec(src)) {
            src = src.substring(cap[0].length);
            cap = cap[0].replace(/^ {4}/gm, '');
            this.tokens.push({
              type: 'code',
              text: !this.options.pedantic ? cap.replace(/\n+$/, '') : cap
            });
            continue;
          }
          if (cap = this.rules.fences.exec(src)) {
            src = src.substring(cap[0].length);
            this.tokens.push({
              type: 'code',
              lang: cap[2],
              text: cap[3]
            });
            continue;
          }
          if (cap = this.rules.heading.exec(src)) {
            src = src.substring(cap[0].length);
            this.tokens.push({
              type: 'heading',
              depth: cap[1].length,
              text: cap[2]
            });
            continue;
          }
          if (top && (cap = this.rules.nptable.exec(src))) {
            src = src.substring(cap[0].length);
            item = {
              type: 'table',
              header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
              align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
              cells: cap[3].replace(/\n$/, '').split('\n')
            };
            for (i = 0; i < item.align.length; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = 'right';
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = 'center';
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = 'left';
              } else {
                item.align[i] = null;
              }
            }
            for (i = 0; i < item.cells.length; i++) {
              item.cells[i] = item.cells[i].split(/ *\| */);
            }
            this.tokens.push(item);
            continue;
          }
          if (cap = this.rules.lheading.exec(src)) {
            src = src.substring(cap[0].length);
            this.tokens.push({
              type: 'heading',
              depth: cap[2] === '=' ? 1 : 2,
              text: cap[1]
            });
            continue;
          }
          if (cap = this.rules.hr.exec(src)) {
            src = src.substring(cap[0].length);
            this.tokens.push({ type: 'hr' });
            continue;
          }
          if (cap = this.rules.blockquote.exec(src)) {
            src = src.substring(cap[0].length);
            this.tokens.push({ type: 'blockquote_start' });
            cap = cap[0].replace(/^ *> ?/gm, '');
            this.token(cap, top);
            this.tokens.push({ type: 'blockquote_end' });
            continue;
          }
          if (cap = this.rules.list.exec(src)) {
            src = src.substring(cap[0].length);
            bull = cap[2];
            this.tokens.push({
              type: 'list_start',
              ordered: bull.length > 1
            });
            cap = cap[0].match(this.rules.item);
            next = false;
            l = cap.length;
            i = 0;
            for (; i < l; i++) {
              item = cap[i];
              space = item.length;
              item = item.replace(/^ *([*+-]|\d+\.) +/, '');
              if (~item.indexOf('\n ')) {
                space -= item.length;
                item = !this.options.pedantic ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '') : item.replace(/^ {1,4}/gm, '');
              }
              if (this.options.smartLists && i !== l - 1) {
                b = block.bullet.exec(cap[i + 1])[0];
                if (bull !== b && !(bull.length > 1 && b.length > 1)) {
                  src = cap.slice(i + 1).join('\n') + src;
                  i = l - 1;
                }
              }
              loose = next || /\n\n(?!\s*$)/.test(item);
              if (i !== l - 1) {
                next = item.charAt(item.length - 1) === '\n';
                if (!loose)
                  loose = next;
              }
              this.tokens.push({ type: loose ? 'loose_item_start' : 'list_item_start' });
              this.token(item, false);
              this.tokens.push({ type: 'list_item_end' });
            }
            this.tokens.push({ type: 'list_end' });
            continue;
          }
          if (cap = this.rules.html.exec(src)) {
            src = src.substring(cap[0].length);
            this.tokens.push({
              type: this.options.sanitize ? 'paragraph' : 'html',
              pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
              text: cap[0]
            });
            continue;
          }
          if (top && (cap = this.rules.def.exec(src))) {
            src = src.substring(cap[0].length);
            this.tokens.links[cap[1].toLowerCase()] = {
              href: cap[2],
              title: cap[3]
            };
            continue;
          }
          if (top && (cap = this.rules.table.exec(src))) {
            src = src.substring(cap[0].length);
            item = {
              type: 'table',
              header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
              align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
              cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
            };
            for (i = 0; i < item.align.length; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = 'right';
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = 'center';
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = 'left';
              } else {
                item.align[i] = null;
              }
            }
            for (i = 0; i < item.cells.length; i++) {
              item.cells[i] = item.cells[i].replace(/^ *\| *| *\| *$/g, '').split(/ *\| */);
            }
            this.tokens.push(item);
            continue;
          }
          if (top && (cap = this.rules.paragraph.exec(src))) {
            src = src.substring(cap[0].length);
            this.tokens.push({
              type: 'paragraph',
              text: cap[1].charAt(cap[1].length - 1) === '\n' ? cap[1].slice(0, -1) : cap[1]
            });
            continue;
          }
          if (cap = this.rules.text.exec(src)) {
            src = src.substring(cap[0].length);
            this.tokens.push({
              type: 'text',
              text: cap[0]
            });
            continue;
          }
          if (src) {
            throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
          }
        }
        return this.tokens;
      };
      var inline = {
          escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
          autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
          url: noop,
          tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
          link: /^!?\[(inside)\]\(href\)/,
          reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
          nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
          strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
          em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
          code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
          br: /^ {2,}\n(?!\s*$)/,
          del: noop,
          text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
        };
      inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
      inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;
      inline.link = replace(inline.link)('inside', inline._inside)('href', inline._href)();
      inline.reflink = replace(inline.reflink)('inside', inline._inside)();
      inline.normal = merge({}, inline);
      inline.pedantic = merge({}, inline.normal, {
        strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
      });
      inline.gfm = merge({}, inline.normal, {
        escape: replace(inline.escape)('])', '~|])')(),
        url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
        del: /^~~(?=\S)([\s\S]*?\S)~~/,
        text: replace(inline.text)(']|', '~]|')('|', '|https?://|')()
      });
      inline.breaks = merge({}, inline.gfm, {
        br: replace(inline.br)('{2,}', '*')(),
        text: replace(inline.gfm.text)('{2,}', '*')()
      });
      function InlineLexer(links, options) {
        this.options = options || marked.defaults;
        this.links = links;
        this.rules = inline.normal;
        if (!this.links) {
          throw new Error('Tokens array requires a `links` property.');
        }
        if (this.options.gfm) {
          if (this.options.breaks) {
            this.rules = inline.breaks;
          } else {
            this.rules = inline.gfm;
          }
        } else if (this.options.pedantic) {
          this.rules = inline.pedantic;
        }
      }
      InlineLexer.rules = inline;
      InlineLexer.output = function (src, links, options) {
        var inline = new InlineLexer(links, options);
        return inline.output(src);
      };
      InlineLexer.prototype.output = function (src) {
        var out = '', link, text, href, cap;
        while (src) {
          if (cap = this.rules.escape.exec(src)) {
            src = src.substring(cap[0].length);
            out += cap[1];
            continue;
          }
          if (cap = this.rules.autolink.exec(src)) {
            src = src.substring(cap[0].length);
            if (cap[2] === '@') {
              text = cap[1].charAt(6) === ':' ? this.mangle(cap[1].substring(7)) : this.mangle(cap[1]);
              href = this.mangle('mailto:') + text;
            } else {
              text = escape(cap[1]);
              href = text;
            }
            out += '<a href="' + href + '">' + text + '</a>';
            continue;
          }
          if (cap = this.rules.url.exec(src)) {
            src = src.substring(cap[0].length);
            text = escape(cap[1]);
            href = text;
            out += '<a href="' + href + '">' + text + '</a>';
            continue;
          }
          if (cap = this.rules.tag.exec(src)) {
            src = src.substring(cap[0].length);
            out += this.options.sanitize ? escape(cap[0]) : cap[0];
            continue;
          }
          if (cap = this.rules.link.exec(src)) {
            src = src.substring(cap[0].length);
            out += this.outputLink(cap, {
              href: cap[2],
              title: cap[3]
            });
            continue;
          }
          if ((cap = this.rules.reflink.exec(src)) || (cap = this.rules.nolink.exec(src))) {
            src = src.substring(cap[0].length);
            link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
            link = this.links[link.toLowerCase()];
            if (!link || !link.href) {
              out += cap[0].charAt(0);
              src = cap[0].substring(1) + src;
              continue;
            }
            out += this.outputLink(cap, link);
            continue;
          }
          if (cap = this.rules.strong.exec(src)) {
            src = src.substring(cap[0].length);
            out += '<strong>' + this.output(cap[2] || cap[1]) + '</strong>';
            continue;
          }
          if (cap = this.rules.em.exec(src)) {
            src = src.substring(cap[0].length);
            out += '<em>' + this.output(cap[2] || cap[1]) + '</em>';
            continue;
          }
          if (cap = this.rules.code.exec(src)) {
            src = src.substring(cap[0].length);
            out += '<code>' + escape(cap[2], true) + '</code>';
            continue;
          }
          if (cap = this.rules.br.exec(src)) {
            src = src.substring(cap[0].length);
            out += '<br>';
            continue;
          }
          if (cap = this.rules.del.exec(src)) {
            src = src.substring(cap[0].length);
            out += '<del>' + this.output(cap[1]) + '</del>';
            continue;
          }
          if (cap = this.rules.text.exec(src)) {
            src = src.substring(cap[0].length);
            out += escape(this.smartypants(cap[0]));
            continue;
          }
          if (src) {
            throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
          }
        }
        return out;
      };
      InlineLexer.prototype.outputLink = function (cap, link) {
        if (cap[0].charAt(0) !== '!') {
          return '<a href="' + escape(link.href) + '"' + (link.title ? ' title="' + escape(link.title) + '"' : '') + '>' + this.output(cap[1]) + '</a>';
        } else {
          return '<img src="' + escape(link.href) + '" alt="' + escape(cap[1]) + '"' + (link.title ? ' title="' + escape(link.title) + '"' : '') + '>';
        }
      };
      InlineLexer.prototype.smartypants = function (text) {
        if (!this.options.smartypants)
          return text;
        return text.replace(/--/g, '\u2014').replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018').replace(/'/g, '\u2019').replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c').replace(/"/g, '\u201d').replace(/\.{3}/g, '\u2026');
      };
      InlineLexer.prototype.mangle = function (text) {
        var out = '', l = text.length, i = 0, ch;
        for (; i < l; i++) {
          ch = text.charCodeAt(i);
          if (Math.random() > .5) {
            ch = 'x' + ch.toString(16);
          }
          out += '&#' + ch + ';';
        }
        return out;
      };
      function Parser(options) {
        this.tokens = [];
        this.token = null;
        this.options = options || marked.defaults;
      }
      Parser.parse = function (src, options) {
        var parser = new Parser(options);
        return parser.parse(src);
      };
      Parser.prototype.parse = function (src) {
        this.inline = new InlineLexer(src.links, this.options);
        this.tokens = src.reverse();
        var out = '';
        while (this.next()) {
          out += this.tok();
        }
        return out;
      };
      Parser.prototype.next = function () {
        return this.token = this.tokens.pop();
      };
      Parser.prototype.peek = function () {
        return this.tokens[this.tokens.length - 1] || 0;
      };
      Parser.prototype.parseText = function () {
        var body = this.token.text;
        while (this.peek().type === 'text') {
          body += '\n' + this.next().text;
        }
        return this.inline.output(body);
      };
      Parser.prototype.tok = function () {
        switch (this.token.type) {
        case 'space': {
            return '';
          }
        case 'hr': {
            return '<hr>\n';
          }
        case 'heading': {
            return '<h' + this.token.depth + ' id="' + this.token.text.toLowerCase().replace(/[^\w]+/g, '-') + '">' + this.inline.output(this.token.text) + '</h' + this.token.depth + '>\n';
          }
        case 'code': {
            if (this.options.highlight) {
              var code = this.options.highlight(this.token.text, this.token.lang);
              if (code != null && code !== this.token.text) {
                this.token.escaped = true;
                this.token.text = code;
              }
            }
            if (!this.token.escaped) {
              this.token.text = escape(this.token.text, true);
            }
            return '<pre><code' + (this.token.lang ? ' class="' + this.options.langPrefix + this.token.lang + '"' : '') + '>' + this.token.text + '</code></pre>\n';
          }
        case 'table': {
            var body = '', heading, i, row, cell, j;
            body += '<thead>\n<tr>\n';
            for (i = 0; i < this.token.header.length; i++) {
              heading = this.inline.output(this.token.header[i]);
              body += '<th';
              if (this.token.align[i]) {
                body += ' style="text-align:' + this.token.align[i] + '"';
              }
              body += '>' + heading + '</th>\n';
            }
            body += '</tr>\n</thead>\n';
            body += '<tbody>\n';
            for (i = 0; i < this.token.cells.length; i++) {
              row = this.token.cells[i];
              body += '<tr>\n';
              for (j = 0; j < row.length; j++) {
                cell = this.inline.output(row[j]);
                body += '<td';
                if (this.token.align[j]) {
                  body += ' style="text-align:' + this.token.align[j] + '"';
                }
                body += '>' + cell + '</td>\n';
              }
              body += '</tr>\n';
            }
            body += '</tbody>\n';
            return '<table>\n' + body + '</table>\n';
          }
        case 'blockquote_start': {
            var body = '';
            while (this.next().type !== 'blockquote_end') {
              body += this.tok();
            }
            return '<blockquote>\n' + body + '</blockquote>\n';
          }
        case 'list_start': {
            var type = this.token.ordered ? 'ol' : 'ul', body = '';
            while (this.next().type !== 'list_end') {
              body += this.tok();
            }
            return '<' + type + '>\n' + body + '</' + type + '>\n';
          }
        case 'list_item_start': {
            var body = '';
            while (this.next().type !== 'list_item_end') {
              body += this.token.type === 'text' ? this.parseText() : this.tok();
            }
            return '<li>' + body + '</li>\n';
          }
        case 'loose_item_start': {
            var body = '';
            while (this.next().type !== 'list_item_end') {
              body += this.tok();
            }
            return '<li>' + body + '</li>\n';
          }
        case 'html': {
            return !this.token.pre && !this.options.pedantic ? this.inline.output(this.token.text) : this.token.text;
          }
        case 'paragraph': {
            return '<p>' + this.inline.output(this.token.text) + '</p>\n';
          }
        case 'text': {
            return '<p>' + this.parseText() + '</p>\n';
          }
        }
      };
      function escape(html, encode) {
        return html.replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
      }
      function replace(regex, opt) {
        regex = regex.source;
        opt = opt || '';
        return function self(name, val) {
          if (!name)
            return new RegExp(regex, opt);
          val = val.source || val;
          val = val.replace(/(^|[^\[])\^/g, '$1');
          regex = regex.replace(name, val);
          return self;
        };
      }
      function noop() {
      }
      noop.exec = noop;
      function merge(obj) {
        var i = 1, target, key;
        for (; i < arguments.length; i++) {
          target = arguments[i];
          for (key in target) {
            if (Object.prototype.hasOwnProperty.call(target, key)) {
              obj[key] = target[key];
            }
          }
        }
        return obj;
      }
      function marked(src, opt, callback) {
        if (callback || typeof opt === 'function') {
          if (!callback) {
            callback = opt;
            opt = null;
          }
          opt = merge({}, marked.defaults, opt || {});
          var highlight = opt.highlight, tokens, pending, i = 0;
          try {
            tokens = Lexer.lex(src, opt);
          } catch (e) {
            return callback(e);
          }
          pending = tokens.length;
          var done = function () {
            var out, err;
            try {
              out = Parser.parse(tokens, opt);
            } catch (e) {
              err = e;
            }
            opt.highlight = highlight;
            return err ? callback(err) : callback(null, out);
          };
          if (!highlight || highlight.length < 3) {
            return done();
          }
          delete opt.highlight;
          if (!pending)
            return done();
          for (; i < tokens.length; i++) {
            (function (token) {
              if (token.type !== 'code') {
                return --pending || done();
              }
              return highlight(token.text, token.lang, function (err, code) {
                if (code == null || code === token.text) {
                  return --pending || done();
                }
                token.text = code;
                token.escaped = true;
                --pending || done();
              });
            }(tokens[i]));
          }
          return;
        }
        try {
          if (opt)
            opt = merge({}, marked.defaults, opt);
          return Parser.parse(Lexer.lex(src, opt), opt);
        } catch (e) {
          e.message += '\nPlease report this to https://github.com/chjj/marked.';
          if ((opt || marked.defaults).silent) {
            return '<p>An error occured:</p><pre>' + escape(e.message + '', true) + '</pre>';
          }
          throw e;
        }
      }
      marked.options = marked.setOptions = function (opt) {
        merge(marked.defaults, opt);
        return marked;
      };
      marked.defaults = {
        gfm: true,
        tables: true,
        breaks: false,
        pedantic: false,
        sanitize: false,
        smartLists: false,
        silent: false,
        highlight: null,
        langPrefix: 'lang-',
        smartypants: false
      };
      marked.Parser = Parser;
      marked.parser = Parser.parse;
      marked.Lexer = Lexer;
      marked.lexer = Lexer.lex;
      marked.InlineLexer = InlineLexer;
      marked.inlineLexer = InlineLexer.output;
      marked.parse = marked;
      if (typeof exports === 'object') {
        module.exports = marked;
      } else if (typeof define === 'function' && define.amd) {
        define(function () {
          return marked;
        });
      } else {
        this.marked = marked;
      }
    }.call(function () {
      return this || (typeof window !== 'undefined' ? window : global);
    }()));
  });
  require.define('/components/kinetic/canvasborder.js', function (module, exports, __dirname, __filename) {
    (function () {
      var CanvasBorder, Stimulus, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      CanvasBorder = function (_super) {
        __extends(CanvasBorder, _super);
        function CanvasBorder() {
          _ref = CanvasBorder.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        CanvasBorder.prototype.defaults = {
          strokeWidth: 5,
          stroke: 'black'
        };
        CanvasBorder.prototype.render = function (context, layer) {
          var border;
          border = new Kinetic.Rect({
            x: 0,
            y: 0,
            width: context.width(),
            height: context.height(),
            strokeWidth: this.spec.strokeWidth,
            stroke: this.spec.stroke
          });
          return layer.add(border);
        };
        return CanvasBorder;
      }(Stimulus);
      exports.CanvasBorder = CanvasBorder;
    }.call(this));
  });
  require.define('/components/kinetic/gridlines.js', function (module, exports, __dirname, __filename) {
    (function () {
      var GridLines, Stimulus, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      GridLines = function (_super) {
        __extends(GridLines, _super);
        function GridLines() {
          _ref = GridLines.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        GridLines.prototype.defaults = {
          x: 0,
          y: 0,
          rows: 3,
          cols: 3,
          stroke: 'black',
          strokeWidth: 2
        };
        GridLines.prototype.render = function (context, layer) {
          var i, line, x, y, _i, _j, _ref1, _ref2, _results;
          for (i = _i = 0, _ref1 = this.spec.rows; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
            y = this.spec.y + i * context.height() / this.spec.rows;
            line = new Kinetic.Line({
              points: [
                this.spec.x,
                y,
                this.spec.x + context.width(),
                y
              ],
              stroke: this.spec.stroke,
              strokeWidth: this.spec.strokeWidth,
              dashArray: this.spec.dashArray
            });
            layer.add(line);
          }
          _results = [];
          for (i = _j = 0, _ref2 = this.spec.cols; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
            x = this.spec.x + i * context.width() / this.spec.cols;
            line = new Kinetic.Line({
              points: [
                x,
                this.spec.y,
                x,
                this.spec.y + context.height()
              ],
              stroke: this.spec.stroke,
              strokeWidth: this.spec.strokeWidth,
              dashArray: this.spec.dashArray
            });
            _results.push(layer.add(line));
          }
          return _results;
        };
        return GridLines;
      }(Stimulus);
      exports.GridLines = GridLines;
    }.call(this));
  });
  require.define('/components/kinetic/rectangle.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Rectangle, Stimulus, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      Rectangle = function (_super) {
        __extends(Rectangle, _super);
        Rectangle.prototype.defaults = {
          x: 0,
          y: 0,
          width: 100,
          height: 100,
          fill: 'red'
        };
        function Rectangle(spec) {
          if (spec == null) {
            spec = {};
          }
          Rectangle.__super__.constructor.call(this, spec, {
            x: 0,
            y: 0,
            width: 100,
            height: 100,
            fill: 'red'
          });
          if (this.spec.layout != null) {
            this.layout = this.spec.layout;
          }
        }
        Rectangle.prototype.render = function (context, layer) {
          var coords, rect;
          coords = this.computeCoordinates(context, this.spec.position);
          rect = new Kinetic.Rect({
            x: coords[0],
            y: coords[1],
            width: this.spec.width,
            height: this.spec.height,
            fill: this.spec.fill,
            stroke: this.spec.stroke,
            strokeWidth: this.spec.strokeWidth
          });
          return layer.add(rect);
        };
        return Rectangle;
      }(Stimulus);
      exports.Rectangle = Rectangle;
    }.call(this));
  });
  require.define('/components/kinetic/startbutton.js', function (module, exports, __dirname, __filename) {
    (function () {
      var StartButton, Stimulus, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      StartButton = function (_super) {
        __extends(StartButton, _super);
        function StartButton() {
          _ref = StartButton.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        StartButton.prototype.defaults = {
          width: 150,
          height: 75
        };
        StartButton.prototype.render = function (context, layer) {
          var button, group, text, xcenter, ycenter;
          xcenter = context.width() / 2;
          ycenter = context.height() / 2;
          group = new Kinetic.Group({ id: this.spec.id });
          text = new Kinetic.Text({
            text: 'Start',
            x: xcenter - this.spec.width / 2,
            y: ycenter - this.spec.height / 2,
            width: this.spec.width,
            height: this.spec.height,
            fontSize: 30,
            fill: 'white',
            fontFamily: 'Arial',
            align: 'center',
            padding: 20
          });
          button = new Kinetic.Rect({
            x: xcenter - this.spec.width / 2,
            y: ycenter - text.getHeight() / 2,
            width: this.spec.width,
            height: text.getHeight(),
            fill: 'black',
            cornerRadius: 10,
            stroke: 'LightSteelBlue',
            strokeWidth: 5
          });
          group.add(button);
          group.add(text);
          return layer.add(group);
        };
        return StartButton;
      }(Stimulus);
      exports.StartButton = StartButton;
    }.call(this));
  });
  require.define('/components/kinetic/text.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Stimulus, Text, layout, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      layout = require('/layout.js', module);
      Text = function (_super) {
        __extends(Text, _super);
        Text.prototype.defaults = {
          content: 'Text',
          x: 5,
          y: 5,
          width: null,
          fill: 'black',
          fontSize: 40,
          fontFamily: 'Arial',
          lineHeight: 2,
          textAlign: 'center',
          position: null
        };
        function Text(spec) {
          if (spec == null) {
            spec = {};
          }
          Text.__super__.constructor.call(this, spec);
          if (_.isArray(this.spec.content)) {
            this.spec.content = this.spec.content.join('\n');
          }
        }
        Text.prototype.render = function (context, layer) {
          var text, xy;
          text = new Kinetic.Text({
            x: this.spec.x,
            y: this.spec.y,
            text: this.spec.content,
            fontSize: this.spec.fontSize,
            fontFamily: this.spec.fontFamily,
            fill: this.spec.fill,
            lineHeight: this.spec.lineHeight,
            width: this.spec.width || context.width(),
            listening: false,
            align: this.spec.textAlign
          });
          if (this.spec.position) {
            xy = layout.positionToCoord(this.spec.position, -text.getWidth() / 2, -text.getHeight() / 2, context.width(), context.height(), [
              this.spec.x,
              this.spec.y
            ]);
            text.setPosition({
              x: xy[0],
              y: xy[1]
            });
          }
          return layer.add(text);
        };
        return Text;
      }(Stimulus);
      exports.Text = Text;
    }.call(this));
  });
  require.define('/components/kinetic/TextInput.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Stimulus, TextInput, utils, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      utils = require('/utils.js', module);
      TextInput = function (_super) {
        __extends(TextInput, _super);
        TextInput.prototype.defaults = {
          x: 100,
          y: 100,
          width: 200,
          height: 40,
          defaultValue: '',
          fill: '#FAF5E6',
          stroke: '#0099FF',
          strokeWidth: 1,
          content: ''
        };
        function TextInput(spec) {
          if (spec == null) {
            spec = {};
          }
          TextInput.__super__.constructor.call(this, spec);
          utils.disableBrowserBack();
        }
        TextInput.prototype.getChar = function (e) {
          if (e.keyCode !== 16) {
            if (e.keyCode >= 65 && e.keyCode <= 90) {
              if (e.shiftKey) {
                return String.fromCharCode(e.keyCode);
              } else {
                return String.fromCharCode(e.keyCode + 32);
              }
            } else if (e.keyCode >= 48 && e.keyCode <= 57) {
              return String.fromCharCode(e.keyCode);
            } else {
              switch (e.keyCode) {
              case 186:
                return ';';
              case 187:
                return '=';
              case 188:
                return ',';
              case 189:
                return '-';
              default:
                return '';
              }
            }
          } else {
            return String.fromCharCode(e.keyCode);
          }
        };
        TextInput.prototype.animateCursor = function (layer, cursor) {
          var flashTime, _this = this;
          flashTime = 0;
          return new Kinetic.Animation(function (frame) {
            if (frame.time > flashTime + 500) {
              flashTime = frame.time;
              if (cursor.getOpacity() === 1) {
                cursor.setOpacity(0);
              } else {
                cursor.setOpacity(1);
              }
              return layer.draw();
            }
          }, layer);
        };
        TextInput.prototype.render = function (context, layer) {
          var cursor, cursorBlink, enterPressed, fsize, group, keyStream, text, textContent, textRect, _this = this;
          textRect = new Kinetic.Rect({
            x: this.spec.x,
            y: this.spec.y,
            width: this.spec.width,
            height: this.spec.height,
            fill: this.spec.fill,
            cornerRadius: 4,
            lineJoin: 'round',
            stroke: this.spec.stroke,
            strokeWidth: this.spec.strokeWidth
          });
          textContent = this.spec.content;
          fsize = .85 * this.spec.height;
          text = new Kinetic.Text({
            text: this.spec.content,
            x: this.spec.x + 2,
            y: this.spec.y - 5,
            height: this.spec.height,
            fontSize: fsize,
            fill: 'black',
            padding: 10,
            align: 'left'
          });
          cursor = new Kinetic.Rect({
            x: text.getX() + text.getWidth() - 7,
            y: this.spec.y + 5,
            width: 1.5,
            height: text.getHeight() - 10,
            fill: 'black'
          });
          enterPressed = false;
          keyStream = context.keydownStream();
          keyStream.takeWhile(function (x) {
            return enterPressed === false && !_this.stopped;
          }).onValue(function (event) {
            var char;
            if (event.keyCode === 13) {
              return enterPressed = true;
            } else if (event.keyCode === 8) {
              textContent = textContent.slice(0, -1);
              text.setText(textContent);
              cursor.setX(text.getX() + text.getWidth() - 7);
              return layer.draw();
            } else if (text.getWidth() > textRect.getWidth()) {
            } else {
              char = _this.getChar(event);
              textContent += char;
              text.setText(textContent);
              cursor.setX(text.getX() + text.getWidth() - 7);
              return layer.draw();
            }
          });
          cursorBlink = this.animateCursor(layer, cursor);
          cursorBlink.start();
          group = new Kinetic.Group({});
          group.add(textRect);
          group.add(cursor);
          group.add(text);
          return layer.add(group);
        };
        return TextInput;
      }(Stimulus);
      exports.TextInput = TextInput;
    }.call(this));
  });
  require.define('/components/kinetic/textInput.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Stimulus, TextInput, utils, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      utils = require('/utils.js', module);
      TextInput = function (_super) {
        __extends(TextInput, _super);
        TextInput.prototype.defaults = {
          x: 100,
          y: 100,
          width: 200,
          height: 40,
          defaultValue: '',
          fill: '#FAF5E6',
          stroke: '#0099FF',
          strokeWidth: 1,
          content: ''
        };
        function TextInput(spec) {
          if (spec == null) {
            spec = {};
          }
          TextInput.__super__.constructor.call(this, spec);
          utils.disableBrowserBack();
        }
        TextInput.prototype.getChar = function (e) {
          if (e.keyCode !== 16) {
            if (e.keyCode >= 65 && e.keyCode <= 90) {
              if (e.shiftKey) {
                return String.fromCharCode(e.keyCode);
              } else {
                return String.fromCharCode(e.keyCode + 32);
              }
            } else if (e.keyCode >= 48 && e.keyCode <= 57) {
              return String.fromCharCode(e.keyCode);
            } else {
              switch (e.keyCode) {
              case 186:
                return ';';
              case 187:
                return '=';
              case 188:
                return ',';
              case 189:
                return '-';
              default:
                return '';
              }
            }
          } else {
            return String.fromCharCode(e.keyCode);
          }
        };
        TextInput.prototype.animateCursor = function (layer, cursor) {
          var flashTime, _this = this;
          flashTime = 0;
          return new Kinetic.Animation(function (frame) {
            if (frame.time > flashTime + 500) {
              flashTime = frame.time;
              if (cursor.getOpacity() === 1) {
                cursor.setOpacity(0);
              } else {
                cursor.setOpacity(1);
              }
              return layer.draw();
            }
          }, layer);
        };
        TextInput.prototype.render = function (context, layer) {
          var cursor, cursorBlink, enterPressed, fsize, group, keyStream, text, textContent, textRect, _this = this;
          textRect = new Kinetic.Rect({
            x: this.spec.x,
            y: this.spec.y,
            width: this.spec.width,
            height: this.spec.height,
            fill: this.spec.fill,
            cornerRadius: 4,
            lineJoin: 'round',
            stroke: this.spec.stroke,
            strokeWidth: this.spec.strokeWidth
          });
          textContent = this.spec.content;
          fsize = .85 * this.spec.height;
          text = new Kinetic.Text({
            text: this.spec.content,
            x: this.spec.x + 2,
            y: this.spec.y - 5,
            height: this.spec.height,
            fontSize: fsize,
            fill: 'black',
            padding: 10,
            align: 'left'
          });
          cursor = new Kinetic.Rect({
            x: text.getX() + text.getWidth() - 7,
            y: this.spec.y + 5,
            width: 1.5,
            height: text.getHeight() - 10,
            fill: 'black'
          });
          enterPressed = false;
          keyStream = context.keydownStream();
          keyStream.takeWhile(function (x) {
            return enterPressed === false && !_this.stopped;
          }).onValue(function (event) {
            var char;
            if (event.keyCode === 13) {
              return enterPressed = true;
            } else if (event.keyCode === 8) {
              textContent = textContent.slice(0, -1);
              text.setText(textContent);
              cursor.setX(text.getX() + text.getWidth() - 7);
              return layer.draw();
            } else if (text.getWidth() > textRect.getWidth()) {
            } else {
              char = _this.getChar(event);
              textContent += char;
              text.setText(textContent);
              cursor.setX(text.getX() + text.getWidth() - 7);
              return layer.draw();
            }
          });
          cursorBlink = this.animateCursor(layer, cursor);
          cursorBlink.start();
          group = new Kinetic.Group({});
          group.add(textRect);
          group.add(cursor);
          group.add(text);
          return layer.add(group);
        };
        return TextInput;
      }(Stimulus);
      exports.TextInput = TextInput;
    }.call(this));
  });
  require.define('/components/kinetic/textinput.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Stimulus, TextInput, utils, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      utils = require('/utils.js', module);
      TextInput = function (_super) {
        __extends(TextInput, _super);
        TextInput.prototype.defaults = {
          x: 100,
          y: 100,
          width: 200,
          height: 40,
          defaultValue: '',
          fill: '#FAF5E6',
          stroke: '#0099FF',
          strokeWidth: 1,
          content: ''
        };
        function TextInput(spec) {
          if (spec == null) {
            spec = {};
          }
          TextInput.__super__.constructor.call(this, spec);
          utils.disableBrowserBack();
        }
        TextInput.prototype.getChar = function (e) {
          if (e.keyCode !== 16) {
            if (e.keyCode >= 65 && e.keyCode <= 90) {
              if (e.shiftKey) {
                return String.fromCharCode(e.keyCode);
              } else {
                return String.fromCharCode(e.keyCode + 32);
              }
            } else if (e.keyCode >= 48 && e.keyCode <= 57) {
              return String.fromCharCode(e.keyCode);
            } else {
              switch (e.keyCode) {
              case 186:
                return ';';
              case 187:
                return '=';
              case 188:
                return ',';
              case 189:
                return '-';
              default:
                return '';
              }
            }
          } else {
            return String.fromCharCode(e.keyCode);
          }
        };
        TextInput.prototype.animateCursor = function (layer, cursor) {
          var flashTime, _this = this;
          flashTime = 0;
          return new Kinetic.Animation(function (frame) {
            if (frame.time > flashTime + 500) {
              flashTime = frame.time;
              if (cursor.getOpacity() === 1) {
                cursor.setOpacity(0);
              } else {
                cursor.setOpacity(1);
              }
              return layer.draw();
            }
          }, layer);
        };
        TextInput.prototype.render = function (context, layer) {
          var cursor, cursorBlink, enterPressed, fsize, group, keyStream, text, textContent, textRect, _this = this;
          textRect = new Kinetic.Rect({
            x: this.spec.x,
            y: this.spec.y,
            width: this.spec.width,
            height: this.spec.height,
            fill: this.spec.fill,
            cornerRadius: 4,
            lineJoin: 'round',
            stroke: this.spec.stroke,
            strokeWidth: this.spec.strokeWidth
          });
          textContent = this.spec.content;
          fsize = .85 * this.spec.height;
          text = new Kinetic.Text({
            text: this.spec.content,
            x: this.spec.x + 2,
            y: this.spec.y - 5,
            height: this.spec.height,
            fontSize: fsize,
            fill: 'black',
            padding: 10,
            align: 'left'
          });
          cursor = new Kinetic.Rect({
            x: text.getX() + text.getWidth() - 7,
            y: this.spec.y + 5,
            width: 1.5,
            height: text.getHeight() - 10,
            fill: 'black'
          });
          enterPressed = false;
          keyStream = context.keydownStream();
          keyStream.takeWhile(function (x) {
            return enterPressed === false && !_this.stopped;
          }).onValue(function (event) {
            var char;
            if (event.keyCode === 13) {
              return enterPressed = true;
            } else if (event.keyCode === 8) {
              textContent = textContent.slice(0, -1);
              text.setText(textContent);
              cursor.setX(text.getX() + text.getWidth() - 7);
              return layer.draw();
            } else if (text.getWidth() > textRect.getWidth()) {
            } else {
              char = _this.getChar(event);
              textContent += char;
              text.setText(textContent);
              cursor.setX(text.getX() + text.getWidth() - 7);
              return layer.draw();
            }
          });
          cursorBlink = this.animateCursor(layer, cursor);
          cursorBlink.start();
          group = new Kinetic.Group({});
          group.add(textRect);
          group.add(cursor);
          group.add(text);
          return layer.add(group);
        };
        return TextInput;
      }(Stimulus);
      exports.TextInput = TextInput;
    }.call(this));
  });
  require.define('/components/kinetic/circle.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Circle, Stimulus, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      Circle = function (_super) {
        __extends(Circle, _super);
        function Circle() {
          _ref = Circle.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        Circle.prototype.defaults = {
          x: 100,
          y: 100,
          radius: 50,
          fill: 'red',
          opacity: 1
        };
        Circle.prototype.render = function (context, layer) {
          var circ;
          circ = new Kinetic.Circle({
            x: this.spec.x,
            y: this.spec.y,
            radius: this.spec.radius,
            fill: this.spec.fill,
            stroke: this.spec.stroke,
            strokeWidth: this.spec.strokeWidth,
            opacity: this.spec.opacity
          });
          return layer.add(circ);
        };
        return Circle;
      }(Stimulus);
      exports.Circle = Circle;
    }.call(this));
  });
  require.define('/components/kinetic/fixationcross.js', function (module, exports, __dirname, __filename) {
    (function () {
      var FixationCross, Stimulus, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      FixationCross = function (_super) {
        __extends(FixationCross, _super);
        function FixationCross() {
          _ref = FixationCross.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        FixationCross.prototype.defaults = {
          strokeWidth: 8,
          length: 150,
          fill: 'black'
        };
        FixationCross.prototype.render = function (context, layer) {
          var group, horz, vert, x, y;
          x = context.width() / 2;
          y = context.height() / 2;
          horz = new Kinetic.Rect({
            x: x - this.spec.length / 2,
            y: y,
            width: this.spec.length,
            height: this.spec.strokeWidth,
            fill: this.spec.fill
          });
          vert = new Kinetic.Rect({
            x: x - this.spec.strokeWidth / 2,
            y: y - this.spec.length / 2 + this.spec.strokeWidth / 2,
            width: this.spec.strokeWidth,
            height: this.spec.length,
            fill: this.spec.fill
          });
          group = new Kinetic.Group;
          group.add(horz);
          group.add(vert);
          return layer.add(group);
        };
        return FixationCross;
      }(Stimulus);
      exports.FixationCross = FixationCross;
    }.call(this));
  });
  require.define('/components/html/html.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Html, HtmlResponse, HtmlStimulus, Response, Stimulus, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      Response = require('/stimresp.js', module).Response;
      HtmlStimulus = function (_super) {
        __extends(HtmlStimulus, _super);
        HtmlStimulus.prototype.tag = 'div';
        HtmlStimulus.prototype.div = function () {
          return $(document.createElement('div'));
        };
        function HtmlStimulus(spec) {
          HtmlStimulus.__super__.constructor.call(this, spec);
          this.el = document.createElement(this.tag);
          this.el = $(this.el);
        }
        HtmlStimulus.prototype.positionElement = function (el) {
          if (this.spec.x != null && this.spec.y != null) {
            return el.css({
              position: 'absolute',
              left: this.spec.x,
              top: this.spec.y
            });
          }
        };
        HtmlStimulus.prototype.centerElement = function (el) {
          return el.css({
            margin: '0 auto',
            position: 'absolute',
            left: '50%',
            top: '50%'
          });
        };
        HtmlStimulus.prototype.render = function (context, layer) {
          return context.appendHtml(this.el);
        };
        return HtmlStimulus;
      }(Stimulus);
      HtmlResponse = function (_super) {
        __extends(HtmlResponse, _super);
        function HtmlResponse() {
          _ref = HtmlResponse.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        HtmlResponse.include(Response);
        return HtmlResponse;
      }(HtmlStimulus);
      exports.HtmlStimulus = HtmlStimulus;
      exports.HtmlResponse = HtmlResponse;
      Html = {};
      Html.HtmlButton = require('/components/html/htmlbutton.js', module).HtmlButton;
      Html.HtmlLink = require('/components/html/htmllink.js', module).HtmlLink;
      Html.HtmlIcon = require('/components/html/htmlicon.js', module).HtmlIcon;
      Html.Instructions = require('/components/html/instructions.js', module).Instructions;
      Html.Markdown = require('/components/html/markdown.js', module).Markdown;
      Html.Message = require('/components/html/message.js', module).Message;
      Html.Page = require('/components/html/page.js', module).Page;
      exports.Html = Html;
    }.call(this));
  });
  require.define('/components/html/htmlbutton.js', function (module, exports, __dirname, __filename) {
    (function () {
      var HtmlButton, html, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      html = require('/components/html/html.js', module);
      HtmlButton = function (_super) {
        __extends(HtmlButton, _super);
        HtmlButton.prototype.defaults = {
          label: 'Next',
          'class': ''
        };
        function HtmlButton(spec) {
          if (spec == null) {
            spec = {};
          }
          HtmlButton.__super__.constructor.call(this, spec);
          this.el.addClass('ui button');
          this.el.addClass(this.spec['class']);
          this.el.append(this.spec.label);
          this.positionElement(this.el);
        }
        return HtmlButton;
      }(html.HtmlStimulus);
      exports.HtmlButton = HtmlButton;
    }.call(this));
  });
  require.define('/module.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Module, moduleKeywords, __indexOf = [].indexOf || function (item) {
          for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
              return i;
          }
          return -1;
        };
      moduleKeywords = [
        'included',
        'extended'
      ];
      Module = function () {
        Module.include = function (obj) {
          var key, value, _ref;
          if (!obj) {
            throw new Error('include(obj) requires obj');
          }
          for (key in obj) {
            value = obj[key];
            if (__indexOf.call(moduleKeywords, key) < 0) {
              this.prototype[key] = value;
            }
          }
          if ((_ref = obj.included) != null) {
            _ref.apply(this);
          }
          return this;
        };
        Module.extend = function (obj) {
          var key, value, _ref;
          if (!obj) {
            throw new Error('extend(obj) requires obj');
          }
          for (key in obj) {
            value = obj[key];
            if (__indexOf.call(moduleKeywords, key) < 0) {
              this[key] = value;
            }
          }
          if ((_ref = obj.extended) != null) {
            _ref.apply(this);
          }
          return this;
        };
        Module.proxy = function (func) {
          var _this = this;
          return function () {
            return func.apply(_this, arguments);
          };
        };
        Module.prototype.proxy = function (func) {
          var _this = this;
          return function () {
            return func.apply(_this, arguments);
          };
        };
        function Module() {
          if (typeof this.init === 'function') {
            this.init.apply(this, arguments);
          }
        }
        return Module;
      }();
      exports.Module = Module;
    }.call(this));
  });
  require.define('/components/html/htmllink.js', function (module, exports, __dirname, __filename) {
    (function () {
      var HtmlLink, html, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      html = require('/components/html/html.js', module);
      HtmlLink = function (_super) {
        __extends(HtmlLink, _super);
        HtmlLink.prototype.defaults = { label: 'link' };
        function HtmlLink(spec) {
          if (spec == null) {
            spec = {};
          }
          HtmlLink.__super__.constructor.call(this, spec);
          this.html = $("<a href='#'>" + this.spec.label + '</a>');
          this.el.append(this.html);
          this.positionElement(this.el);
        }
        return HtmlLink;
      }(html.HtmlStimulus);
      exports.HtmlLink = HtmlLink;
    }.call(this));
  });
  require.define('/components/html/htmlicon.js', function (module, exports, __dirname, __filename) {
    (function () {
      var HtmlIcon, html, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      html = require('/components/html/html.js', module);
      HtmlIcon = function (_super) {
        __extends(HtmlIcon, _super);
        HtmlIcon.prototype.defaults = {
          glyph: 'plane',
          size: 'massive'
        };
        function HtmlIcon(spec) {
          if (spec == null) {
            spec = {};
          }
          HtmlIcon.__super__.constructor.call(this, spec);
          this.html = $('<i></i>');
          this.html.addClass(this.spec.glyph + ' ' + this.spec.size + ' icon');
          this.el.append(this.html);
          this.positionElement(this.el);
        }
        return HtmlIcon;
      }(html.HtmlStimulus);
      exports.HtmlIcon = HtmlIcon;
    }.call(this));
  });
  require.define('/components/html/instructions.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Instructions, Markdown, Q, html, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      html = require('/components/html/html.js', module);
      Q = require('/../node_modules/q/q.js', module);
      Markdown = require('/components/html/markdown.js', module).Markdown;
      Instructions = function (_super) {
        __extends(Instructions, _super);
        function Instructions(spec) {
          var content, div, i, itm, key, md, type, value;
          if (spec == null) {
            spec = {};
          }
          Instructions.__super__.constructor.call(this, spec);
          this.pages = function () {
            var _ref, _results;
            _ref = this.spec.pages;
            _results = [];
            for (key in _ref) {
              value = _ref[key];
              type = _.keys(value)[0];
              content = _.values(value)[0];
              md = new Markdown(content);
              div = this.div();
              div.addClass('ui stacked segment').append(md.el);
              _results.push(div);
            }
            return _results;
          }.call(this);
          this.menu = this.div();
          this.menu.addClass('ui borderless pagination menu');
          this.back = $('<a class="item">\n  <i class="icon left arrow"></i>  Previous\n </a>').attr('id', 'instructions_back');
          this.next = $('<a class="item">\nNext <i class="icon right arrow"></i>\n</a>').attr('id', 'instructions_next');
          this.menu.append(this.back).append('\n');
          this.items = function () {
            var _i, _ref, _results;
            _results = [];
            for (i = _i = 1, _ref = this.pages.length; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
              itm = $('<a class="item">' + i + '</a>');
              this.menu.append(itm).append('\n');
              _results.push(itm);
            }
            return _results;
          }.call(this);
          this.items[0].addClass('active');
          this.menu.append(this.next).css('position', 'absolute').css('right', '15px');
          this.currentPage = 0;
          this.el.append(this.pages[this.currentPage]);
          this.el.append(this.menu);
        }
        Instructions.prototype.activate = function (context) {
          this.deferred = Q.defer();
          return this.deferred.promise;
        };
        Instructions.prototype.updateEl = function (currentPage) {
          this.el.empty();
          this.el.append(this.pages[this.currentPage]);
          return this.el.append(this.menu);
        };
        Instructions.prototype.render = function (context, layer) {
          var _this = this;
          this.next.click(function (e) {
            if (_this.currentPage < _this.pages.length - 1) {
              _this.items[_this.currentPage].removeClass('active');
              _this.currentPage += 1;
              _this.items[_this.currentPage].addClass('active');
              _this.updateEl(_this.currentPage);
              return _this.render(context);
            } else {
              return _this.deferred.resolve(0);
            }
          });
          this.back.click(function (e) {
            console.log('back click!');
            if (_this.currentPage > 0) {
              _this.items[_this.currentPage].removeClass('active');
              _this.currentPage -= 1;
              _this.items[_this.currentPage].addClass('active');
              _this.updateEl(_this.currentPage);
              return _this.render(context);
            }
          });
          if (this.currentPage > 0) {
            this.back.removeClass('disabled');
          }
          $(this.pages[this.currentPage]).css({ 'min-height': context.height() - 50 });
          return context.appendHtml(this.el);
        };
        return Instructions;
      }(html.HtmlResponse);
      exports.Instructions = Instructions;
    }.call(this));
  });
  require.define('/components/html/markdown.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Markdown, html, marked, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      html = require('/components/html/html.js', module);
      marked = require('/../node_modules/marked/lib/marked.js', module);
      Markdown = function (_super) {
        __extends(Markdown, _super);
        function Markdown(spec) {
          var _this = this;
          if (spec == null) {
            spec = {};
          }
          Markdown.__super__.constructor.call(this, spec);
          if (_.isString(spec)) {
            this.spec = {};
            this.spec.content = spec;
          }
          if (this.spec.url != null) {
            $.ajax({
              url: this.spec.url,
              success: function (result) {
                _this.spec.content = result;
                return _this.el.append(marked(_this.spec.content));
              },
              error: function (result) {
                return console.log('ajax failure', result);
              }
            });
          } else {
            this.el.append($(marked(this.spec.content)));
          }
          this.el.addClass('markdown');
        }
        return Markdown;
      }(html.HtmlStimulus);
      exports.Markdown = Markdown;
    }.call(this));
  });
  require.define('/components/html/message.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Message, html, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      html = require('/components/html/html.js', module);
      Message = function (_super) {
        __extends(Message, _super);
        Message.prototype.defaults = {
          title: 'Message!',
          content: 'your content here',
          color: '',
          size: 'large'
        };
        function Message(spec) {
          if (spec == null) {
            spec = {};
          }
          Message.__super__.constructor.call(this, spec);
          this.el.addClass(this.messageClass());
          this.title = $('<div>' + this.spec.title + '</div>').addClass('header');
          this.content = $('<p>' + this.spec.content + '</p>');
          this.el.append(this.title);
          this.el.append(this.content);
        }
        Message.prototype.messageClass = function () {
          return 'ui message ' + this.spec.color + ' ' + this.spec.size;
        };
        return Message;
      }(html.HtmlStimulus);
      exports.Message = Message;
    }.call(this));
  });
  require.define('/components/html/page.js', function (module, exports, __dirname, __filename) {
    (function () {
      var HtmlStimulus, Page, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      HtmlStimulus = require('/components/html/html.js', module).HtmlStimulus;
      Page = function (_super) {
        __extends(Page, _super);
        Page.prototype.defaults = { html: '<p>HTML Page</p>' };
        function Page(spec) {
          if (spec == null) {
            spec = {};
          }
          Page.__super__.constructor.call(this, spec);
          this.el.append(this.spec.html);
        }
        Page.prototype.render = function (context, layer) {
          return context.appendHtml(this.el);
        };
        return Page;
      }(HtmlStimulus);
      exports.Page = Page;
    }.call(this));
  });
  require.define('/components/canvas/canvas.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Canvas;
      Canvas = {};
      Canvas.Arrow = require('/components/canvas/arrow.js', module).Arrow;
      Canvas.Background = require('/components/canvas/background.js', module).Background;
      Canvas.Blank = require('/components/canvas/blank.js', module).Blank;
      Canvas.Circle = require('/components/canvas/circle.js', module).Circle;
      Canvas.Clear = require('/components/canvas/clear.js', module).Clear;
      Canvas.FixationCross = require('/components/canvas/fixationcross.js', module).FixationCross;
      Canvas.CanvasBorder = require('/components/canvas/canvasborder.js', module).CanvasBorder;
      Canvas.GridLines = require('/components/canvas/gridlines.js', module).GridLines;
      Canvas.Picture = require('/components/canvas/picture.js', module).Picture;
      Canvas.Rectangle = require('/components/canvas/rectangle.js', module).Rectangle;
      Canvas.StartButton = require('/components/canvas/startbutton.js', module).StartButton;
      Canvas.Text = require('/components/canvas/text.js', module).Text;
      Canvas.TextInput = require('/components/canvas/textinput.js', module).TextInput;
      exports.Canvas = Canvas;
    }.call(this));
  });
  require.define('/components/canvas/textinput.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Stimulus, TextInput, utils, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      utils = require('/utils.js', module);
      TextInput = function (_super) {
        __extends(TextInput, _super);
        TextInput.prototype.defaults = {
          x: 100,
          y: 100,
          width: 200,
          height: 40,
          defaultValue: '',
          fill: '#FAF5E6',
          stroke: '#0099FF',
          strokeWidth: 1,
          content: ''
        };
        function TextInput(spec) {
          if (spec == null) {
            spec = {};
          }
          TextInput.__super__.constructor.call(this, spec);
          utils.disableBrowserBack();
        }
        TextInput.prototype.getChar = function (e) {
          if (e.keyCode !== 16) {
            if (e.keyCode >= 65 && e.keyCode <= 90) {
              if (e.shiftKey) {
                return String.fromCharCode(e.keyCode);
              } else {
                return String.fromCharCode(e.keyCode + 32);
              }
            } else if (e.keyCode >= 48 && e.keyCode <= 57) {
              return String.fromCharCode(e.keyCode);
            } else {
              switch (e.keyCode) {
              case 186:
                return ';';
              case 187:
                return '=';
              case 188:
                return ',';
              case 189:
                return '-';
              default:
                return '';
              }
            }
          } else {
            return String.fromCharCode(e.keyCode);
          }
        };
        TextInput.prototype.animateCursor = function (layer, cursor) {
          var flashTime, _this = this;
          flashTime = 0;
          return new Kinetic.Animation(function (frame) {
            if (frame.time > flashTime + 500) {
              flashTime = frame.time;
              if (cursor.getOpacity() === 1) {
                cursor.setOpacity(0);
              } else {
                cursor.setOpacity(1);
              }
              return layer.draw();
            }
          }, layer);
        };
        TextInput.prototype.render = function (context, layer) {
          var cursor, cursorBlink, enterPressed, fsize, group, keyStream, text, textContent, textRect, _this = this;
          textRect = new Kinetic.Rect({
            x: this.spec.x,
            y: this.spec.y,
            width: this.spec.width,
            height: this.spec.height,
            fill: this.spec.fill,
            cornerRadius: 4,
            lineJoin: 'round',
            stroke: this.spec.stroke,
            strokeWidth: this.spec.strokeWidth
          });
          textContent = this.spec.content;
          fsize = .85 * this.spec.height;
          text = new Kinetic.Text({
            text: this.spec.content,
            x: this.spec.x + 2,
            y: this.spec.y - 5,
            height: this.spec.height,
            fontSize: fsize,
            fill: 'black',
            padding: 10,
            align: 'left'
          });
          cursor = new Kinetic.Rect({
            x: text.getX() + text.getWidth() - 7,
            y: this.spec.y + 5,
            width: 1.5,
            height: text.getHeight() - 10,
            fill: 'black'
          });
          enterPressed = false;
          keyStream = context.keydownStream();
          keyStream.takeWhile(function (x) {
            return enterPressed === false && !_this.stopped;
          }).onValue(function (event) {
            var char;
            if (event.keyCode === 13) {
              return enterPressed = true;
            } else if (event.keyCode === 8) {
              textContent = textContent.slice(0, -1);
              text.setText(textContent);
              cursor.setX(text.getX() + text.getWidth() - 7);
              return layer.draw();
            } else if (text.getWidth() > textRect.getWidth()) {
            } else {
              char = _this.getChar(event);
              textContent += char;
              text.setText(textContent);
              cursor.setX(text.getX() + text.getWidth() - 7);
              return layer.draw();
            }
          });
          cursorBlink = this.animateCursor(layer, cursor);
          cursorBlink.start();
          group = new Kinetic.Group({});
          group.add(textRect);
          group.add(cursor);
          group.add(text);
          return layer.add(group);
        };
        return TextInput;
      }(Stimulus);
      exports.TextInput = TextInput;
    }.call(this));
  });
  require.define('/components/canvas/text.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Stimulus, Text, layout, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      layout = require('/layout.js', module);
      Text = function (_super) {
        __extends(Text, _super);
        Text.prototype.defaults = {
          content: 'Text',
          x: 5,
          y: 5,
          width: null,
          fill: 'black',
          fontSize: 40,
          fontFamily: 'Arial',
          lineHeight: 2,
          textAlign: 'center',
          position: null
        };
        function Text(spec) {
          if (spec == null) {
            spec = {};
          }
          Text.__super__.constructor.call(this, spec);
          if (_.isArray(this.spec.content)) {
            this.spec.content = this.spec.content.join('\n');
          }
        }
        Text.prototype.render = function (context, layer) {
          var text, xy;
          text = new Kinetic.Text({
            x: this.spec.x,
            y: this.spec.y,
            text: this.spec.content,
            fontSize: this.spec.fontSize,
            fontFamily: this.spec.fontFamily,
            fill: this.spec.fill,
            lineHeight: this.spec.lineHeight,
            width: this.spec.width || context.width(),
            listening: false,
            align: this.spec.textAlign
          });
          if (this.spec.position) {
            xy = layout.positionToCoord(this.spec.position, -text.getWidth() / 2, -text.getHeight() / 2, context.width(), context.height(), [
              this.spec.x,
              this.spec.y
            ]);
            text.setPosition({
              x: xy[0],
              y: xy[1]
            });
          }
          return layer.add(text);
        };
        return Text;
      }(Stimulus);
      exports.Text = Text;
    }.call(this));
  });
  require.define('/components/canvas/startbutton.js', function (module, exports, __dirname, __filename) {
    (function () {
      var StartButton, Stimulus, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      StartButton = function (_super) {
        __extends(StartButton, _super);
        function StartButton() {
          _ref = StartButton.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        StartButton.prototype.defaults = {
          width: 150,
          height: 75
        };
        StartButton.prototype.render = function (context, layer) {
          var button, group, text, xcenter, ycenter;
          xcenter = context.width() / 2;
          ycenter = context.height() / 2;
          group = new Kinetic.Group({ id: this.spec.id });
          text = new Kinetic.Text({
            text: 'Start',
            x: xcenter - this.spec.width / 2,
            y: ycenter - this.spec.height / 2,
            width: this.spec.width,
            height: this.spec.height,
            fontSize: 30,
            fill: 'white',
            fontFamily: 'Arial',
            align: 'center',
            padding: 20
          });
          button = new Kinetic.Rect({
            x: xcenter - this.spec.width / 2,
            y: ycenter - text.getHeight() / 2,
            width: this.spec.width,
            height: text.getHeight(),
            fill: 'black',
            cornerRadius: 10,
            stroke: 'LightSteelBlue',
            strokeWidth: 5
          });
          group.add(button);
          group.add(text);
          return layer.add(group);
        };
        return StartButton;
      }(Stimulus);
      exports.StartButton = StartButton;
    }.call(this));
  });
  require.define('/components/canvas/rectangle.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Rectangle, Stimulus, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      Rectangle = function (_super) {
        __extends(Rectangle, _super);
        Rectangle.prototype.defaults = {
          x: 0,
          y: 0,
          width: 100,
          height: 100,
          fill: 'red'
        };
        function Rectangle(spec) {
          if (spec == null) {
            spec = {};
          }
          Rectangle.__super__.constructor.call(this, spec, {
            x: 0,
            y: 0,
            width: 100,
            height: 100,
            fill: 'red'
          });
          if (this.spec.layout != null) {
            this.layout = this.spec.layout;
          }
        }
        Rectangle.prototype.render = function (context, layer) {
          var coords, rect;
          coords = this.computeCoordinates(context, this.spec.position);
          rect = new Kinetic.Rect({
            x: coords[0],
            y: coords[1],
            width: this.spec.width,
            height: this.spec.height,
            fill: this.spec.fill,
            stroke: this.spec.stroke,
            strokeWidth: this.spec.strokeWidth
          });
          return layer.add(rect);
        };
        return Rectangle;
      }(Stimulus);
      exports.Rectangle = Rectangle;
    }.call(this));
  });
  require.define('/components/canvas/picture.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Picture, Stimulus, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      Picture = function (_super) {
        __extends(Picture, _super);
        Picture.prototype.defaults = {
          url: 'http://www.html5canvastutorials.com/demos/assets/yoda.jpg',
          x: 0,
          y: 0
        };
        function Picture(spec) {
          var _this = this;
          if (spec == null) {
            spec = {};
          }
          Picture.__super__.constructor.call(this, spec);
          this.imageObj = new Image;
          this.image = null;
          this.imageObj.onload = function () {
            return _this.image = new Kinetic.Image({
              x: _this.spec.x,
              y: _this.spec.y,
              image: _this.imageObj,
              width: _this.spec.width || _this.imageObj.width,
              height: _this.spec.height || _this.imageObj.height
            });
          };
          this.imageObj.src = this.spec.url;
        }
        Picture.prototype.render = function (context, layer) {
          return layer.add(this.image);
        };
        return Picture;
      }(Stimulus);
      exports.Picture = Picture;
    }.call(this));
  });
  require.define('/components/canvas/gridlines.js', function (module, exports, __dirname, __filename) {
    (function () {
      var GridLines, Stimulus, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      GridLines = function (_super) {
        __extends(GridLines, _super);
        function GridLines() {
          _ref = GridLines.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        GridLines.prototype.defaults = {
          x: 0,
          y: 0,
          rows: 3,
          cols: 3,
          stroke: 'black',
          strokeWidth: 2
        };
        GridLines.prototype.render = function (context, layer) {
          var i, line, x, y, _i, _j, _ref1, _ref2, _results;
          for (i = _i = 0, _ref1 = this.spec.rows; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
            y = this.spec.y + i * context.height() / this.spec.rows;
            line = new Kinetic.Line({
              points: [
                this.spec.x,
                y,
                this.spec.x + context.width(),
                y
              ],
              stroke: this.spec.stroke,
              strokeWidth: this.spec.strokeWidth,
              dashArray: this.spec.dashArray
            });
            layer.add(line);
          }
          _results = [];
          for (i = _j = 0, _ref2 = this.spec.cols; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
            x = this.spec.x + i * context.width() / this.spec.cols;
            line = new Kinetic.Line({
              points: [
                x,
                this.spec.y,
                x,
                this.spec.y + context.height()
              ],
              stroke: this.spec.stroke,
              strokeWidth: this.spec.strokeWidth,
              dashArray: this.spec.dashArray
            });
            _results.push(layer.add(line));
          }
          return _results;
        };
        return GridLines;
      }(Stimulus);
      exports.GridLines = GridLines;
    }.call(this));
  });
  require.define('/components/canvas/canvasborder.js', function (module, exports, __dirname, __filename) {
    (function () {
      var CanvasBorder, Stimulus, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      CanvasBorder = function (_super) {
        __extends(CanvasBorder, _super);
        function CanvasBorder() {
          _ref = CanvasBorder.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        CanvasBorder.prototype.defaults = {
          strokeWidth: 5,
          stroke: 'black'
        };
        CanvasBorder.prototype.render = function (context, layer) {
          var border;
          border = new Kinetic.Rect({
            x: 0,
            y: 0,
            width: context.width(),
            height: context.height(),
            strokeWidth: this.spec.strokeWidth,
            stroke: this.spec.stroke
          });
          return layer.add(border);
        };
        return CanvasBorder;
      }(Stimulus);
      exports.CanvasBorder = CanvasBorder;
    }.call(this));
  });
  require.define('/components/canvas/fixationcross.js', function (module, exports, __dirname, __filename) {
    (function () {
      var FixationCross, Stimulus, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      FixationCross = function (_super) {
        __extends(FixationCross, _super);
        function FixationCross() {
          _ref = FixationCross.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        FixationCross.prototype.defaults = {
          strokeWidth: 8,
          length: 150,
          fill: 'black'
        };
        FixationCross.prototype.render = function (context, layer) {
          var group, horz, vert, x, y;
          x = context.width() / 2;
          y = context.height() / 2;
          horz = new Kinetic.Rect({
            x: x - this.spec.length / 2,
            y: y,
            width: this.spec.length,
            height: this.spec.strokeWidth,
            fill: this.spec.fill
          });
          vert = new Kinetic.Rect({
            x: x - this.spec.strokeWidth / 2,
            y: y - this.spec.length / 2 + this.spec.strokeWidth / 2,
            width: this.spec.strokeWidth,
            height: this.spec.length,
            fill: this.spec.fill
          });
          group = new Kinetic.Group;
          group.add(horz);
          group.add(vert);
          return layer.add(group);
        };
        return FixationCross;
      }(Stimulus);
      exports.FixationCross = FixationCross;
    }.call(this));
  });
  require.define('/components/canvas/clear.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Clear, Stimulus, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      Clear = function (_super) {
        __extends(Clear, _super);
        function Clear() {
          _ref = Clear.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        Clear.prototype.render = function (context, layer) {
          return context.clearContent(true);
        };
        return Clear;
      }(Stimulus);
      exports.Clear = Clear;
    }.call(this));
  });
  require.define('/components/canvas/circle.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Circle, Stimulus, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      Circle = function (_super) {
        __extends(Circle, _super);
        function Circle() {
          _ref = Circle.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        Circle.prototype.defaults = {
          x: 100,
          y: 100,
          radius: 50,
          fill: 'red',
          opacity: 1
        };
        Circle.prototype.render = function (context, layer) {
          var circ;
          circ = new Kinetic.Circle({
            x: this.spec.x,
            y: this.spec.y,
            radius: this.spec.radius,
            fill: this.spec.fill,
            stroke: this.spec.stroke,
            strokeWidth: this.spec.strokeWidth,
            opacity: this.spec.opacity
          });
          return layer.add(circ);
        };
        return Circle;
      }(Stimulus);
      exports.Circle = Circle;
    }.call(this));
  });
  require.define('/components/canvas/blank.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Blank, Stimulus, _, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      _ = require('/../node_modules/lodash/dist/lodash.js', module);
      Stimulus = require('/stimresp.js', module).Stimulus;
      Blank = function (_super) {
        __extends(Blank, _super);
        function Blank() {
          _ref = Blank.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        Blank.prototype.defaults = { fill: 'white' };
        Blank.prototype.render = function (context, layer) {
          var blank;
          blank = new Kinetic.Rect({
            x: 0,
            y: 0,
            width: context.width(),
            height: context.height(),
            fill: this.spec.fill
          });
          return layer.add(blank);
        };
        return Blank;
      }(Stimulus);
      exports.Blank = Blank;
    }.call(this));
  });
  require.define('/components/canvas/arrow.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Arrow, Stimulus, _ref, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      Arrow = function (_super) {
        __extends(Arrow, _super);
        function Arrow() {
          _ref = Arrow.__super__.constructor.apply(this, arguments);
          return _ref;
        }
        Arrow.prototype.defaults = {
          x: 100,
          y: 100,
          length: 100,
          angle: 0,
          thickness: 40,
          fill: 'red',
          arrowSize: 50
        };
        Arrow.prototype.render = function (context, layer) {
          var group, rect, triangle, _this;
          rect = new Kinetic.Rect({
            x: 0,
            y: 0,
            width: this.spec.length,
            height: this.spec.thickness,
            fill: this.spec.fill,
            stroke: this.spec.stroke,
            strokeWidth: this.spec.strokeWidth,
            opacity: this.spec.opacity
          });
          _this = this;
          triangle = new Kinetic.Shape({
            drawFunc: function (cx) {
              cx.beginPath();
              cx.moveTo(_this.spec.length, -_this.spec.arrowSize / 2);
              cx.lineTo(_this.spec.length + _this.spec.arrowSize, _this.spec.thickness / 2);
              cx.lineTo(_this.spec.length, _this.spec.thickness + _this.spec.arrowSize / 2);
              cx.closePath();
              return cx.fillStrokeShape(this);
            },
            fill: _this.spec.fill,
            stroke: this.spec.stroke,
            strokeWidth: this.spec.strokeWidth,
            opacity: this.spec.opacity
          });
          group = new Kinetic.Group({
            x: this.spec.x,
            y: this.spec.y,
            rotationDeg: this.spec.angle,
            offset: [
              0,
              this.spec.thickness / 2
            ]
          });
          group.add(rect);
          group.add(triangle);
          return layer.add(group);
        };
        return Arrow;
      }(Stimulus);
      exports.Arrow = Arrow;
    }.call(this));
  });
  require.define('/components/canvas/background.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Background, Stimulus, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      Background = function (_super) {
        __extends(Background, _super);
        function Background(stims, fill) {
          this.stims = stims != null ? stims : [];
          this.fill = fill != null ? fill : 'white';
          Background.__super__.constructor.call(this, {}, {});
        }
        Background.prototype.render = function (context, layer) {
          var background, stim, _i, _len, _ref, _results;
          background = new Kinetic.Rect({
            x: 0,
            y: 0,
            width: context.width(),
            height: context.height(),
            name: 'background',
            fill: this.fill
          });
          layer.add(background);
          _ref = this.stims;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            stim = _ref[_i];
            _results.push(stim.render(context, layer));
          }
          return _results;
        };
        return Background;
      }(Stimulus);
      exports.Background = Background;
    }.call(this));
  });
  require.define('/components/components.js', function (module, exports, __dirname, __filename) {
    (function () {
      exports.Sound = require('/components/sound.js', module).Sound;
    }.call(this));
  });
  require.define('/components/sound.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Sound, Stimulus, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      Sound = function (_super) {
        __extends(Sound, _super);
        Sound.prototype.defaults = { url: 'http://www.centraloutdoors.com/mp3/sheep/sheep.wav' };
        function Sound(spec) {
          if (spec == null) {
            spec = {};
          }
          Sound.__super__.constructor.call(this, spec);
          this.sound = new buzz.sound(this.spec.url);
        }
        Sound.prototype.render = function (context, layer) {
          return this.sound.play();
        };
        return Sound;
      }(Stimulus);
      exports.Sound = Sound;
    }.call(this));
  });
  require.define('/components/canvas/Background.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Background, Stimulus, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Stimulus = require('/stimresp.js', module).Stimulus;
      Background = function (_super) {
        __extends(Background, _super);
        function Background(stims, fill) {
          this.stims = stims != null ? stims : [];
          this.fill = fill != null ? fill : 'white';
          Background.__super__.constructor.call(this, {}, {});
        }
        Background.prototype.render = function (context, layer) {
          var background, stim, _i, _len, _ref, _results;
          background = new Kinetic.Rect({
            x: 0,
            y: 0,
            width: context.width(),
            height: context.height(),
            name: 'background',
            fill: this.fill
          });
          layer.add(background);
          _ref = this.stims;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            stim = _ref[_i];
            _results.push(stim.render(context, layer));
          }
          return _results;
        };
        return Background;
      }(Stimulus);
      exports.Background = Background;
    }.call(this));
  });
  global.Psy = require('/main.coffee');
}.call(this, this));