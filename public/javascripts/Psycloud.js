// Generated by CommonJS Everywhere 0.9.2
(function (global) {
  function require(file, parentModule) {
    if ({}.hasOwnProperty.call(require.cache, file))
      return require.cache[file];
    var resolved = require.resolve(file);
    if (!resolved)
      throw new Error('Failed to resolve module ' + file);
    var module$ = {
        id: file,
        require: require,
        filename: file,
        exports: {},
        loaded: false,
        parent: parentModule,
        children: []
      };
    if (parentModule)
      parentModule.children.push(module$);
    var dirname = file.slice(0, file.lastIndexOf('/') + 1);
    require.cache[file] = module$.exports;
    resolved.call(module$.exports, module$, module$.exports, dirname, file);
    module$.loaded = true;
    return require.cache[file] = module$.exports;
  }
  require.modules = {};
  require.cache = {};
  require.resolve = function (file) {
    return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;
  };
  require.define = function (file, fn) {
    require.modules[file] = fn;
  };
  var process = function () {
      var cwd = '/';
      return {
        title: 'browser',
        version: 'v0.8.9',
        browser: true,
        env: {},
        argv: [],
        nextTick: global.setImmediate || function (fn) {
          setTimeout(fn, 0);
        },
        cwd: function () {
          return cwd;
        },
        chdir: function (dir) {
          cwd = dir;
        }
      };
    }();
  require.define('/main.coffee', function (module, exports, __dirname, __filename) {
    var Exp, key, key, Psy, value, value;
    Exp = require('/Elements.js', module);
    Psy = require('/PsyCloud.js', module);
    for (key in Psy) {
      value = Psy[key];
      exports[key] = value;
    }
    for (key in Exp) {
      value = Exp[key];
      exports[key] = value;
    }
  });
  require.define('/PsyCloud.js', function (module, exports, __dirname, __filename) {
    (function () {
      var ConditionalSampler, CrossedFactorSpec, DataTable, Event, ExhaustiveSampler, ExpDesign, Experiment, ExperimentContext, Factor, FactorSpec, MockStimFactory, Q, Sampler, StimFactory, TaskSpec, Trial, UniformSampler, VarSpec, asArray, dt1, dt2, dt3, permute, rep, repLen, _, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      _ = require('/../node_modules/lodash/dist/lodash.js', module);
      Q = require('/../node_modules/q/q.js', module);
      asArray = function (value) {
        if (_.isArray(value)) {
          return value;
        } else if (_.isNumber(value) || _.isBoolean(value)) {
          return [value];
        } else {
          return _.toArray(value);
        }
      };
      permute = function (input) {
        var main, permArr, usedChars;
        permArr = [];
        usedChars = [];
        exports.main = main = function (input) {
          var ch, i, _i, _ref;
          for (i = _i = 0, _ref = input.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            ch = input.splice(i, 1)[0];
            usedChars.push(ch);
            if (input.length === 0) {
              permArr.push(usedChars.slice());
            }
            main(input);
            input.splice(i, 0, ch);
            usedChars.pop();
          }
          return permArr;
        };
        return main(input);
      };
      exports.permute = permute;
      console.log(permute([
        1,
        2,
        3
      ]));
      rep = function (vec, times) {
        var el, i, j, out, _this = this;
        if (!(times instanceof Array)) {
          times = [times];
        }
        if (times.length !== 1 && vec.length !== times.length) {
          console.log('vec', vec);
          console.log('times', times);
          throw 'vec.length must equal times.length or times.length must be 1';
        }
        if (vec.length === times.length) {
          out = function () {
            var _i, _len, _results;
            _results = [];
            for (i = _i = 0, _len = vec.length; _i < _len; i = ++_i) {
              el = vec[i];
              _results.push(function () {
                var _j, _ref, _results1;
                _results1 = [];
                for (j = _j = 1, _ref = times[i]; 1 <= _ref ? _j <= _ref : _j >= _ref; j = 1 <= _ref ? ++_j : --_j) {
                  _results1.push(el);
                }
                return _results1;
              }());
            }
            return _results;
          }();
          return _.flatten(out);
        } else {
          out = _.times(times[0], function (n) {
            return vec;
          });
          return _.flatten(out);
        }
      };
      repLen = function (vec, length) {
        var i, _i, _results;
        if (length < 1) {
          throw 'repLen: length must be greater than or equal to 1';
        }
        _results = [];
        for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
          _results.push(vec[i % vec.length]);
        }
        return _results;
      };
      exports.rep = rep;
      exports.repLen = repLen;
      exports.Sampler = Sampler = function () {
        function Sampler(items) {
          this.items = items;
        }
        Sampler.prototype.take = function (n) {
          if (n > this.items.length) {
            throw 'cannot take sample larger than the number of items when using non-replacing sampler';
          }
          return _.shuffle(this.items).slice(0, n);
        };
        return Sampler;
      }();
      exports.ExhaustiveSampler = ExhaustiveSampler = function () {
        ExhaustiveSampler.fillBuffer = function (items, n) {
          var buf, i;
          buf = function () {
            var _i, _results;
            _results = [];
            for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
              _results.push(_.shuffle(items));
            }
            return _results;
          }();
          return _.flatten(buf);
        };
        function ExhaustiveSampler(items, buflen) {
          this.items = items;
          if (buflen == null) {
            buflen = 10;
          }
          this.buffer = ExhaustiveSampler.fillBuffer(this.items, buflen);
        }
        ExhaustiveSampler.prototype.take = function (n) {
          var buf, buflen, res;
          if (n <= this.buffer.length) {
            res = _.take(this.buffer, n);
            this.buffer = _.drop(this.buffer, n);
            return res;
          } else {
            buflen = Math.max(n, 10 * this.items.length);
            buf = ExhaustiveSampler.fillBuffer(this.items, buflen / this.items.length);
            this.buffer = this.buffer.concat(buf);
            return this.take(n);
          }
        };
        return ExhaustiveSampler;
      }();
      exports.UniformSampler = UniformSampler = function (_super) {
        __extends(UniformSampler, _super);
        UniformSampler.validate = function (range) {
          if (range.length !== 2) {
            throw 'range must be an array with two values (min, max)';
          }
          if (range[1] <= range[0]) {
            throw 'range[1] must > range[0]';
          }
        };
        function UniformSampler(range) {
          this.range = range;
          this.interval = this.range[1] - this.range[0];
        }
        UniformSampler.prototype.take = function (n) {
          var i, nums;
          nums = function () {
            var _i, _results;
            _results = [];
            for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
              _results.push(Math.round(Math.random() * this.interval));
            }
            return _results;
          }.call(this);
          return nums;
        };
        return UniformSampler;
      }(Sampler);
      exports.Factor = Factor = function (_super) {
        __extends(Factor, _super);
        Factor.asFactor = function (arr) {
          return function (func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
          }(Factor, arr, function () {
          });
        };
        function Factor(arr) {
          var arg, _i, _len;
          for (_i = 0, _len = arr.length; _i < _len; _i++) {
            arg = arr[_i];
            this.push(arg);
          }
          this.levels = _.uniq(arr).sort();
        }
        return Factor;
      }(Array);
      exports.DataTable = DataTable = function () {
        DataTable.prototype.show = function () {
          var i, _i, _ref, _results;
          console.log('DataTable: rows: ' + this.nrow() + ' columns: ' + this.ncol());
          _results = [];
          for (i = _i = 0, _ref = this.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            _results.push(console.log(this.record(i)));
          }
          return _results;
        };
        DataTable.fromRecords = function (records, union) {
          var allkeys, key, rec, vars, _i, _j, _k, _len, _len1, _len2;
          if (union == null) {
            union = true;
          }
          allkeys = _.uniq(_.flatten(_.map(records, function (rec) {
            return _.keys(rec);
          })));
          console.log(allkeys);
          vars = {};
          for (_i = 0, _len = allkeys.length; _i < _len; _i++) {
            key = allkeys[_i];
            vars[key] = [];
          }
          console.log(vars);
          for (_j = 0, _len1 = records.length; _j < _len1; _j++) {
            rec = records[_j];
            for (_k = 0, _len2 = allkeys.length; _k < _len2; _k++) {
              key = allkeys[_k];
              vars[key].push(rec[key] || null);
            }
          }
          return new DataTable(vars);
        };
        DataTable.build = function (vars) {
          if (vars == null) {
            vars = {};
          }
          return Object.seal(new DataTable(vars));
        };
        DataTable.rbind = function (tab1, tab2, union) {
          var col1, col2, keys1, keys2, name, out, sharedKeys, _i, _len;
          if (union == null) {
            union = false;
          }
          keys1 = _.keys(tab1);
          keys2 = _.keys(tab2);
          sharedKeys = union ? _.union(keys1, keys2) : _.intersection(keys1, keys2);
          console.log('shared keys', sharedKeys);
          out = {};
          for (_i = 0, _len = sharedKeys.length; _i < _len; _i++) {
            name = sharedKeys[_i];
            col1 = tab1[name];
            col2 = tab2[name];
            if (!col1) {
              col1 = repLen([null], tab1.nrow());
            }
            if (!col2) {
              col2 = repLen([null], tab2.nrow());
            }
            out[name] = col1.concat(col2);
          }
          return new DataTable(out);
        };
        DataTable.cbind = function (tab1, tab2) {
          var diffkeys, key, out, _i, _len;
          if (tab1.nrow() !== tab2.nrow()) {
            throw 'cbind requires arguments to have same number of rows';
          }
          out = _.cloneDeep(tab1);
          diffkeys = _.difference(_.keys(tab2), _.keys(tab1));
          for (_i = 0, _len = diffkeys.length; _i < _len; _i++) {
            key = diffkeys[_i];
            out[key] = tab2[key];
          }
          return out;
        };
        DataTable.expand = function (vars, unique, nreps) {
          var d, i, key, name, nargs, nm, nx, orep, out, r1, r2, r3, repfac, value, _i, _results;
          if (vars == null) {
            vars = {};
          }
          if (unique == null) {
            unique = true;
          }
          if (nreps == null) {
            nreps = 1;
          }
          if (unique) {
            out = {};
            for (name in vars) {
              value = vars[name];
              out[name] = _.unique(value);
            }
            vars = out;
          }
          nargs = _.size(vars);
          nm = _.keys(vars);
          repfac = 1;
          d = _.map(vars, function (x) {
            return x.length;
          });
          orep = _.reduce(d, function (x, acc) {
            return x * acc;
          });
          out = {};
          for (key in vars) {
            value = vars[key];
            nx = value.length;
            orep = orep / nx;
            r1 = rep([repfac], nx);
            r2 = rep(function () {
              _results = [];
              for (var _i = 0; 0 <= nx ? _i < nx : _i > nx; 0 <= nx ? _i++ : _i--) {
                _results.push(_i);
              }
              return _results;
            }.apply(this), r1);
            r3 = rep(r2, orep);
            out[key] = function () {
              var _j, _len, _results1;
              _results1 = [];
              for (_j = 0, _len = r3.length; _j < _len; _j++) {
                i = r3[_j];
                _results1.push(value[i]);
              }
              return _results1;
            }();
            repfac = repfac * nx;
          }
          return new DataTable(out);
        };
        function DataTable(vars) {
          var key, samelen, value, varlen;
          if (vars == null) {
            vars = {};
          }
          varlen = _.map(vars, function (x) {
            return x.length;
          });
          samelen = _.all(varlen, function (x) {
            return x === varlen[0];
          });
          if (!samelen) {
            throw 'arguments to DataTable must all have same length.';
          }
          for (key in vars) {
            value = vars[key];
            this[key] = value;
          }
        }
        DataTable.prototype.subset = function (key, filter) {
          var el, i, keep, name, out, val, value;
          keep = function () {
            var _i, _len, _ref, _results;
            _ref = this[key];
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              val = _ref[_i];
              if (filter(val)) {
                _results.push(true);
              } else {
                _results.push(false);
              }
            }
            return _results;
          }.call(this);
          out = {};
          for (name in this) {
            if (!__hasProp.call(this, name))
              continue;
            value = this[name];
            out[name] = function () {
              var _i, _len, _results;
              _results = [];
              for (i = _i = 0, _len = value.length; _i < _len; i = ++_i) {
                el = value[i];
                if (keep[i] === true) {
                  _results.push(el);
                }
              }
              return _results;
            }();
          }
          return new DataTable(out);
        };
        DataTable.prototype.whichRow = function (where) {
          var count, i, key, nkeys, out, rec, value, _i, _ref;
          out = [];
          nkeys = _.keys(where).length;
          for (i = _i = 0, _ref = this.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            rec = this.record(i);
            count = asArray(function () {
              var _results;
              _results = [];
              for (key in where) {
                value = where[key];
                _results.push(rec[key] === value);
              }
              return _results;
            }());
            count = _.map(count, function (x) {
              if (x) {
                return 1;
              } else {
                return 0;
              }
            });
            count = _.reduce(asArray(count), function (sum, num) {
              return sum + num;
            });
            if (count === nkeys) {
              out.push(i);
            }
          }
          return out;
        };
        DataTable.prototype.select = function (where) {
          var count, i, key, nkeys, out, rec, value, _i, _ref;
          out = [];
          nkeys = _.keys(where).length;
          for (i = _i = 0, _ref = this.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            rec = this.record(i);
            count = asArray(function () {
              var _results;
              _results = [];
              for (key in where) {
                value = where[key];
                _results.push(rec[key] === value);
              }
              return _results;
            }());
            count = _.map(count, function (x) {
              if (x) {
                return 1;
              } else {
                return 0;
              }
            });
            count = _.reduce(asArray(count), function (sum, num) {
              return sum + num;
            });
            if (count === nkeys) {
              out.push(rec);
            }
          }
          return out;
        };
        DataTable.prototype.nrow = function () {
          var lens, name, value;
          lens = function () {
            var _results;
            _results = [];
            for (name in this) {
              if (!__hasProp.call(this, name))
                continue;
              value = this[name];
              _results.push(value.length);
            }
            return _results;
          }.call(this);
          return _.max(lens);
        };
        DataTable.prototype.ncol = function () {
          return Object.keys(this).length;
        };
        DataTable.prototype.colnames = function () {
          return Object.keys(this);
        };
        DataTable.prototype.record = function (index) {
          var name, rec, value;
          rec = {};
          for (name in this) {
            if (!__hasProp.call(this, name))
              continue;
            value = this[name];
            rec[name] = value[index];
          }
          return rec;
        };
        DataTable.prototype.replicate = function (nreps) {
          var name, out, value, _this = this;
          out = {};
          for (name in this) {
            if (!__hasProp.call(this, name))
              continue;
            value = this[name];
            out[name] = _.flatten(_.times(nreps, function (n) {
              return value;
            }));
          }
          return new DataTable(out);
        };
        DataTable.prototype.bindcol = function (name, column) {
          if (column.length !== this.nrow()) {
            throw 'new column must be same length as existing DataTable object: column.length is  ' + column.length + ' and this.length is  ' + this.nrow();
          }
          this[name] = column;
          return this;
        };
        DataTable.prototype.bindrow = function (rows) {
          var key, record, value, _i, _len;
          if (!_.isArray(rows)) {
            rows = [rows];
          }
          for (_i = 0, _len = rows.length; _i < _len; _i++) {
            record = rows[_i];
            console.log(record);
            for (key in record) {
              if (!__hasProp.call(record, key))
                continue;
              value = record[key];
              if (!_.has(this, key)) {
                throw 'DataTable has no field named ' + key;
              } else {
                this[key].push(value);
              }
            }
          }
          return this;
        };
        return DataTable;
      }();
      exports.StimFactory = StimFactory = function () {
        function StimFactory() {
        }
        StimFactory.prototype.makeStimulus = function (name, params) {
        };
        StimFactory.prototype.makeResponse = function (name, params) {
        };
        StimFactory.prototype.makeEvent = function (stim, response) {
        };
        return StimFactory;
      }();
      exports.MockStimFactory = MockStimFactory = function (_super) {
        __extends(MockStimFactory, _super);
        function MockStimFactory() {
          return MockStimFactory.__super__.constructor.apply(this, arguments);
        }
        MockStimFactory.prototype.makeStimulus = function (name, params) {
          var ret;
          ret = {};
          ret[name] = params;
          return ret;
        };
        MockStimFactory.prototype.makeResponse = function (name, params) {
          var ret;
          ret = {};
          ret[name] = params;
          return ret;
        };
        MockStimFactory.prototype.makeEvent = function (stim, response) {
          return [
            stim,
            response
          ];
        };
        return MockStimFactory;
      }(StimFactory);
      exports.Event = Event = function () {
        function Event(stimulus, response) {
          this.stimulus = stimulus;
          this.response = response;
        }
        Event.prototype.start = function (context) {
          var _this = this;
          console.log('starting event', this.stimulus);
          if (!this.stimulus.overlay) {
            context.clearContent();
          }
          console.log('rendering event');
          this.stimulus.render(context, context.contentLayer);
          context.draw();
          console.log('activating response');
          return this.response.activate(context).then(function (ret) {
            _this.stimulus.stop();
            return ret;
          });
        };
        return Event;
      }();
      exports.Trial = Trial = function () {
        function Trial(events, meta, background) {
          this.events = events != null ? events : [];
          this.meta = meta != null ? meta : {};
          this.background = background;
        }
        Trial.prototype.numEvents = function () {
          return this.events.length;
        };
        Trial.prototype.push = function (event) {
          return this.events.push(event);
        };
        Trial.prototype.start = function (context) {
          var farray, fun, result, _i, _len, _this = this;
          console.log('starting trial');
          context.clearBackground();
          if (this.background) {
            context.setBackground(this.background);
            context.drawBackground();
          }
          farray = _.map(this.events, function (ev) {
            return function () {
              return ev.start(context);
            };
          });
          result = Q.resolve(0);
          for (_i = 0, _len = farray.length; _i < _len; _i++) {
            fun = farray[_i];
            result = result.then(fun);
          }
          return result;
        };
        return Trial;
      }();
      exports.ExperimentContext = ExperimentContext = function () {
        function ExperimentContext() {
        }
        ExperimentContext.prototype.eventLog = [];
        ExperimentContext.prototype.trialNumber = 0;
        ExperimentContext.prototype.currentTrial = {};
        ExperimentContext.prototype.logEvent = function (key, value) {
          var record;
          console.log('logging event');
          record = _.clone(this.currentTrial.meta);
          record[key] = value;
          this.eventLog.push(record);
          return console.log(this.eventLog);
        };
        ExperimentContext.prototype.start = function (trialList) {
          var fun, funList, result, _i, _len, _results, _this = this;
          funList = _.map(trialList, function (trial) {
            return function () {
              _this.trialNumber += 1;
              _this.currentTrial = trial;
              return trial.start(_this);
            };
          });
          result = Q.resolve(0);
          _results = [];
          for (_i = 0, _len = funList.length; _i < _len; _i++) {
            fun = funList[_i];
            console.log('building trial list');
            _results.push(result = result.then(fun));
          }
          return _results;
        };
        ExperimentContext.prototype.clearContent = function () {
        };
        ExperimentContext.prototype.clearBackground = function () {
        };
        ExperimentContext.prototype.keydownStream = function () {
        };
        ExperimentContext.prototype.keypressStream = function () {
        };
        ExperimentContext.prototype.mousepressStream = function () {
        };
        ExperimentContext.prototype.draw = function () {
        };
        return ExperimentContext;
      }();
      exports.Experiment = Experiment = function () {
        function Experiment(designSpec, stimFactory) {
          this.designSpec = designSpec;
          this.stimFactory = stimFactory != null ? stimFactory : new MockStimFactory;
          this.design = new ExpDesign(this.designSpec);
          this.display = this.designSpec.Display;
          this.trialGenerator = this.display.Trial;
        }
        Experiment.prototype.buildStimulus = function (event) {
          var params, stimType;
          stimType = _.keys(event)[0];
          params = _.values(event)[0];
          return this.stimFactory.makeStimulus(stimType, params);
        };
        Experiment.prototype.buildEvent = function (event) {
          var params, responseType;
          responseType = _.keys(event)[0];
          params = _.values(event)[0];
          return this.stimFactory.makeResponse(responseType, params);
        };
        Experiment.prototype.buildTrial = function (eventSpec, record) {
          var events, key, response, responseSpec, stim, stimSpec, value;
          events = function () {
            var _results;
            _results = [];
            for (key in eventSpec) {
              value = eventSpec[key];
              stimSpec = _.omit(value, 'Next');
              responseSpec = _.pick(value, 'Next');
              stim = this.buildStimulus(stimSpec);
              response = this.buildEvent(responseSpec.Next);
              _results.push(this.stimFactory.makeEvent(stim, response));
            }
            return _results;
          }.call(this);
          return new Trial(events, record);
        };
        Experiment.prototype.start = function (context) {
          var i, record, trialList, trialSpec, trials;
          trials = this.design.fullDesign;
          console.log(trials.nrow());
          trialList = function () {
            var _i, _ref, _results;
            _results = [];
            for (i = _i = 0, _ref = trials.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              record = trials.record(i);
              record.$trialNumber = i;
              trialSpec = this.trialGenerator(record);
              _results.push(this.buildTrial(trialSpec, record));
            }
            return _results;
          }.call(this);
          return context.start(trialList);
        };
        return Experiment;
      }();
      exports.ConditionalSampler = ConditionalSampler = function (_super) {
        __extends(ConditionalSampler, _super);
        ConditionalSampler.prototype.makeItemSubsets = function () {
          var ctable, i, indices, itemSets, j, keySet, levs, record;
          ctable = this.factorSpec.conditionTable;
          keySet = function () {
            var _i, _ref, _results;
            _results = [];
            for (i = _i = 0, _ref = ctable.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              record = ctable.record(i);
              levs = _.values(record);
              _results.push(_.reduce(levs, function (a, b) {
                return a + ':' + b;
              }));
            }
            return _results;
          }();
          console.log(keySet);
          itemSets = function () {
            var _i, _ref, _results;
            _results = [];
            for (i = _i = 0, _ref = ctable.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              record = ctable.record(i);
              indices = this.itemMap.whichRow(record);
              _results.push(function () {
                var _j, _len, _results1;
                _results1 = [];
                for (_j = 0, _len = indices.length; _j < _len; _j++) {
                  j = indices[_j];
                  _results1.push(this.items[j]);
                }
                return _results1;
              }.call(this));
            }
            return _results;
          }.call(this);
          console.log(itemSets);
          return _.zipObject(keySet, itemSets);
        };
        function ConditionalSampler(items, itemMap, factorSpec) {
          var key, value, _ref;
          this.items = items;
          this.itemMap = itemMap;
          this.factorSpec = factorSpec;
          this.keyMap = this.makeItemSubsets();
          this.conditions = _.keys(this.keyMap);
          this.samplerSet = {};
          _ref = this.keyMap;
          for (key in _ref) {
            value = _ref[key];
            this.samplerSet[key] = new ExhaustiveSampler(value);
          }
        }
        ConditionalSampler.prototype.take = function (n) {
          var keys;
          keys = repLen(this.conditions, n);
          return _.flatten(this.takeCondition(keys));
        };
        ConditionalSampler.prototype.takeCondition = function (keys) {
          var key, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = keys.length; _i < _len; _i++) {
            key = keys[_i];
            _results.push(this.samplerSet[key].take(1));
          }
          return _results;
        };
        return ConditionalSampler;
      }(Sampler);
      exports.VarSpec = VarSpec = function () {
        function VarSpec() {
        }
        VarSpec.name = '';
        VarSpec.nblocks = 1;
        VarSpec.reps = 1;
        VarSpec.expanded = {};
        VarSpec.prototype.names = function () {
          return this.name;
        };
        VarSpec.prototype.ntrials = function () {
          return this.nblocks * this.reps;
        };
        VarSpec.prototype.valueAt = function (block, trial) {
        };
        return VarSpec;
      }();
      exports.FactorSpec = FactorSpec = function (_super) {
        __extends(FactorSpec, _super);
        function FactorSpec(name, levels) {
          this.name = name;
          this.levels = levels;
          console.log(this.name);
          console.log(this.levels);
          this.factorSet = {};
          this.factorSet[this.name] = this.levels;
          this.conditionTable = DataTable.expand(this.factorSet);
        }
        FactorSpec.prototype.cross = function (other) {
          return new CrossedFactorSpec(this.nblocks, this.reps, [
            this,
            other
          ]);
        };
        FactorSpec.prototype.expand = function (nblocks, reps) {
          var blocks, concatBlocks, i, prop, vset, _i, _results;
          prop = {};
          prop[this.name] = this.levels;
          vset = new DataTable(prop);
          blocks = function () {
            var _i, _results;
            _results = [];
            for (i = _i = 1; 1 <= nblocks ? _i <= nblocks : _i >= nblocks; i = 1 <= nblocks ? ++_i : --_i) {
              _results.push(vset.replicate(reps));
            }
            return _results;
          }();
          concatBlocks = _.reduce(blocks, function (sum, nex) {
            return DataTable.rbind(sum, nex);
          });
          concatBlocks.bindcol('$Block', rep(function () {
            _results = [];
            for (var _i = 1; 1 <= nblocks ? _i <= nblocks : _i >= nblocks; 1 <= nblocks ? _i++ : _i--) {
              _results.push(_i);
            }
            return _results;
          }.apply(this), rep(reps * vset.nrow(), nblocks)));
          return concatBlocks;
        };
        return FactorSpec;
      }(VarSpec);
      exports.CrossedFactorSpec = CrossedFactorSpec = function (_super) {
        __extends(CrossedFactorSpec, _super);
        function CrossedFactorSpec(parents) {
          var fac;
          this.parents = parents;
          this.parentNames = function () {
            var _i, _len, _ref, _results;
            _ref = this.parents;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              fac = _ref[_i];
              _results.push(fac.name);
            }
            return _results;
          }.call(this);
          this.name = _.reduce(this.parentNames, function (n, n1) {
            return n + ':' + n1;
          });
          this.levels = function () {
            var _i, _len, _ref, _results;
            _ref = this.parents;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              fac = _ref[_i];
              _results.push(fac.levels);
            }
            return _results;
          }.call(this);
          this.factorSet = _.zipObject(this.parentNames, this.levels);
          this.conditionTable = DataTable.expand(this.factorSet);
        }
        CrossedFactorSpec.prototype.names = function () {
          return this.parentNames;
        };
        CrossedFactorSpec.prototype.expand = function (nblocks, reps) {
          var blocks, concatBlocks, i, _i, _results;
          blocks = function () {
            var _i, _results;
            _results = [];
            for (i = _i = 1; 1 <= nblocks ? _i <= nblocks : _i >= nblocks; i = 1 <= nblocks ? ++_i : --_i) {
              _results.push(this.conditionTable.replicate(reps));
            }
            return _results;
          }.call(this);
          concatBlocks = _.reduce(blocks, function (sum, nex) {
            return DataTable.rbind(sum, nex);
          });
          concatBlocks.bindcol('$Block', rep(function () {
            _results = [];
            for (var _i = 1; 1 <= nblocks ? _i <= nblocks : _i >= nblocks; 1 <= nblocks ? _i++ : _i--) {
              _results.push(_i);
            }
            return _results;
          }.apply(this), rep(reps * this.conditionTable.nrow(), nblocks)));
          return concatBlocks;
        };
        return CrossedFactorSpec;
      }(VarSpec);
      exports.TaskSpec = TaskSpec = function () {
        function TaskSpec(varSpecs, crossedSet) {
          var i, vname, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2;
          this.varSpecs = varSpecs;
          this.crossedSet = crossedSet != null ? crossedSet : [];
          this.varnames = _.map(this.varSpecs, function (x) {
            return x.names();
          });
          this.varmap = {};
          for (i = _i = 0, _ref = this.varnames.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            this.varmap[this.varnames[i]] = this.varSpecs[i];
          }
          if (this.crossedSet.length > 0) {
            _ref1 = this.crossedSet;
            for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
              vname = _ref1[_j];
              this.crossedVars = this.varmap[vname];
            }
            this.crossedSpec = new CrossedFactorSpec(this.crossedVars);
          } else {
            this.crossedVars = [];
            this.crossedSpec = {};
          }
          this.uncrossedVars = _.difference(this.varnames, this.crossedSet);
          _ref2 = this.uncrossedVars;
          for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
            vname = _ref2[_k];
            this.uncrossedSpec = this.varmap[vname];
          }
          ({
            expand: function (nblocks, nreps) {
              var ctable;
              if (this.crossedVars.length > 0) {
                return ctable = this.crossedSpec.expand(nblocks, nreps);
              }
            }
          });
        }
        return TaskSpec;
      }();
      exports.ExpDesign = ExpDesign = function () {
        ExpDesign.blocks = 1;
        ExpDesign.validate = function (spec) {
          var des;
          if (!('Design' in spec)) {
            throw 'Design is undefined';
          }
          des = spec['Design'];
          if (!('Variables' in des)) {
            throw 'Variables is undefined';
          }
          if (!('Structure' in des)) {
            throw 'Structure is undefined';
          }
          if (!('Items' in spec)) {
            throw 'Items is undefined';
          }
        };
        ExpDesign.splitCrossedItems = function (itemSpec, crossedVariables) {
          var attrnames, conditionTable, i, indices, itemSets, j, keySet, levs, record, values;
          attrnames = crossedVariables.colnames();
          keySet = function () {
            var _i, _ref, _results;
            _results = [];
            for (i = _i = 0, _ref = crossedVariables.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              record = crossedVariables.record(i);
              levs = _.values(record);
              _results.push(_.reduce(levs, function (a, b) {
                return a + ':' + b;
              }));
            }
            return _results;
          }();
          values = itemSpec['values'];
          conditionTable = new DataTable(_.pick(itemSpec, attrnames));
          itemSets = function () {
            var _i, _ref, _results;
            _results = [];
            for (i = _i = 0, _ref = crossedVariables.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              record = crossedVariables.record(i);
              indices = conditionTable.whichRow(record);
              _results.push(function () {
                var _j, _len, _results1;
                _results1 = [];
                for (_j = 0, _len = indices.length; _j < _len; _j++) {
                  j = indices[_j];
                  _results1.push(values[j]);
                }
                return _results1;
              }());
            }
            return _results;
          }();
          return _.zipObject(keySet, itemSets);
        };
        ExpDesign.prototype.init = function (spec) {
          this.design = spec['Design'];
          this.variables = this.design['Variables'];
          this.itemSpec = spec['Items'];
          this.structure = this.design['Structure'];
          this.varnames = _.keys(this.variables);
          this.crossed = this.variables['Crossed'];
          return this.auxiliary = this.variables['Auxiliary'];
        };
        ExpDesign.prototype.initStructure = function () {
          if (this.structure['type'] === 'Block') {
            if (!_.has(this.structure, 'reps_per_block')) {
              this.structure['reps_per_block'] = 1;
            }
            this.reps_per_block = this.structure['reps_per_block'];
            return this.blocks = this.structure['blocks'];
          } else {
            this.reps_per_block = 1;
            return this.blocks = 1;
          }
        };
        ExpDesign.prototype.makeConditionalSampler = function (crossedSpec, crossedItems) {
          var crossedItemMap, crossedItemName, key;
          crossedItemName = _.keys(crossedItems)[0];
          console.log('names:', crossedSpec.names());
          crossedItemMap = function () {
            var _i, _len, _ref, _results;
            _ref = crossedSpec.names();
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              key = _ref[_i];
              _results.push(crossedItems[crossedItemName][key]);
            }
            return _results;
          }();
          crossedItemMap = _.zipObject(_.keys(this.crossed), crossedItemMap);
          console.log('item map: ', crossedItemMap);
          return new ConditionalSampler(crossedItems[crossedItemName].values, new DataTable(crossedItemMap), crossedSpec);
        };
        ExpDesign.prototype.makeCrossedSpec = function (crossed, nblocks, nreps) {
          var factors, key, val;
          factors = function () {
            var _results;
            _results = [];
            for (key in crossed) {
              val = crossed[key];
              _results.push(new FactorSpec(nblocks, nreps, key, val.levels));
            }
            return _results;
          }();
          return crossed = new CrossedFactorSpec(nblocks, nreps, factors);
        };
        ExpDesign.prototype.makeFactorSpec = function (fac, nblocks, nreps) {
          return new FactorSpec(nblocks, nreps, _.keys(fac)[0], _.values(fac)[0]);
        };
        function ExpDesign(spec) {
          var crossedItems, crossedSampler;
          if (spec == null) {
            spec = {};
          }
          ExpDesign.validate(spec);
          this.init(spec);
          this.initStructure();
          this.crossedSpec = this.makeCrossedSpec(this.crossed, this.blocks, this.reps_per_block);
          crossedItems = this.itemSpec.Crossed;
          crossedSampler = this.makeConditionalSampler(this.crossedSpec, crossedItems);
          this.fullDesign = this.crossedSpec.expanded.bindcol(_.keys(crossedItems)[0], crossedSampler.take(this.crossedSpec.expanded.nrow()));
          console.log(this.crossedDesign);
        }
        return ExpDesign;
      }();
      dt1 = DataTable.fromRecords([
        {
          a: 1,
          b: 2
        },
        {
          c: 1,
          d: 2,
          a: 88
        }
      ]);
      dt2 = DataTable.fromRecords([{
          a: 1,
          b: 2
        }]);
      dt2.show();
      dt3 = DataTable.rbind(dt1, dt2, true);
      dt3.show();
    }.call(this));
  });
  require.define('/../node_modules/q/q.js', function (module, exports, __dirname, __filename) {
    (function (definition) {
      if (typeof bootstrap === 'function') {
        bootstrap('promise', definition);
      } else if (typeof exports === 'object') {
        module.exports = definition();
      } else if (typeof define === 'function' && define.amd) {
        define(definition);
      } else if (typeof ses !== 'undefined') {
        if (!ses.ok()) {
          return;
        } else {
          ses.makeQ = definition;
        }
      } else {
        Q = definition();
      }
    }(function () {
      'use strict';
      var qStartingLine = captureLine();
      var qFileName;
      var noop = function () {
      };
      var nextTick;
      if (typeof process !== 'undefined') {
        nextTick = process.nextTick;
      } else if (typeof setImmediate === 'function') {
        if (typeof window !== 'undefined') {
          nextTick = setImmediate.bind(window);
        } else {
          nextTick = setImmediate;
        }
      } else {
        (function () {
          var head = {
              task: void 0,
              next: null
            }, tail = head, maxPendingTicks = 2, pendingTicks = 0, queuedTasks = 0, usedTicks = 0, requestTick;
          function onTick() {
            --pendingTicks;
            if (++usedTicks >= maxPendingTicks) {
              usedTicks = 0;
              maxPendingTicks *= 4;
              var expectedTicks = queuedTasks && Math.min(queuedTasks - 1, maxPendingTicks);
              while (pendingTicks < expectedTicks) {
                ++pendingTicks;
                requestTick();
              }
            }
            while (queuedTasks) {
              --queuedTasks;
              head = head.next;
              var task = head.task;
              head.task = void 0;
              task();
            }
            usedTicks = 0;
          }
          nextTick = function (task) {
            tail = tail.next = {
              task: task,
              next: null
            };
            if (pendingTicks < ++queuedTasks && pendingTicks < maxPendingTicks) {
              ++pendingTicks;
              requestTick();
            }
          };
          if (typeof MessageChannel !== 'undefined') {
            var channel = new MessageChannel;
            channel.port1.onmessage = onTick;
            requestTick = function () {
              channel.port2.postMessage(0);
            };
          } else {
            requestTick = function () {
              setTimeout(onTick, 0);
            };
          }
        }());
      }
      function uncurryThis(f) {
        var call = Function.call;
        return function () {
          return call.apply(f, arguments);
        };
      }
      var array_slice = uncurryThis(Array.prototype.slice);
      var array_reduce = uncurryThis(Array.prototype.reduce || function (callback, basis) {
          var index = 0, length = this.length;
          if (arguments.length === 1) {
            do {
              if (index in this) {
                basis = this[index++];
                break;
              }
              if (++index >= length) {
                throw new TypeError;
              }
            } while (1);
          }
          for (; index < length; index++) {
            if (index in this) {
              basis = callback(basis, this[index], index);
            }
          }
          return basis;
        });
      var array_indexOf = uncurryThis(Array.prototype.indexOf || function (value) {
          for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
              return i;
            }
          }
          return -1;
        });
      var array_map = uncurryThis(Array.prototype.map || function (callback, thisp) {
          var self = this;
          var collect = [];
          array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
          }, void 0);
          return collect;
        });
      var object_create = Object.create || function (prototype) {
          function Type() {
          }
          Type.prototype = prototype;
          return new Type;
        };
      var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
      var object_keys = Object.keys || function (object) {
          var keys = [];
          for (var key in object) {
            if (object_hasOwnProperty(object, key)) {
              keys.push(key);
            }
          }
          return keys;
        };
      var object_toString = uncurryThis(Object.prototype.toString);
      function isStopIteration(exception) {
        return object_toString(exception) === '[object StopIteration]' || exception instanceof QReturnValue;
      }
      var QReturnValue;
      if (typeof ReturnValue !== 'undefined') {
        QReturnValue = ReturnValue;
      } else {
        QReturnValue = function (value) {
          this.value = value;
        };
      }
      Q.longStackJumpLimit = 1;
      var STACK_JUMP_SEPARATOR = 'From previous event:';
      function makeStackTraceLong(error, promise) {
        if (promise.stack && typeof error === 'object' && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {
          error.stack = filterStackString(error.stack) + '\n' + STACK_JUMP_SEPARATOR + '\n' + filterStackString(promise.stack);
        }
      }
      function filterStackString(stackString) {
        var lines = stackString.split('\n');
        var desiredLines = [];
        for (var i = 0; i < lines.length; ++i) {
          var line = lines[i];
          if (!isInternalFrame(line) && !isNodeFrame(line)) {
            desiredLines.push(line);
          }
        }
        return desiredLines.join('\n');
      }
      function isNodeFrame(stackLine) {
        return stackLine.indexOf('(module.js:') !== -1 || stackLine.indexOf('(node.js:') !== -1;
      }
      function isInternalFrame(stackLine) {
        var pieces = /at .+ \((.*):(\d+):\d+\)/.exec(stackLine);
        if (!pieces) {
          return false;
        }
        var fileName = pieces[1];
        var lineNumber = pieces[2];
        return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;
      }
      function captureLine() {
        if (Error.captureStackTrace) {
          var fileName, lineNumber;
          var oldPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = function (error, frames) {
            fileName = frames[1].getFileName();
            lineNumber = frames[1].getLineNumber();
          };
          new Error().stack;
          Error.prepareStackTrace = oldPrepareStackTrace;
          qFileName = fileName;
          return lineNumber;
        }
      }
      function deprecate(callback, name, alternative) {
        return function () {
          if (typeof console !== 'undefined' && typeof console.warn === 'function') {
            console.warn(name + ' is deprecated, use ' + alternative + ' instead.', new Error('').stack);
          }
          return callback.apply(callback, arguments);
        };
      }
      function Q(value) {
        return resolve(value);
      }
      Q.nextTick = nextTick;
      Q.defer = defer;
      function defer() {
        var pending = [], progressListeners = [], value;
        var deferred = object_create(defer.prototype);
        var promise = object_create(makePromise.prototype);
        promise.promiseDispatch = function (resolve, op, operands) {
          var args = array_slice(arguments);
          if (pending) {
            pending.push(args);
            if (op === 'when' && operands[1]) {
              progressListeners.push(operands[1]);
            }
          } else {
            nextTick(function () {
              value.promiseDispatch.apply(value, args);
            });
          }
        };
        promise.valueOf = function () {
          if (pending) {
            return promise;
          }
          var nearer = valueOf(value);
          if (isPromise(nearer)) {
            value = nearer;
          }
          return nearer;
        };
        if (Error.captureStackTrace && Q.longStackJumpLimit > 0) {
          Error.captureStackTrace(promise, defer);
          promise.stack = promise.stack.substring(promise.stack.indexOf('\n') + 1);
        }
        function become(resolvedValue) {
          if (!pending) {
            return;
          }
          value = resolve(resolvedValue);
          array_reduce(pending, function (undefined, pending) {
            nextTick(function () {
              value.promiseDispatch.apply(value, pending);
            });
          }, void 0);
          pending = void 0;
          progressListeners = void 0;
        }
        deferred.promise = promise;
        deferred.resolve = become;
        deferred.fulfill = function (value) {
          become(fulfill(value));
        };
        deferred.reject = function (exception) {
          become(reject(exception));
        };
        deferred.notify = function (progress) {
          if (pending) {
            array_reduce(progressListeners, function (undefined, progressListener) {
              nextTick(function () {
                progressListener(progress);
              });
            }, void 0);
          }
        };
        return deferred;
      }
      defer.prototype.makeNodeResolver = function () {
        var self = this;
        return function (error, value) {
          if (error) {
            self.reject(error);
          } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
          } else {
            self.resolve(value);
          }
        };
      };
      Q.promise = promise;
      function promise(makePromise) {
        var deferred = defer();
        fcall(makePromise, deferred.resolve, deferred.reject, deferred.notify).fail(deferred.reject);
        return deferred.promise;
      }
      Q.makePromise = makePromise;
      function makePromise(descriptor, fallback, valueOf, exception, isException) {
        if (fallback === void 0) {
          fallback = function (op) {
            return reject(new Error('Promise does not support operation: ' + op));
          };
        }
        var promise = object_create(makePromise.prototype);
        promise.promiseDispatch = function (resolve, op, args) {
          var result;
          try {
            if (descriptor[op]) {
              result = descriptor[op].apply(promise, args);
            } else {
              result = fallback.call(promise, op, args);
            }
          } catch (exception) {
            result = reject(exception);
          }
          if (resolve) {
            resolve(result);
          }
        };
        if (valueOf) {
          promise.valueOf = valueOf;
        }
        if (isException) {
          promise.exception = exception;
        }
        return promise;
      }
      makePromise.prototype.then = function (fulfilled, rejected, progressed) {
        return when(this, fulfilled, rejected, progressed);
      };
      makePromise.prototype.thenResolve = function (value) {
        return when(this, function () {
          return value;
        });
      };
      makePromise.prototype.thenReject = function (reason) {
        return when(this, function () {
          throw reason;
        });
      };
      array_reduce([
        'isFulfilled',
        'isRejected',
        'isPending',
        'dispatch',
        'when',
        'spread',
        'get',
        'put',
        'set',
        'del',
        'delete',
        'post',
        'send',
        'invoke',
        'keys',
        'fapply',
        'fcall',
        'fbind',
        'all',
        'allResolved',
        'timeout',
        'delay',
        'catch',
        'finally',
        'fail',
        'fin',
        'progress',
        'done',
        'nfcall',
        'nfapply',
        'nfbind',
        'denodeify',
        'nbind',
        'ncall',
        'napply',
        'nbind',
        'npost',
        'nsend',
        'ninvoke',
        'nodeify'
      ], function (undefined, name) {
        makePromise.prototype[name] = function () {
          return Q[name].apply(Q, [this].concat(array_slice(arguments)));
        };
      }, void 0);
      makePromise.prototype.toSource = function () {
        return this.toString();
      };
      makePromise.prototype.toString = function () {
        return '[object Promise]';
      };
      Q.nearer = valueOf;
      function valueOf(value) {
        if (isPromise(value)) {
          return value.valueOf();
        }
        return value;
      }
      Q.isPromise = isPromise;
      function isPromise(object) {
        return object && typeof object.promiseDispatch === 'function';
      }
      Q.isPromiseAlike = isPromiseAlike;
      function isPromiseAlike(object) {
        return object && typeof object.then === 'function';
      }
      Q.isPending = isPending;
      function isPending(object) {
        return !isFulfilled(object) && !isRejected(object);
      }
      Q.isFulfilled = isFulfilled;
      function isFulfilled(object) {
        return !isPromiseAlike(valueOf(object));
      }
      Q.isRejected = isRejected;
      function isRejected(object) {
        object = valueOf(object);
        return isPromise(object) && 'exception' in object;
      }
      var rejections = [];
      var errors = [];
      var errorsDisplayed;
      function displayErrors() {
        if (!errorsDisplayed && typeof window !== 'undefined' && !window.Touch && window.console) {
          console.log('Should be empty:', errors);
        }
        errorsDisplayed = true;
      }
      if (typeof process !== 'undefined' && process.on) {
        process.on('exit', function () {
          for (var i = 0; i < errors.length; i++) {
            var error = errors[i];
            if (error && typeof error.stack !== 'undefined') {
              console.warn('Unhandled rejected promise:', error.stack);
            } else {
              console.warn('Unhandled rejected promise (no stack):', error);
            }
          }
        });
      }
      Q.reject = reject;
      function reject(exception) {
        var rejection = makePromise({
            'when': function (rejected) {
              if (rejected) {
                var at = array_indexOf(rejections, this);
                if (at !== -1) {
                  errors.splice(at, 1);
                  rejections.splice(at, 1);
                }
              }
              return rejected ? rejected(exception) : this;
            }
          }, function fallback() {
            return reject(exception);
          }, function valueOf() {
            return this;
          }, exception, true);
        displayErrors();
        rejections.push(rejection);
        errors.push(exception);
        return rejection;
      }
      Q.fulfill = fulfill;
      function fulfill(object) {
        return makePromise({
          'when': function () {
            return object;
          },
          'get': function (name) {
            return object[name];
          },
          'set': function (name, value) {
            object[name] = value;
          },
          'delete': function (name) {
            delete object[name];
          },
          'post': function (name, args) {
            if (name == null) {
              return object.apply(void 0, args);
            } else {
              return object[name].apply(object, args);
            }
          },
          'apply': function (thisP, args) {
            return object.apply(thisP, args);
          },
          'keys': function () {
            return object_keys(object);
          }
        }, void 0, function valueOf() {
          return object;
        });
      }
      Q.resolve = resolve;
      function resolve(value) {
        if (isPromise(value)) {
          return value;
        }
        value = valueOf(value);
        if (isPromiseAlike(value)) {
          return coerce(value);
        } else {
          return fulfill(value);
        }
      }
      function coerce(promise) {
        var deferred = defer();
        nextTick(function () {
          try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
          } catch (exception) {
            deferred.reject(exception);
          }
        });
        return deferred.promise;
      }
      Q.master = master;
      function master(object) {
        return makePromise({
          'isDef': function () {
          }
        }, function fallback(op, args) {
          return dispatch(object, op, args);
        }, function () {
          return valueOf(object);
        });
      }
      Q.when = when;
      function when(value, fulfilled, rejected, progressed) {
        var deferred = defer();
        var done = false;
        function _fulfilled(value) {
          try {
            return typeof fulfilled === 'function' ? fulfilled(value) : value;
          } catch (exception) {
            return reject(exception);
          }
        }
        function _rejected(exception) {
          if (typeof rejected === 'function') {
            makeStackTraceLong(exception, resolvedValue);
            try {
              return rejected(exception);
            } catch (newException) {
              return reject(newException);
            }
          }
          return reject(exception);
        }
        function _progressed(value) {
          return typeof progressed === 'function' ? progressed(value) : value;
        }
        var resolvedValue = resolve(value);
        nextTick(function () {
          resolvedValue.promiseDispatch(function (value) {
            if (done) {
              return;
            }
            done = true;
            deferred.resolve(_fulfilled(value));
          }, 'when', [function (exception) {
              if (done) {
                return;
              }
              done = true;
              deferred.resolve(_rejected(exception));
            }]);
        });
        resolvedValue.promiseDispatch(void 0, 'when', [
          void 0,
          function (value) {
            var newValue;
            var threw = false;
            try {
              newValue = _progressed(value);
            } catch (e) {
              threw = true;
              if (Q.onerror) {
                Q.onerror(e);
              } else {
                throw e;
              }
            }
            if (!threw) {
              deferred.notify(newValue);
            }
          }
        ]);
        return deferred.promise;
      }
      Q.spread = spread;
      function spread(promise, fulfilled, rejected) {
        return when(promise, function (valuesOrPromises) {
          return all(valuesOrPromises).then(function (values) {
            return fulfilled.apply(void 0, values);
          }, rejected);
        }, rejected);
      }
      Q.async = async;
      function async(makeGenerator) {
        return function () {
          function continuer(verb, arg) {
            var result;
            try {
              result = generator[verb](arg);
            } catch (exception) {
              if (isStopIteration(exception)) {
                return exception.value;
              } else {
                return reject(exception);
              }
            }
            return when(result, callback, errback);
          }
          var generator = makeGenerator.apply(this, arguments);
          var callback = continuer.bind(continuer, 'send');
          var errback = continuer.bind(continuer, 'throw');
          return callback();
        };
      }
      Q['return'] = _return;
      function _return(value) {
        throw new QReturnValue(value);
      }
      Q.promised = promised;
      function promised(callback) {
        return function () {
          return spread([
            this,
            all(arguments)
          ], function (self, args) {
            return callback.apply(self, args);
          });
        };
      }
      Q.dispatch = dispatch;
      function dispatch(object, op, args) {
        var deferred = defer();
        nextTick(function () {
          resolve(object).promiseDispatch(deferred.resolve, op, args);
        });
        return deferred.promise;
      }
      Q.dispatcher = dispatcher;
      function dispatcher(op) {
        return function (object) {
          var args = array_slice(arguments, 1);
          return dispatch(object, op, args);
        };
      }
      Q.get = dispatcher('get');
      Q.set = dispatcher('set');
      Q['delete'] = Q.del = dispatcher('delete');
      var post = Q.post = dispatcher('post');
      Q.send = send;
      Q.invoke = send;
      function send(value, name) {
        var args = array_slice(arguments, 2);
        return post(value, name, args);
      }
      Q.fapply = fapply;
      function fapply(value, args) {
        return dispatch(value, 'apply', [
          void 0,
          args
        ]);
      }
      Q['try'] = fcall;
      Q.fcall = fcall;
      function fcall(value) {
        var args = array_slice(arguments, 1);
        return fapply(value, args);
      }
      Q.fbind = fbind;
      function fbind(value) {
        var args = array_slice(arguments, 1);
        return function fbound() {
          var allArgs = args.concat(array_slice(arguments));
          return dispatch(value, 'apply', [
            this,
            allArgs
          ]);
        };
      }
      Q.keys = dispatcher('keys');
      Q.all = all;
      function all(promises) {
        return when(promises, function (promises) {
          var countDown = 0;
          var deferred = defer();
          array_reduce(promises, function (undefined, promise, index) {
            if (isFulfilled(promise)) {
              promises[index] = valueOf(promise);
            } else {
              ++countDown;
              when(promise, function (value) {
                promises[index] = value;
                if (--countDown === 0) {
                  deferred.resolve(promises);
                }
              }, deferred.reject);
            }
          }, void 0);
          if (countDown === 0) {
            deferred.resolve(promises);
          }
          return deferred.promise;
        });
      }
      Q.allResolved = allResolved;
      function allResolved(promises) {
        return when(promises, function (promises) {
          promises = array_map(promises, resolve);
          return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
          })), function () {
            return promises;
          });
        });
      }
      Q['catch'] = Q.fail = fail;
      function fail(promise, rejected) {
        return when(promise, void 0, rejected);
      }
      Q.progress = progress;
      function progress(promise, progressed) {
        return when(promise, void 0, void 0, progressed);
      }
      Q['finally'] = Q.fin = fin;
      function fin(promise, callback) {
        return when(promise, function (value) {
          return when(callback(), function () {
            return value;
          });
        }, function (exception) {
          return when(callback(), function () {
            return reject(exception);
          });
        });
      }
      Q.done = done;
      function done(promise, fulfilled, rejected, progress) {
        var onUnhandledError = function (error) {
          nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
              Q.onerror(error);
            } else {
              throw error;
            }
          });
        };
        var promiseToHandle = fulfilled || rejected || progress ? when(promise, fulfilled, rejected, progress) : promise;
        if (typeof process === 'object' && process && process.domain) {
          onUnhandledError = process.domain.bind(onUnhandledError);
        }
        fail(promiseToHandle, onUnhandledError);
      }
      Q.timeout = timeout;
      function timeout(promise, ms) {
        var deferred = defer();
        var timeoutId = setTimeout(function () {
            deferred.reject(new Error('Timed out after ' + ms + ' ms'));
          }, ms);
        when(promise, function (value) {
          clearTimeout(timeoutId);
          deferred.resolve(value);
        }, function (exception) {
          clearTimeout(timeoutId);
          deferred.reject(exception);
        });
        return deferred.promise;
      }
      Q.delay = delay;
      function delay(promise, timeout) {
        if (timeout === void 0) {
          timeout = promise;
          promise = void 0;
        }
        var deferred = defer();
        setTimeout(function () {
          deferred.resolve(promise);
        }, timeout);
        return deferred.promise;
      }
      Q.nfapply = nfapply;
      function nfapply(callback, args) {
        var nodeArgs = array_slice(args);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        fapply(callback, nodeArgs).fail(deferred.reject);
        return deferred.promise;
      }
      Q.nfcall = nfcall;
      function nfcall(callback) {
        var nodeArgs = array_slice(arguments, 1);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        fapply(callback, nodeArgs).fail(deferred.reject);
        return deferred.promise;
      }
      Q.nfbind = nfbind;
      Q.denodeify = Q.nfbind;
      function nfbind(callback) {
        var baseArgs = array_slice(arguments, 1);
        return function () {
          var nodeArgs = baseArgs.concat(array_slice(arguments));
          var deferred = defer();
          nodeArgs.push(deferred.makeNodeResolver());
          fapply(callback, nodeArgs).fail(deferred.reject);
          return deferred.promise;
        };
      }
      Q.nbind = nbind;
      function nbind(callback) {
        var baseArgs = array_slice(arguments, 1);
        return function () {
          var nodeArgs = baseArgs.concat(array_slice(arguments));
          var deferred = defer();
          nodeArgs.push(deferred.makeNodeResolver());
          var thisArg = this;
          function bound() {
            return callback.apply(thisArg, arguments);
          }
          fapply(bound, nodeArgs).fail(deferred.reject);
          return deferred.promise;
        };
      }
      Q.npost = npost;
      function npost(object, name, args) {
        var nodeArgs = array_slice(args || []);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        post(object, name, nodeArgs).fail(deferred.reject);
        return deferred.promise;
      }
      Q.nsend = nsend;
      Q.ninvoke = Q.nsend;
      function nsend(object, name) {
        var nodeArgs = array_slice(arguments, 2);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        post(object, name, nodeArgs).fail(deferred.reject);
        return deferred.promise;
      }
      Q.nodeify = nodeify;
      function nodeify(promise, nodeback) {
        if (nodeback) {
          promise.then(function (value) {
            nextTick(function () {
              nodeback(null, value);
            });
          }, function (error) {
            nextTick(function () {
              nodeback(error);
            });
          });
        } else {
          return promise;
        }
      }
      var qEndingLine = captureLine();
      return Q;
    }));
  });
  require.define('/../node_modules/lodash/dist/lodash.js', function (module, exports, __dirname, __filename) {
    ;
    (function (window) {
      var undefined;
      var arrayPool = [], objectPool = [];
      var idCounter = 0;
      var indicatorObject = {};
      var keyPrefix = +new Date + '';
      var largeArraySize = 75;
      var maxPoolSize = 40;
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reInterpolate = /<%=([\s\S]+?)%>/g;
      var reThis = (reThis = /\bthis\b/) && reThis.test(runInContext) && reThis;
      var whitespace = ' \t\x0B\f\xa0\ufeff' + '\n\r\u2028\u2029' + '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000';
      var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');
      var reNoMatch = /($^)/;
      var reUnescapedHtml = /[&<>"']/g;
      var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
      var contextProps = [
          'Array',
          'Boolean',
          'Date',
          'Function',
          'Math',
          'Number',
          'Object',
          'RegExp',
          'String',
          '_',
          'attachEvent',
          'clearTimeout',
          'isFinite',
          'isNaN',
          'parseInt',
          'setImmediate',
          'setTimeout'
        ];
      var templateCounter = 0;
      var argsClass = '[object Arguments]', arrayClass = '[object Array]', boolClass = '[object Boolean]', dateClass = '[object Date]', errorClass = '[object Error]', funcClass = '[object Function]', numberClass = '[object Number]', objectClass = '[object Object]', regexpClass = '[object RegExp]', stringClass = '[object String]';
      var cloneableClasses = {};
      cloneableClasses[funcClass] = false;
      cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
      var objectTypes = {
          'boolean': false,
          'function': true,
          'object': true,
          'number': false,
          'string': false,
          'undefined': false
        };
      var stringEscapes = {
          '\\': '\\',
          "'": "'",
          '\n': 'n',
          '\r': 'r',
          '\t': 't',
          '\u2028': 'u2028',
          '\u2029': 'u2029'
        };
      var freeExports = objectTypes[typeof exports] && exports;
      var freeModule = objectTypes[typeof module] && module && module.exports == freeExports && module;
      var freeGlobal = objectTypes[typeof global] && global;
      if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
        window = freeGlobal;
      }
      function basicIndexOf(array, value, fromIndex) {
        var index = (fromIndex || 0) - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function cacheIndexOf(cache, value) {
        var type = typeof value;
        cache = cache.cache;
        if (type == 'boolean' || value == null) {
          return cache[value];
        }
        if (type != 'number' && type != 'string') {
          type = 'object';
        }
        var key = type == 'number' ? value : keyPrefix + value;
        cache = cache[type] || (cache[type] = {});
        return type == 'object' ? cache[key] && basicIndexOf(cache[key], value) > -1 ? 0 : -1 : cache[key] ? 0 : -1;
      }
      function cachePush(value) {
        var cache = this.cache, type = typeof value;
        if (type == 'boolean' || value == null) {
          cache[value] = true;
        } else {
          if (type != 'number' && type != 'string') {
            type = 'object';
          }
          var key = type == 'number' ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
          if (type == 'object') {
            if ((typeCache[key] || (typeCache[key] = [])).push(value) == this.array.length) {
              cache[type] = false;
            }
          } else {
            typeCache[key] = true;
          }
        }
      }
      function charAtCallback(value) {
        return value.charCodeAt(0);
      }
      function compareAscending(a, b) {
        var ai = a.index, bi = b.index;
        a = a.criteria;
        b = b.criteria;
        if (a !== b) {
          if (a > b || typeof a == 'undefined') {
            return 1;
          }
          if (a < b || typeof b == 'undefined') {
            return -1;
          }
        }
        return ai < bi ? -1 : 1;
      }
      function createCache(array) {
        var index = -1, length = array.length;
        var cache = getObject();
        cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;
        var result = getObject();
        result.array = array;
        result.cache = cache;
        result.push = cachePush;
        while (++index < length) {
          result.push(array[index]);
        }
        return cache.object === false ? (releaseObject(result), null) : result;
      }
      function escapeStringChar(match) {
        return '\\' + stringEscapes[match];
      }
      function getArray() {
        return arrayPool.pop() || [];
      }
      function getObject() {
        return objectPool.pop() || {
          'array': null,
          'cache': null,
          'criteria': null,
          'false': false,
          'index': 0,
          'leading': false,
          'maxWait': 0,
          'null': false,
          'number': null,
          'object': null,
          'push': null,
          'string': null,
          'trailing': false,
          'true': false,
          'undefined': false,
          'value': null
        };
      }
      function noop() {
      }
      function releaseArray(array) {
        array.length = 0;
        if (arrayPool.length < maxPoolSize) {
          arrayPool.push(array);
        }
      }
      function releaseObject(object) {
        var cache = object.cache;
        if (cache) {
          releaseObject(cache);
        }
        object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
        if (objectPool.length < maxPoolSize) {
          objectPool.push(object);
        }
      }
      function slice(array, start, end) {
        start || (start = 0);
        if (typeof end == 'undefined') {
          end = array ? array.length : 0;
        }
        var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
        while (++index < length) {
          result[index] = array[start + index];
        }
        return result;
      }
      function runInContext(context) {
        context = context ? _.defaults(window.Object(), context, _.pick(window, contextProps)) : window;
        var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
        var arrayRef = [];
        var objectProto = Object.prototype, stringProto = String.prototype;
        var oldDash = context._;
        var reNative = RegExp('^' + String(objectProto.valueOf).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/valueOf|for [^\]]+/g, '.+?') + '$');
        var ceil = Math.ceil, clearTimeout = context.clearTimeout, concat = arrayRef.concat, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = reNative.test(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, propertyIsEnumerable = objectProto.propertyIsEnumerable, setImmediate = context.setImmediate, setTimeout = context.setTimeout, toString = objectProto.toString;
        var nativeBind = reNative.test(nativeBind = toString.bind) && nativeBind, nativeCreate = reNative.test(nativeCreate = Object.create) && nativeCreate, nativeIsArray = reNative.test(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = reNative.test(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeSlice = arrayRef.slice;
        var isIeOpera = reNative.test(context.attachEvent), isV8 = nativeBind && !/\n|true/.test(nativeBind + isIeOpera);
        var ctorByClass = {};
        ctorByClass[arrayClass] = Array;
        ctorByClass[boolClass] = Boolean;
        ctorByClass[dateClass] = Date;
        ctorByClass[funcClass] = Function;
        ctorByClass[objectClass] = Object;
        ctorByClass[numberClass] = Number;
        ctorByClass[regexpClass] = RegExp;
        ctorByClass[stringClass] = String;
        function lodash(value) {
          return value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__') ? value : new lodashWrapper(value);
        }
        function lodashWrapper(value) {
          this.__wrapped__ = value;
        }
        lodashWrapper.prototype = lodash.prototype;
        var support = lodash.support = {};
        support.fastBind = nativeBind && !isV8;
        lodash.templateSettings = {
          'escape': /<%-([\s\S]+?)%>/g,
          'evaluate': /<%([\s\S]+?)%>/g,
          'interpolate': reInterpolate,
          'variable': '',
          'imports': { '_': lodash }
        };
        function createBound(func, thisArg, partialArgs, indicator) {
          var isFunc = isFunction(func), isPartial = !partialArgs, key = thisArg;
          if (isPartial) {
            var rightIndicator = indicator;
            partialArgs = thisArg;
          } else if (!isFunc) {
            if (!indicator) {
              throw new TypeError;
            }
            thisArg = func;
          }
          function bound() {
            var args = arguments, thisBinding = isPartial ? this : thisArg;
            if (!isFunc) {
              func = thisArg[key];
            }
            if (partialArgs.length) {
              args = args.length ? (args = nativeSlice.call(args), rightIndicator ? args.concat(partialArgs) : partialArgs.concat(args)) : partialArgs;
            }
            if (this instanceof bound) {
              thisBinding = createObject(func.prototype);
              var result = func.apply(thisBinding, args);
              return isObject(result) ? result : thisBinding;
            }
            return func.apply(thisBinding, args);
          }
          return bound;
        }
        function createObject(prototype) {
          return isObject(prototype) ? nativeCreate(prototype) : {};
        }
        function escapeHtmlChar(match) {
          return htmlEscapes[match];
        }
        function getIndexOf(array, value, fromIndex) {
          var result = (result = lodash.indexOf) === indexOf ? basicIndexOf : result;
          return result;
        }
        function overloadWrapper(func) {
          return function (array, flag, callback, thisArg) {
            if (typeof flag != 'boolean' && flag != null) {
              thisArg = callback;
              callback = !(thisArg && thisArg[flag] === array) ? flag : undefined;
              flag = false;
            }
            if (callback != null) {
              callback = lodash.createCallback(callback, thisArg);
            }
            return func(array, flag, callback, thisArg);
          };
        }
        function shimIsPlainObject(value) {
          var ctor, result;
          if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
            return false;
          }
          forIn(value, function (value, key) {
            result = key;
          });
          return result === undefined || hasOwnProperty.call(value, result);
        }
        function unescapeHtmlChar(match) {
          return htmlUnescapes[match];
        }
        function isArguments(value) {
          return toString.call(value) == argsClass;
        }
        var isArray = nativeIsArray;
        var shimKeys = function (object) {
          var index, iterable = object, result = [];
          if (!iterable)
            return result;
          if (!objectTypes[typeof object])
            return result;
          for (index in iterable) {
            if (hasOwnProperty.call(iterable, index)) {
              result.push(index);
            }
          }
          return result;
        };
        var keys = !nativeKeys ? shimKeys : function (object) {
            if (!isObject(object)) {
              return [];
            }
            return nativeKeys(object);
          };
        var htmlEscapes = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
          };
        var htmlUnescapes = invert(htmlEscapes);
        var assign = function (object, source, guard) {
          var index, iterable = object, result = iterable;
          if (!iterable)
            return result;
          var args = arguments, argsIndex = 0, argsLength = typeof guard == 'number' ? 2 : args.length;
          if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
            var callback = lodash.createCallback(args[--argsLength - 1], args[argsLength--], 2);
          } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
            callback = args[--argsLength];
          }
          while (++argsIndex < argsLength) {
            iterable = args[argsIndex];
            if (iterable && objectTypes[typeof iterable]) {
              var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
              while (++ownIndex < length) {
                index = ownProps[ownIndex];
                result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
              }
            }
          }
          return result;
        };
        function clone(value, deep, callback, thisArg, stackA, stackB) {
          var result = value;
          if (typeof deep != 'boolean' && deep != null) {
            thisArg = callback;
            callback = deep;
            deep = false;
          }
          if (typeof callback == 'function') {
            callback = typeof thisArg == 'undefined' ? callback : lodash.createCallback(callback, thisArg, 1);
            result = callback(result);
            if (typeof result != 'undefined') {
              return result;
            }
            result = value;
          }
          var isObj = isObject(result);
          if (isObj) {
            var className = toString.call(result);
            if (!cloneableClasses[className]) {
              return result;
            }
            var isArr = isArray(result);
          }
          if (!isObj || !deep) {
            return isObj ? isArr ? slice(result) : assign({}, result) : result;
          }
          var ctor = ctorByClass[className];
          switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+result);
          case numberClass:
          case stringClass:
            return new ctor(result);
          case regexpClass:
            return ctor(result.source, reFlags.exec(result));
          }
          var initedStack = !stackA;
          stackA || (stackA = getArray());
          stackB || (stackB = getArray());
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == value) {
              return stackB[length];
            }
          }
          result = isArr ? ctor(result.length) : {};
          if (isArr) {
            if (hasOwnProperty.call(value, 'index')) {
              result.index = value.index;
            }
            if (hasOwnProperty.call(value, 'input')) {
              result.input = value.input;
            }
          }
          stackA.push(value);
          stackB.push(result);
          (isArr ? forEach : forOwn)(value, function (objValue, key) {
            result[key] = clone(objValue, deep, callback, undefined, stackA, stackB);
          });
          if (initedStack) {
            releaseArray(stackA);
            releaseArray(stackB);
          }
          return result;
        }
        function cloneDeep(value, callback, thisArg) {
          return clone(value, true, callback, thisArg);
        }
        var defaults = function (object, source, guard) {
          var index, iterable = object, result = iterable;
          if (!iterable)
            return result;
          var args = arguments, argsIndex = 0, argsLength = typeof guard == 'number' ? 2 : args.length;
          while (++argsIndex < argsLength) {
            iterable = args[argsIndex];
            if (iterable && objectTypes[typeof iterable]) {
              var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
              while (++ownIndex < length) {
                index = ownProps[ownIndex];
                if (typeof result[index] == 'undefined')
                  result[index] = iterable[index];
              }
            }
          }
          return result;
        };
        function findKey(object, callback, thisArg) {
          var result;
          callback = lodash.createCallback(callback, thisArg);
          forOwn(object, function (value, key, object) {
            if (callback(value, key, object)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        var forIn = function (collection, callback, thisArg) {
          var index, iterable = collection, result = iterable;
          if (!iterable)
            return result;
          if (!objectTypes[typeof iterable])
            return result;
          callback = callback && typeof thisArg == 'undefined' ? callback : lodash.createCallback(callback, thisArg);
          for (index in iterable) {
            if (callback(iterable[index], index, collection) === false)
              return result;
          }
          return result;
        };
        var forOwn = function (collection, callback, thisArg) {
          var index, iterable = collection, result = iterable;
          if (!iterable)
            return result;
          if (!objectTypes[typeof iterable])
            return result;
          callback = callback && typeof thisArg == 'undefined' ? callback : lodash.createCallback(callback, thisArg);
          var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
          while (++ownIndex < length) {
            index = ownProps[ownIndex];
            if (callback(iterable[index], index, collection) === false)
              return result;
          }
          return result;
        };
        function functions(object) {
          var result = [];
          forIn(object, function (value, key) {
            if (isFunction(value)) {
              result.push(key);
            }
          });
          return result.sort();
        }
        function has(object, property) {
          return object ? hasOwnProperty.call(object, property) : false;
        }
        function invert(object) {
          var index = -1, props = keys(object), length = props.length, result = {};
          while (++index < length) {
            var key = props[index];
            result[object[key]] = key;
          }
          return result;
        }
        function isBoolean(value) {
          return value === true || value === false || toString.call(value) == boolClass;
        }
        function isDate(value) {
          return value ? typeof value == 'object' && toString.call(value) == dateClass : false;
        }
        function isElement(value) {
          return value ? value.nodeType === 1 : false;
        }
        function isEmpty(value) {
          var result = true;
          if (!value) {
            return result;
          }
          var className = toString.call(value), length = value.length;
          if (className == arrayClass || className == stringClass || className == argsClass || className == objectClass && typeof length == 'number' && isFunction(value.splice)) {
            return !length;
          }
          forOwn(value, function () {
            return result = false;
          });
          return result;
        }
        function isEqual(a, b, callback, thisArg, stackA, stackB) {
          var whereIndicator = callback === indicatorObject;
          if (typeof callback == 'function' && !whereIndicator) {
            callback = lodash.createCallback(callback, thisArg, 2);
            var result = callback(a, b);
            if (typeof result != 'undefined') {
              return !!result;
            }
          }
          if (a === b) {
            return a !== 0 || 1 / a == 1 / b;
          }
          var type = typeof a, otherType = typeof b;
          if (a === a && (!a || type != 'function' && type != 'object') && (!b || otherType != 'function' && otherType != 'object')) {
            return false;
          }
          if (a == null || b == null) {
            return a === b;
          }
          var className = toString.call(a), otherClass = toString.call(b);
          if (className == argsClass) {
            className = objectClass;
          }
          if (otherClass == argsClass) {
            otherClass = objectClass;
          }
          if (className != otherClass) {
            return false;
          }
          switch (className) {
          case boolClass:
          case dateClass:
            return +a == +b;
          case numberClass:
            return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
          case regexpClass:
          case stringClass:
            return a == String(b);
          }
          var isArr = className == arrayClass;
          if (!isArr) {
            if (hasOwnProperty.call(a, '__wrapped__ ') || hasOwnProperty.call(b, '__wrapped__')) {
              return isEqual(a.__wrapped__ || a, b.__wrapped__ || b, callback, thisArg, stackA, stackB);
            }
            if (className != objectClass) {
              return false;
            }
            var ctorA = a.constructor, ctorB = b.constructor;
            if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB)) {
              return false;
            }
          }
          var initedStack = !stackA;
          stackA || (stackA = getArray());
          stackB || (stackB = getArray());
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == a) {
              return stackB[length] == b;
            }
          }
          var size = 0;
          result = true;
          stackA.push(a);
          stackB.push(b);
          if (isArr) {
            length = a.length;
            size = b.length;
            result = size == a.length;
            if (!result && !whereIndicator) {
              return result;
            }
            while (size--) {
              var index = length, value = b[size];
              if (whereIndicator) {
                while (index--) {
                  if (result = isEqual(a[index], value, callback, thisArg, stackA, stackB)) {
                    break;
                  }
                }
              } else if (!(result = isEqual(a[size], value, callback, thisArg, stackA, stackB))) {
                break;
              }
            }
            return result;
          }
          forIn(b, function (value, key, b) {
            if (hasOwnProperty.call(b, key)) {
              size++;
              return result = hasOwnProperty.call(a, key) && isEqual(a[key], value, callback, thisArg, stackA, stackB);
            }
          });
          if (result && !whereIndicator) {
            forIn(a, function (value, key, a) {
              if (hasOwnProperty.call(a, key)) {
                return result = --size > -1;
              }
            });
          }
          if (initedStack) {
            releaseArray(stackA);
            releaseArray(stackB);
          }
          return result;
        }
        function isFinite(value) {
          return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
        }
        function isFunction(value) {
          return typeof value == 'function';
        }
        function isObject(value) {
          return !!(value && objectTypes[typeof value]);
        }
        function isNaN(value) {
          return isNumber(value) && value != +value;
        }
        function isNull(value) {
          return value === null;
        }
        function isNumber(value) {
          return typeof value == 'number' || toString.call(value) == numberClass;
        }
        var isPlainObject = function (value) {
          if (!(value && toString.call(value) == objectClass)) {
            return false;
          }
          var valueOf = value.valueOf, objProto = typeof valueOf == 'function' && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
          return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
        };
        function isRegExp(value) {
          return value ? typeof value == 'object' && toString.call(value) == regexpClass : false;
        }
        function isString(value) {
          return typeof value == 'string' || toString.call(value) == stringClass;
        }
        function isUndefined(value) {
          return typeof value == 'undefined';
        }
        function merge(object, source, deepIndicator) {
          var args = arguments, index = 0, length = 2;
          if (!isObject(object)) {
            return object;
          }
          if (deepIndicator === indicatorObject) {
            var callback = args[3], stackA = args[4], stackB = args[5];
          } else {
            var initedStack = true;
            stackA = getArray();
            stackB = getArray();
            if (typeof deepIndicator != 'number') {
              length = args.length;
            }
            if (length > 3 && typeof args[length - 2] == 'function') {
              callback = lodash.createCallback(args[--length - 1], args[length--], 2);
            } else if (length > 2 && typeof args[length - 1] == 'function') {
              callback = args[--length];
            }
          }
          while (++index < length) {
            (isArray(args[index]) ? forEach : forOwn)(args[index], function (source, key) {
              var found, isArr, result = source, value = object[key];
              if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                var stackLength = stackA.length;
                while (stackLength--) {
                  if (found = stackA[stackLength] == source) {
                    value = stackB[stackLength];
                    break;
                  }
                }
                if (!found) {
                  var isShallow;
                  if (callback) {
                    result = callback(value, source);
                    if (isShallow = typeof result != 'undefined') {
                      value = result;
                    }
                  }
                  if (!isShallow) {
                    value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
                  }
                  stackA.push(source);
                  stackB.push(value);
                  if (!isShallow) {
                    value = merge(value, source, indicatorObject, callback, stackA, stackB);
                  }
                }
              } else {
                if (callback) {
                  result = callback(value, source);
                  if (typeof result == 'undefined') {
                    result = source;
                  }
                }
                if (typeof result != 'undefined') {
                  value = result;
                }
              }
              object[key] = value;
            });
          }
          if (initedStack) {
            releaseArray(stackA);
            releaseArray(stackB);
          }
          return object;
        }
        function omit(object, callback, thisArg) {
          var indexOf = getIndexOf(), isFunc = typeof callback == 'function', result = {};
          if (isFunc) {
            callback = lodash.createCallback(callback, thisArg);
          } else {
            var props = concat.apply(arrayRef, nativeSlice.call(arguments, 1));
          }
          forIn(object, function (value, key, object) {
            if (isFunc ? !callback(value, key, object) : indexOf(props, key) < 0) {
              result[key] = value;
            }
          });
          return result;
        }
        function pairs(object) {
          var index = -1, props = keys(object), length = props.length, result = Array(length);
          while (++index < length) {
            var key = props[index];
            result[index] = [
              key,
              object[key]
            ];
          }
          return result;
        }
        function pick(object, callback, thisArg) {
          var result = {};
          if (typeof callback != 'function') {
            var index = -1, props = concat.apply(arrayRef, nativeSlice.call(arguments, 1)), length = isObject(object) ? props.length : 0;
            while (++index < length) {
              var key = props[index];
              if (key in object) {
                result[key] = object[key];
              }
            }
          } else {
            callback = lodash.createCallback(callback, thisArg);
            forIn(object, function (value, key, object) {
              if (callback(value, key, object)) {
                result[key] = value;
              }
            });
          }
          return result;
        }
        function transform(object, callback, accumulator, thisArg) {
          var isArr = isArray(object);
          callback = lodash.createCallback(callback, thisArg, 4);
          if (accumulator == null) {
            if (isArr) {
              accumulator = [];
            } else {
              var ctor = object && object.constructor, proto = ctor && ctor.prototype;
              accumulator = createObject(proto);
            }
          }
          (isArr ? forEach : forOwn)(object, function (value, index, object) {
            return callback(accumulator, value, index, object);
          });
          return accumulator;
        }
        function values(object) {
          var index = -1, props = keys(object), length = props.length, result = Array(length);
          while (++index < length) {
            result[index] = object[props[index]];
          }
          return result;
        }
        function at(collection) {
          var index = -1, props = concat.apply(arrayRef, nativeSlice.call(arguments, 1)), length = props.length, result = Array(length);
          while (++index < length) {
            result[index] = collection[props[index]];
          }
          return result;
        }
        function contains(collection, target, fromIndex) {
          var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = false;
          fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
          if (length && typeof length == 'number') {
            result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
          } else {
            forOwn(collection, function (value) {
              if (++index >= fromIndex) {
                return !(result = value === target);
              }
            });
          }
          return result;
        }
        function countBy(collection, callback, thisArg) {
          var result = {};
          callback = lodash.createCallback(callback, thisArg);
          forEach(collection, function (value, key, collection) {
            key = String(callback(value, key, collection));
            hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
          });
          return result;
        }
        function every(collection, callback, thisArg) {
          var result = true;
          callback = lodash.createCallback(callback, thisArg);
          var index = -1, length = collection ? collection.length : 0;
          if (typeof length == 'number') {
            while (++index < length) {
              if (!(result = !!callback(collection[index], index, collection))) {
                break;
              }
            }
          } else {
            forOwn(collection, function (value, index, collection) {
              return result = !!callback(value, index, collection);
            });
          }
          return result;
        }
        function filter(collection, callback, thisArg) {
          var result = [];
          callback = lodash.createCallback(callback, thisArg);
          var index = -1, length = collection ? collection.length : 0;
          if (typeof length == 'number') {
            while (++index < length) {
              var value = collection[index];
              if (callback(value, index, collection)) {
                result.push(value);
              }
            }
          } else {
            forOwn(collection, function (value, index, collection) {
              if (callback(value, index, collection)) {
                result.push(value);
              }
            });
          }
          return result;
        }
        function find(collection, callback, thisArg) {
          callback = lodash.createCallback(callback, thisArg);
          var index = -1, length = collection ? collection.length : 0;
          if (typeof length == 'number') {
            while (++index < length) {
              var value = collection[index];
              if (callback(value, index, collection)) {
                return value;
              }
            }
          } else {
            var result;
            forOwn(collection, function (value, index, collection) {
              if (callback(value, index, collection)) {
                result = value;
                return false;
              }
            });
            return result;
          }
        }
        function forEach(collection, callback, thisArg) {
          var index = -1, length = collection ? collection.length : 0;
          callback = callback && typeof thisArg == 'undefined' ? callback : lodash.createCallback(callback, thisArg);
          if (typeof length == 'number') {
            while (++index < length) {
              if (callback(collection[index], index, collection) === false) {
                break;
              }
            }
          } else {
            forOwn(collection, callback);
          }
          return collection;
        }
        function groupBy(collection, callback, thisArg) {
          var result = {};
          callback = lodash.createCallback(callback, thisArg);
          forEach(collection, function (value, key, collection) {
            key = String(callback(value, key, collection));
            (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
          });
          return result;
        }
        function invoke(collection, methodName) {
          var args = nativeSlice.call(arguments, 2), index = -1, isFunc = typeof methodName == 'function', length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
          forEach(collection, function (value) {
            result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
          });
          return result;
        }
        function map(collection, callback, thisArg) {
          var index = -1, length = collection ? collection.length : 0;
          callback = lodash.createCallback(callback, thisArg);
          if (typeof length == 'number') {
            var result = Array(length);
            while (++index < length) {
              result[index] = callback(collection[index], index, collection);
            }
          } else {
            result = [];
            forOwn(collection, function (value, key, collection) {
              result[++index] = callback(value, key, collection);
            });
          }
          return result;
        }
        function max(collection, callback, thisArg) {
          var computed = -Infinity, result = computed;
          if (!callback && isArray(collection)) {
            var index = -1, length = collection.length;
            while (++index < length) {
              var value = collection[index];
              if (value > result) {
                result = value;
              }
            }
          } else {
            callback = !callback && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg);
            forEach(collection, function (value, index, collection) {
              var current = callback(value, index, collection);
              if (current > computed) {
                computed = current;
                result = value;
              }
            });
          }
          return result;
        }
        function min(collection, callback, thisArg) {
          var computed = Infinity, result = computed;
          if (!callback && isArray(collection)) {
            var index = -1, length = collection.length;
            while (++index < length) {
              var value = collection[index];
              if (value < result) {
                result = value;
              }
            }
          } else {
            callback = !callback && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg);
            forEach(collection, function (value, index, collection) {
              var current = callback(value, index, collection);
              if (current < computed) {
                computed = current;
                result = value;
              }
            });
          }
          return result;
        }
        function pluck(collection, property) {
          var index = -1, length = collection ? collection.length : 0;
          if (typeof length == 'number') {
            var result = Array(length);
            while (++index < length) {
              result[index] = collection[index][property];
            }
          }
          return result || map(collection, property);
        }
        function reduce(collection, callback, accumulator, thisArg) {
          if (!collection)
            return accumulator;
          var noaccum = arguments.length < 3;
          callback = lodash.createCallback(callback, thisArg, 4);
          var index = -1, length = collection.length;
          if (typeof length == 'number') {
            if (noaccum) {
              accumulator = collection[++index];
            }
            while (++index < length) {
              accumulator = callback(accumulator, collection[index], index, collection);
            }
          } else {
            forOwn(collection, function (value, index, collection) {
              accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
            });
          }
          return accumulator;
        }
        function reduceRight(collection, callback, accumulator, thisArg) {
          var iterable = collection, length = collection ? collection.length : 0, noaccum = arguments.length < 3;
          if (typeof length != 'number') {
            var props = keys(collection);
            length = props.length;
          }
          callback = lodash.createCallback(callback, thisArg, 4);
          forEach(collection, function (value, index, collection) {
            index = props ? props[--length] : --length;
            accumulator = noaccum ? (noaccum = false, iterable[index]) : callback(accumulator, iterable[index], index, collection);
          });
          return accumulator;
        }
        function reject(collection, callback, thisArg) {
          callback = lodash.createCallback(callback, thisArg);
          return filter(collection, function (value, index, collection) {
            return !callback(value, index, collection);
          });
        }
        function shuffle(collection) {
          var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
          forEach(collection, function (value) {
            var rand = floor(nativeRandom() * (++index + 1));
            result[index] = result[rand];
            result[rand] = value;
          });
          return result;
        }
        function size(collection) {
          var length = collection ? collection.length : 0;
          return typeof length == 'number' ? length : keys(collection).length;
        }
        function some(collection, callback, thisArg) {
          var result;
          callback = lodash.createCallback(callback, thisArg);
          var index = -1, length = collection ? collection.length : 0;
          if (typeof length == 'number') {
            while (++index < length) {
              if (result = callback(collection[index], index, collection)) {
                break;
              }
            }
          } else {
            forOwn(collection, function (value, index, collection) {
              return !(result = callback(value, index, collection));
            });
          }
          return !!result;
        }
        function sortBy(collection, callback, thisArg) {
          var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
          callback = lodash.createCallback(callback, thisArg);
          forEach(collection, function (value, key, collection) {
            var object = result[++index] = getObject();
            object.criteria = callback(value, key, collection);
            object.index = index;
            object.value = value;
          });
          length = result.length;
          result.sort(compareAscending);
          while (length--) {
            var object = result[length];
            result[length] = object.value;
            releaseObject(object);
          }
          return result;
        }
        function toArray(collection) {
          if (collection && typeof collection.length == 'number') {
            return slice(collection);
          }
          return values(collection);
        }
        var where = filter;
        function compact(array) {
          var index = -1, length = array ? array.length : 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result.push(value);
            }
          }
          return result;
        }
        function difference(array) {
          var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, seen = concat.apply(arrayRef, nativeSlice.call(arguments, 1)), result = [];
          var isLarge = length >= largeArraySize && indexOf === basicIndexOf;
          if (isLarge) {
            var cache = createCache(seen);
            if (cache) {
              indexOf = cacheIndexOf;
              seen = cache;
            } else {
              isLarge = false;
            }
          }
          while (++index < length) {
            var value = array[index];
            if (indexOf(seen, value) < 0) {
              result.push(value);
            }
          }
          if (isLarge) {
            releaseObject(seen);
          }
          return result;
        }
        function findIndex(array, callback, thisArg) {
          var index = -1, length = array ? array.length : 0;
          callback = lodash.createCallback(callback, thisArg);
          while (++index < length) {
            if (callback(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function first(array, callback, thisArg) {
          if (array) {
            var n = 0, length = array.length;
            if (typeof callback != 'number' && callback != null) {
              var index = -1;
              callback = lodash.createCallback(callback, thisArg);
              while (++index < length && callback(array[index], index, array)) {
                n++;
              }
            } else {
              n = callback;
              if (n == null || thisArg) {
                return array[0];
              }
            }
            return slice(array, 0, nativeMin(nativeMax(0, n), length));
          }
        }
        var flatten = overloadWrapper(function flatten(array, isShallow, callback) {
            var index = -1, length = array ? array.length : 0, result = [];
            while (++index < length) {
              var value = array[index];
              if (callback) {
                value = callback(value, index, array);
              }
              if (isArray(value)) {
                push.apply(result, isShallow ? value : flatten(value));
              } else {
                result.push(value);
              }
            }
            return result;
          });
        function indexOf(array, value, fromIndex) {
          if (typeof fromIndex == 'number') {
            var length = array ? array.length : 0;
            fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
          } else if (fromIndex) {
            var index = sortedIndex(array, value);
            return array[index] === value ? index : -1;
          }
          return array ? basicIndexOf(array, value, fromIndex) : -1;
        }
        function initial(array, callback, thisArg) {
          if (!array) {
            return [];
          }
          var n = 0, length = array.length;
          if (typeof callback != 'number' && callback != null) {
            var index = length;
            callback = lodash.createCallback(callback, thisArg);
            while (index-- && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = callback == null || thisArg ? 1 : callback || n;
          }
          return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
        }
        function intersection(array) {
          var args = arguments, argsLength = args.length, argsIndex = -1, caches = getArray(), index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [], seen = getArray();
          while (++argsIndex < argsLength) {
            var value = args[argsIndex];
            caches[argsIndex] = indexOf === basicIndexOf && (value ? value.length : 0) >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen);
          }
          outer:
            while (++index < length) {
              var cache = caches[0];
              value = array[index];
              if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                argsIndex = argsLength;
                (cache || seen).push(value);
                while (--argsIndex) {
                  cache = caches[argsIndex];
                  if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                    continue outer;
                  }
                }
                result.push(value);
              }
            }
          while (argsLength--) {
            cache = caches[argsLength];
            if (cache) {
              releaseObject(cache);
            }
          }
          releaseArray(caches);
          releaseArray(seen);
          return result;
        }
        function last(array, callback, thisArg) {
          if (array) {
            var n = 0, length = array.length;
            if (typeof callback != 'number' && callback != null) {
              var index = length;
              callback = lodash.createCallback(callback, thisArg);
              while (index-- && callback(array[index], index, array)) {
                n++;
              }
            } else {
              n = callback;
              if (n == null || thisArg) {
                return array[length - 1];
              }
            }
            return slice(array, nativeMax(0, length - n));
          }
        }
        function lastIndexOf(array, value, fromIndex) {
          var index = array ? array.length : 0;
          if (typeof fromIndex == 'number') {
            index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function range(start, end, step) {
          start = +start || 0;
          step = +step || 1;
          if (end == null) {
            end = start;
            start = 0;
          }
          var index = -1, length = nativeMax(0, ceil((end - start) / step)), result = Array(length);
          while (++index < length) {
            result[index] = start;
            start += step;
          }
          return result;
        }
        function rest(array, callback, thisArg) {
          if (typeof callback != 'number' && callback != null) {
            var n = 0, index = -1, length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg);
            while (++index < length && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = callback == null || thisArg ? 1 : nativeMax(0, callback);
          }
          return slice(array, n);
        }
        function sortedIndex(array, value, callback, thisArg) {
          var low = 0, high = array ? array.length : low;
          callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
          value = callback(value);
          while (low < high) {
            var mid = low + high >>> 1;
            callback(array[mid]) < value ? low = mid + 1 : high = mid;
          }
          return low;
        }
        function union(array) {
          if (!isArray(array)) {
            arguments[0] = array ? nativeSlice.call(array) : arrayRef;
          }
          return uniq(concat.apply(arrayRef, arguments));
        }
        var uniq = overloadWrapper(function (array, isSorted, callback) {
            var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [];
            var isLarge = !isSorted && length >= largeArraySize && indexOf === basicIndexOf, seen = callback || isLarge ? getArray() : result;
            if (isLarge) {
              var cache = createCache(seen);
              if (cache) {
                indexOf = cacheIndexOf;
                seen = cache;
              } else {
                isLarge = false;
                seen = callback ? seen : (releaseArray(seen), result);
              }
            }
            while (++index < length) {
              var value = array[index], computed = callback ? callback(value, index, array) : value;
              if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
                if (callback || isLarge) {
                  seen.push(computed);
                }
                result.push(value);
              }
            }
            if (isLarge) {
              releaseArray(seen.array);
              releaseObject(seen);
            } else if (callback) {
              releaseArray(seen);
            }
            return result;
          });
        function unzip(array) {
          var index = -1, length = array ? max(pluck(array, 'length')) : 0, result = Array(length < 0 ? 0 : length);
          while (++index < length) {
            result[index] = pluck(array, index);
          }
          return result;
        }
        function without(array) {
          return difference(array, nativeSlice.call(arguments, 1));
        }
        function zip(array) {
          return array ? unzip(arguments) : [];
        }
        function zipObject(keys, values) {
          var index = -1, length = keys ? keys.length : 0, result = {};
          while (++index < length) {
            var key = keys[index];
            if (values) {
              result[key] = values[index];
            } else {
              result[key[0]] = key[1];
            }
          }
          return result;
        }
        function after(n, func) {
          if (n < 1) {
            return func();
          }
          return function () {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function bind(func, thisArg) {
          return support.fastBind || nativeBind && arguments.length > 2 ? nativeBind.call.apply(nativeBind, arguments) : createBound(func, thisArg, nativeSlice.call(arguments, 2));
        }
        function bindAll(object) {
          var funcs = arguments.length > 1 ? concat.apply(arrayRef, nativeSlice.call(arguments, 1)) : functions(object), index = -1, length = funcs.length;
          while (++index < length) {
            var key = funcs[index];
            object[key] = bind(object[key], object);
          }
          return object;
        }
        function bindKey(object, key) {
          return createBound(object, key, nativeSlice.call(arguments, 2), indicatorObject);
        }
        function compose() {
          var funcs = arguments;
          return function () {
            var args = arguments, length = funcs.length;
            while (length--) {
              args = [funcs[length].apply(this, args)];
            }
            return args[0];
          };
        }
        function createCallback(func, thisArg, argCount) {
          if (func == null) {
            return identity;
          }
          var type = typeof func;
          if (type != 'function') {
            if (type != 'object') {
              return function (object) {
                return object[func];
              };
            }
            var props = keys(func);
            return function (object) {
              var length = props.length, result = false;
              while (length--) {
                if (!(result = isEqual(object[props[length]], func[props[length]], indicatorObject))) {
                  break;
                }
              }
              return result;
            };
          }
          if (typeof thisArg == 'undefined' || reThis && !reThis.test(fnToString.call(func))) {
            return func;
          }
          if (argCount === 1) {
            return function (value) {
              return func.call(thisArg, value);
            };
          }
          if (argCount === 2) {
            return function (a, b) {
              return func.call(thisArg, a, b);
            };
          }
          if (argCount === 4) {
            return function (accumulator, value, index, collection) {
              return func.call(thisArg, accumulator, value, index, collection);
            };
          }
          return function (value, index, collection) {
            return func.call(thisArg, value, index, collection);
          };
        }
        function debounce(func, wait, options) {
          var args, result, thisArg, callCount = 0, lastCalled = 0, maxWait = false, maxTimeoutId = null, timeoutId = null, trailing = true;
          function clear() {
            clearTimeout(maxTimeoutId);
            clearTimeout(timeoutId);
            callCount = 0;
            maxTimeoutId = timeoutId = null;
          }
          function delayed() {
            var isCalled = trailing && (!leading || callCount > 1);
            clear();
            if (isCalled) {
              if (maxWait !== false) {
                lastCalled = new Date;
              }
              result = func.apply(thisArg, args);
            }
          }
          function maxDelayed() {
            clear();
            if (trailing || maxWait !== wait) {
              lastCalled = new Date;
              result = func.apply(thisArg, args);
            }
          }
          wait = nativeMax(0, wait || 0);
          if (options === true) {
            var leading = true;
            trailing = false;
          } else if (isObject(options)) {
            leading = options.leading;
            maxWait = 'maxWait' in options && nativeMax(wait, options.maxWait || 0);
            trailing = 'trailing' in options ? options.trailing : trailing;
          }
          return function () {
            args = arguments;
            thisArg = this;
            callCount++;
            clearTimeout(timeoutId);
            if (maxWait === false) {
              if (leading && callCount < 2) {
                result = func.apply(thisArg, args);
              }
            } else {
              var now = new Date;
              if (!maxTimeoutId && !leading) {
                lastCalled = now;
              }
              var remaining = maxWait - (now - lastCalled);
              if (remaining <= 0) {
                clearTimeout(maxTimeoutId);
                maxTimeoutId = null;
                lastCalled = now;
                result = func.apply(thisArg, args);
              } else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout(maxDelayed, remaining);
              }
            }
            if (wait !== maxWait) {
              timeoutId = setTimeout(delayed, wait);
            }
            return result;
          };
        }
        function defer(func) {
          var args = nativeSlice.call(arguments, 1);
          return setTimeout(function () {
            func.apply(undefined, args);
          }, 1);
        }
        if (isV8 && freeModule && typeof setImmediate == 'function') {
          defer = bind(setImmediate, context);
        }
        function delay(func, wait) {
          var args = nativeSlice.call(arguments, 2);
          return setTimeout(function () {
            func.apply(undefined, args);
          }, wait);
        }
        function memoize(func, resolver) {
          function memoized() {
            var cache = memoized.cache, key = keyPrefix + (resolver ? resolver.apply(this, arguments) : arguments[0]);
            return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
          }
          memoized.cache = {};
          return memoized;
        }
        function once(func) {
          var ran, result;
          return function () {
            if (ran) {
              return result;
            }
            ran = true;
            result = func.apply(this, arguments);
            func = null;
            return result;
          };
        }
        function partial(func) {
          return createBound(func, nativeSlice.call(arguments, 1));
        }
        function partialRight(func) {
          return createBound(func, nativeSlice.call(arguments, 1), null, indicatorObject);
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (options === false) {
            leading = false;
          } else if (isObject(options)) {
            leading = 'leading' in options ? options.leading : leading;
            trailing = 'trailing' in options ? options.trailing : trailing;
          }
          options = getObject();
          options.leading = leading;
          options.maxWait = wait;
          options.trailing = trailing;
          var result = debounce(func, wait, options);
          releaseObject(options);
          return result;
        }
        function wrap(value, wrapper) {
          return function () {
            var args = [value];
            push.apply(args, arguments);
            return wrapper.apply(this, args);
          };
        }
        function escape(string) {
          return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
        }
        function identity(value) {
          return value;
        }
        function mixin(object) {
          forEach(functions(object), function (methodName) {
            var func = lodash[methodName] = object[methodName];
            lodash.prototype[methodName] = function () {
              var value = this.__wrapped__, args = [value];
              push.apply(args, arguments);
              var result = func.apply(lodash, args);
              return value && typeof value == 'object' && value === result ? this : new lodashWrapper(result);
            };
          });
        }
        function noConflict() {
          context._ = oldDash;
          return this;
        }
        var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function (value, radix) {
            return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
          };
        function random(min, max) {
          if (min == null && max == null) {
            max = 1;
          }
          min = +min || 0;
          if (max == null) {
            max = min;
            min = 0;
          } else {
            max = +max || 0;
          }
          var rand = nativeRandom();
          return min % 1 || max % 1 ? min + nativeMin(rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1))), max) : min + floor(rand * (max - min + 1));
        }
        function result(object, property) {
          var value = object ? object[property] : undefined;
          return isFunction(value) ? object[property]() : value;
        }
        function template(text, data, options) {
          var settings = lodash.templateSettings;
          text || (text = '');
          options = defaults({}, options, settings);
          var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
          var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
          text.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = options.variable, hasVariable = variable;
          if (!hasVariable) {
            variable = 'obj';
            source = 'with (' + variable + ') {\n' + source + '\n}\n';
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
          source = 'function(' + variable + ') {\n' + (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
          var sourceURL = '\n/*\n//@ sourceURL=' + (options.sourceURL || '/lodash/template/source[' + templateCounter++ + ']') + '\n*/';
          try {
            var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
          } catch (e) {
            e.source = source;
            throw e;
          }
          if (data) {
            return result(data);
          }
          result.source = source;
          return result;
        }
        function times(n, callback, thisArg) {
          n = (n = +n) > -1 ? n : 0;
          var index = -1, result = Array(n);
          callback = lodash.createCallback(callback, thisArg, 1);
          while (++index < n) {
            result[index] = callback(index);
          }
          return result;
        }
        function unescape(string) {
          return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return String(prefix == null ? '' : prefix) + id;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function wrapperToString() {
          return String(this.__wrapped__);
        }
        function wrapperValueOf() {
          return this.__wrapped__;
        }
        lodash.after = after;
        lodash.assign = assign;
        lodash.at = at;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.compact = compact;
        lodash.compose = compose;
        lodash.countBy = countBy;
        lodash.createCallback = createCallback;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.forEach = forEach;
        lodash.forIn = forIn;
        lodash.forOwn = forOwn;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.map = map;
        lodash.max = max;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.min = min;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.range = range;
        lodash.reject = reject;
        lodash.rest = rest;
        lodash.shuffle = shuffle;
        lodash.sortBy = sortBy;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.unzip = unzip;
        lodash.values = values;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.collect = map;
        lodash.drop = rest;
        lodash.each = forEach;
        lodash.extend = assign;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        mixin(lodash);
        lodash.chain = lodash;
        lodash.prototype.chain = function () {
          return this;
        };
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.contains = contains;
        lodash.escape = escape;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.has = has;
        lodash.identity = identity;
        lodash.indexOf = indexOf;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isNaN = isNaN;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isUndefined = isUndefined;
        lodash.lastIndexOf = lastIndexOf;
        lodash.mixin = mixin;
        lodash.noConflict = noConflict;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.result = result;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.template = template;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.all = every;
        lodash.any = some;
        lodash.detect = find;
        lodash.findWhere = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.include = contains;
        lodash.inject = reduce;
        forOwn(lodash, function (func, methodName) {
          if (!lodash.prototype[methodName]) {
            lodash.prototype[methodName] = function () {
              var args = [this.__wrapped__];
              push.apply(args, arguments);
              return func.apply(lodash, args);
            };
          }
        });
        lodash.first = first;
        lodash.last = last;
        lodash.take = first;
        lodash.head = first;
        forOwn(lodash, function (func, methodName) {
          if (!lodash.prototype[methodName]) {
            lodash.prototype[methodName] = function (callback, thisArg) {
              var result = func(this.__wrapped__, callback, thisArg);
              return callback == null || thisArg && typeof callback != 'function' ? result : new lodashWrapper(result);
            };
          }
        });
        lodash.VERSION = '1.3.1';
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.value = wrapperValueOf;
        lodash.prototype.valueOf = wrapperValueOf;
        forEach([
          'join',
          'pop',
          'shift'
        ], function (methodName) {
          var func = arrayRef[methodName];
          lodash.prototype[methodName] = function () {
            return func.apply(this.__wrapped__, arguments);
          };
        });
        forEach([
          'push',
          'reverse',
          'sort',
          'unshift'
        ], function (methodName) {
          var func = arrayRef[methodName];
          lodash.prototype[methodName] = function () {
            func.apply(this.__wrapped__, arguments);
            return this;
          };
        });
        forEach([
          'concat',
          'slice',
          'splice'
        ], function (methodName) {
          var func = arrayRef[methodName];
          lodash.prototype[methodName] = function () {
            return new lodashWrapper(func.apply(this.__wrapped__, arguments));
          };
        });
        return lodash;
      }
      var _ = runInContext();
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        window._ = _;
        define(function () {
          return _;
        });
      } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          (freeModule.exports = _)._ = _;
        } else {
          freeExports._ = _;
        }
      } else {
        window._ = _;
      }
    }(this));
  });
  require.define('/Elements.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Arrow, Background, Bacon, Blank, CanvasBorder, Circle, Clear, ClickResponse, FirstResponse, FixationCross, Group, KeypressResponse, KineticContext, KineticStimFactory, MousepressResponse, Picture, Prompt, Psy, Q, Rectangle, Response, Sequence, Sound, SpaceKeyResponse, StartButton, Stimulus, Text, Timeout, TypedResponse, doTimer, getTimestamp, position, x, _, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        };
      Psy = require('/PsyCloud.js', module);
      Bacon = require('/lib/Bacon.js', module).Bacon;
      _ = require('/../node_modules/lodash/dist/lodash.js', module);
      Q = require('/../node_modules/q/q.js', module);
      if (typeof window !== 'undefined' && window !== null ? window.performance.now : void 0) {
        console.log('Using high performance timer');
        getTimestamp = function () {
          return window.performance.now();
        };
      } else if (typeof window !== 'undefined' && window !== null ? window.performance.webkitNow : void 0) {
        console.log('Using webkit high performance timer');
        getTimestamp = function () {
          return window.performance.webkitNow();
        };
      } else {
        console.log('Using low performance timer');
        getTimestamp = function () {
          return new Date().getTime();
        };
      }
      doTimer = function (length, resolution, oninstance, oncomplete) {
        var count, instance, speed, start, steps;
        instance = function () {
          var diff;
          if (count++ === steps) {
            return oncomplete(steps, count);
          } else {
            oninstance(steps, count);
            diff = getTimeStamp() - start - count * speed;
            return window.setTimeout(instance, speed - diff);
          }
        };
        steps = length / 100 * (resolution / 10);
        speed = length / steps;
        count = 0;
        start = getTimeStamp();
        return window.setTimeout(instance, speed);
      };
      exports.Response = Response = function () {
        function Response() {
        }
        Response.delay = function (ms, func) {
          return setTimeout(func, ms);
        };
        return Response;
      }();
      exports.Timeout = Timeout = function (_super) {
        __extends(Timeout, _super);
        function Timeout(spec) {
          if (spec == null) {
            spec = {};
          }
          this.spec = _.defaults(spec, { duration: 2e3 });
        }
        Timeout.prototype.activate = function (context) {
          console.log('activating Timeout', this.spec.duration);
          return Q.delay(this.spec.duration);
        };
        return Timeout;
      }(Response);
      exports.Prompt = Prompt = function (_super) {
        __extends(Prompt, _super);
        function Prompt(spec) {
          this.spec = spec != null ? spec : {};
          this.spec = _.defaults(this.spec, {
            title: '',
            delay: 0,
            defaultValue: ''
          });
        }
        Prompt.prototype.activate = function (context) {
          var deferred, promise, _this = this;
          console.log('Prompting: ', this.title);
          deferred = Q.defer();
          promise = Q.delay(this.spec.delay);
          console.log('got promise');
          promise.then(function (f) {
            var result;
            result = window.prompt(_this.spec.title, _this.spec.defaultValue);
            return deferred.resolve(result);
          });
          return deferred.promise;
        };
        return Prompt;
      }(Response);
      exports.TypedResponse = TypedResponse = function () {
        function TypedResponse(spec) {
          this.spec = spec != null ? spec : {};
          this.spec = _.defaults(this.spec, {
            left: 250,
            top: 250,
            defaultValue: ''
          });
        }
        TypedResponse.prototype.activate = function (context) {
          var cursor, deferred, enterPressed, freeText, keyStream, text, xoffset, _this = this;
          deferred = Q.defer();
          enterPressed = false;
          freeText = '____';
          text = new fabric.Text(freeText, {
            top: this.spec.top,
            left: this.spec.left,
            fontSize: 50,
            textAlign: 'left'
          });
          context.canvas.add(text);
          xoffset = text.width / 2;
          cursor = new fabric.Line([
            this.spec.left,
            this.spec.top + text.height / 2,
            this.spec.left,
            this.spec.top - text.height / 2
          ]);
          context.canvas.add(cursor);
          keyStream = context.keypressStream();
          keyStream.takeWhile(function (x) {
            return enterPressed === false;
          }).onValue(function (event) {
            var char;
            if (event.keyCode === 13) {
              enterPressed = true;
              return deferred.resolve(freeText);
            } else {
              char = String.fromCharCode(event.keyCode);
              freeText = freeText + char;
              text.setText(freeText);
              text.set({ 'left': _this.spec.left + (text.width / 2 - xoffset) });
              console.log(text.width);
              console.log(text.height);
              return context.canvas.renderAll();
            }
          });
          return deferred.promise;
        };
        return TypedResponse;
      }();
      exports.MousepressResponse = MousepressResponse = function (_super) {
        __extends(MousepressResponse, _super);
        function MousepressResponse() {
        }
        MousepressResponse.prototype.activate = function (context) {
          var deferred, mouse, _this = this;
          deferred = Q.defer();
          mouse = context.mousepressStream();
          mouse.stream.take(1).onValue(function (event) {
            mouse.stop();
            return deferred.resolve(event);
          });
          return deferred.promise;
        };
        return MousepressResponse;
      }(Response);
      exports.KeypressResponse = KeypressResponse = function (_super) {
        __extends(KeypressResponse, _super);
        function KeypressResponse(spec) {
          this.spec = spec != null ? spec : {};
          this.spec = _.defaults(this.spec, {
            keys: [
              'n',
              'm'
            ],
            correct: ['n'],
            timeout: 3e3
          });
        }
        KeypressResponse.prototype.activate = function (context) {
          var deferred, keyStream, _this = this;
          deferred = Q.defer();
          keyStream = context.keypressStream();
          keyStream.filter(function (event) {
            var char;
            char = String.fromCharCode(event.keyCode);
            console.log(char);
            console.log(event.keyCode);
            return _.contains(_this.spec.keys, char);
          }).take(1).onValue(function (filtered) {
            var Acc;
            Acc = _.contains(_this.spec.correct, String.fromCharCode(filtered.keyCode));
            console.log('Acc', Acc);
            context.logEvent('$ACC', Acc);
            return deferred.resolve(event);
          });
          return deferred.promise;
        };
        return KeypressResponse;
      }(Response);
      exports.SpaceKeyResponse = SpaceKeyResponse = function (_super) {
        __extends(SpaceKeyResponse, _super);
        function SpaceKeyResponse(spec) {
          this.spec = spec != null ? spec : {};
        }
        SpaceKeyResponse.prototype.activate = function (context) {
          var deferred, keyStream, _this = this;
          deferred = Q.defer();
          keyStream = context.keypressStream();
          keyStream.filter(function (event) {
            var char;
            char = String.fromCharCode(event.keyCode);
            console.log(char);
            console.log(event.keyCode);
            return event.keyCode === 32;
          }).take(1).onValue(function (event) {
            return deferred.resolve(event);
          });
          return deferred.promise;
        };
        return SpaceKeyResponse;
      }(Response);
      exports.FirstResponse = FirstResponse = function (_super) {
        __extends(FirstResponse, _super);
        function FirstResponse(responses) {
          this.responses = responses;
        }
        FirstResponse.prototype.activate = function (context) {
          var deferred, promises, _this = this;
          deferred = Q.defer();
          promises = _.map(this.responses, function (resp) {
            return resp.activate(context).then(function () {
              return deferred.resolve(resp);
            });
          });
          return deferred.promise;
        };
        return FirstResponse;
      }(Response);
      exports.ClickResponse = ClickResponse = function (_super) {
        __extends(ClickResponse, _super);
        function ClickResponse(id) {
          this.id = id;
        }
        ClickResponse.prototype.activate = function (context) {
          var deferred, element, _this = this;
          element = context.stage.get('#' + this.id);
          if (!element) {
            throw 'cannot find element with id' + this.id;
          }
          deferred = Q.defer();
          element.on('click', function (ev) {
            return deferred.resolve(ev);
          });
          return deferred.promise;
        };
        return ClickResponse;
      }(Response);
      exports.Stimulus = Stimulus = function () {
        Stimulus.prototype.spec = {};
        Stimulus.prototype.overlay = false;
        function Stimulus() {
        }
        Stimulus.prototype.render = function (context, layer) {
        };
        Stimulus.prototype.stop = function () {
        };
        Stimulus.prototype.id = function () {
          return this.spec.id || -9999;
        };
        return Stimulus;
      }();
      exports.Sound = Sound = function () {
        function Sound(url) {
          this.url = url;
          this.sound = new buzz.sound(this.url);
        }
        Sound.prototype.render = function (context) {
          return this.sound.play();
        };
        return Sound;
      }();
      exports.Picture = Picture = function (_super) {
        __extends(Picture, _super);
        function Picture(spec) {
          var _this = this;
          if (spec == null) {
            spec = {};
          }
          this.spec = _.defaults(spec, {
            url: 'http://www.html5canvastutorials.com/demos/assets/yoda.jpg',
            x: 0,
            y: 0
          });
          this.imageObj = new Image;
          this.image = null;
          this.imageObj.onload = function () {
            return _this.image = new Kinetic.Image({
              x: _this.spec.x,
              y: _this.spec.y,
              image: _this.imageObj,
              width: _this.spec.width || _this.imageObj.width,
              height: _this.spec.height || _this.imageObj.height
            });
          };
          this.imageObj.src = this.spec.url;
        }
        Picture.prototype.render = function (context, layer) {
          return layer.add(this.image);
        };
        return Picture;
      }(Stimulus);
      exports.Group = Group = function (_super) {
        __extends(Group, _super);
        function Group(stims) {
          this.stims = stims;
          this.overlay = true;
        }
        Group.prototype.render = function (context, layer) {
          var stim, _i, _len, _ref, _results;
          _ref = this.stims;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            stim = _ref[_i];
            _results.push(stim.render(context, layer));
          }
          return _results;
        };
        return Group;
      }(Stimulus);
      exports.Background = Background = function (_super) {
        __extends(Background, _super);
        function Background(stims, fill) {
          this.stims = stims != null ? stims : [];
          this.fill = fill != null ? fill : 'red';
          this.background = new Kinetic.Rect({
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            fill: this.fill
          });
        }
        Background.prototype.render = function (context, layer) {
          var stim, _i, _len, _ref, _results;
          this.background = new Kinetic.Rect({
            x: 0,
            y: 0,
            width: context.width(),
            height: context.height(),
            name: 'background',
            fill: this.fill
          });
          console.log('rendering background');
          layer.add(this.background);
          _ref = this.stims;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            stim = _ref[_i];
            console.log('rendering stim background');
            _results.push(stim.render(context, layer));
          }
          return _results;
        };
        return Background;
      }(Stimulus);
      exports.Sequence = Sequence = function (_super) {
        __extends(Sequence, _super);
        Sequence.prototype.stopped = false;
        function Sequence(stims, soa, clear) {
          var i;
          this.stims = stims;
          this.soa = soa;
          this.clear = clear != null ? clear : true;
          if (this.soa.length !== this.stims.length) {
            this.soa = Psy.repLen(this.soa, this.stims.length);
          }
          this.onsets = function () {
            var _i, _ref, _results;
            _results = [];
            for (i = _i = 0, _ref = this.soa.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              _results.push(_.reduce(this.soa.slice(0, +i + 1 || 9e9), function (x, acc) {
                return x + acc;
              }));
            }
            return _results;
          }.call(this);
        }
        Sequence.prototype.render = function (context, layer) {
          var _i, _ref, _results, _this = this;
          return _.forEach(function () {
            _results = [];
            for (var _i = 0, _ref = this.stims.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--) {
              _results.push(_i);
            }
            return _results;
          }.apply(this), function (i) {
            var ev, stim;
            ev = new Timeout({ duration: _this.onsets[i] });
            stim = _this.stims[i];
            return ev.activate(context).then(function () {
              if (!_this.stopped) {
                if (_this.clear) {
                  context.clearContent();
                }
                console.log('drawing stim');
                stim.render(context, layer);
                return context.draw();
              }
            });
          });
        };
        Sequence.prototype.stop = function () {
          console.log('stopping Sequence!');
          return this.stopped = true;
        };
        return Sequence;
      }(Stimulus);
      exports.Blank = Blank = function (_super) {
        __extends(Blank, _super);
        function Blank(spec) {
          if (spec == null) {
            spec = {};
          }
          this.spec = _.defaults(spec, { fill: 'white' });
        }
        Blank.prototype.render = function (context, layer) {
          var blank;
          blank = new Kinetic.Rect({
            x: 0,
            y: 0,
            width: context.width(),
            height: context.height(),
            fill: this.spec.fill
          });
          return layer.add(blank);
        };
        return Blank;
      }(Stimulus);
      exports.Clear = Clear = function (_super) {
        __extends(Clear, _super);
        function Clear(spec) {
          this.spec = spec != null ? spec : {};
        }
        Clear.prototype.render = function (context, layer) {
          return context.clearContent(true);
        };
        return Clear;
      }(Stimulus);
      exports.Arrow = Arrow = function (_super) {
        __extends(Arrow, _super);
        function Arrow(spec) {
          if (spec == null) {
            spec = {};
          }
          this.spec = _.defaults(spec, {
            x: 100,
            y: 100,
            length: 100,
            angle: 0,
            thickness: 40,
            fill: 'red',
            arrowSize: 50
          });
        }
        Arrow.prototype.render = function (context, layer) {
          var group, rect, triangle, _this;
          rect = new Kinetic.Rect({
            x: 0,
            y: 0,
            width: this.spec.length,
            height: this.spec.thickness,
            fill: this.spec.fill
          });
          _this = this;
          triangle = new Kinetic.Shape({
            drawFunc: function (cx) {
              cx.beginPath();
              cx.moveTo(_this.spec.length, -_this.spec.arrowSize / 2);
              cx.lineTo(_this.spec.length + _this.spec.arrowSize, _this.spec.thickness / 2);
              cx.lineTo(_this.spec.length, _this.spec.thickness + _this.spec.arrowSize / 2);
              cx.closePath();
              return cx.fillStrokeShape(this);
            },
            fill: _this.spec.fill
          });
          group = new Kinetic.Group({
            x: this.spec.x,
            y: this.spec.y,
            rotationDeg: this.spec.angle,
            offset: [
              0,
              this.spec.thickness / 2
            ]
          });
          group.add(rect);
          group.add(triangle);
          console.log(group.getOffset());
          console.log(group.getOffset());
          return layer.add(group);
        };
        return Arrow;
      }(Stimulus);
      exports.Rectangle = Rectangle = function (_super) {
        __extends(Rectangle, _super);
        function Rectangle(spec) {
          if (spec == null) {
            spec = {};
          }
          this.spec = _.defaults(spec, {
            x: 0,
            y: 0,
            width: 100,
            height: 100,
            fill: 'red'
          });
          this.spec = _.omit(this.spec, function (value, key) {
            return !value;
          });
        }
        Rectangle.prototype.render = function (context, layer) {
          var rect;
          rect = new Kinetic.Rect({
            x: this.spec.x,
            y: this.spec.y,
            width: this.spec.width,
            height: this.spec.height,
            fill: this.spec.fill,
            stroke: this.spec.stroke,
            strokeWidth: this.spec.strokeWidth
          });
          return layer.add(rect);
        };
        return Rectangle;
      }(Stimulus);
      exports.Circle = Circle = function (_super) {
        __extends(Circle, _super);
        function Circle(spec) {
          if (spec == null) {
            spec = {};
          }
          this.spec = _.defaults(spec, {
            x: 100,
            y: 100,
            radius: 50,
            fill: 'red'
          });
        }
        Circle.prototype.render = function (context, layer) {
          var circ;
          circ = new Kinetic.Circle({
            x: this.spec.x,
            y: this.spec.y,
            radius: this.spec.radius,
            fill: this.spec.fill,
            stroke: this.spec.stroke,
            strokeWidth: this.spec.strokeWidth
          });
          return layer.add(circ);
        };
        return Circle;
      }(Stimulus);
      exports.FixationCross = FixationCross = function (_super) {
        __extends(FixationCross, _super);
        function FixationCross(spec) {
          if (spec == null) {
            spec = {};
          }
          this.spec = _.defaults(spec, {
            strokeWidth: 8,
            length: 150,
            fill: 'black'
          });
        }
        FixationCross.prototype.render = function (context, layer) {
          var group, horz, vert, x, y;
          x = context.width() / 2;
          y = context.height() / 2;
          horz = new Kinetic.Rect({
            x: x - this.spec.length / 2,
            y: y,
            width: this.spec.length,
            height: this.spec.strokeWidth,
            fill: this.spec.fill
          });
          vert = new Kinetic.Rect({
            x: x - this.spec.strokeWidth / 2,
            y: y - this.spec.length / 2 + this.spec.strokeWidth / 2,
            width: this.spec.strokeWidth,
            height: this.spec.length,
            fill: this.spec.fill
          });
          group = new Kinetic.Group;
          group.add(horz);
          group.add(vert);
          return layer.add(group);
        };
        return FixationCross;
      }(Stimulus);
      exports.CanvasBorder = CanvasBorder = function (_super) {
        __extends(CanvasBorder, _super);
        function CanvasBorder(spec) {
          if (spec == null) {
            spec = {};
          }
          this.spec = _.defaults(spec, {
            strokeWidth: 5,
            stroke: 'black'
          });
        }
        CanvasBorder.prototype.render = function (context, layer) {
          var border;
          border = new Kinetic.Rect({
            x: 0,
            y: 0,
            width: context.width(),
            height: context.height(),
            strokeWidth: this.spec.strokeWidth,
            stroke: this.spec.stroke
          });
          return layer.add(border);
        };
        return CanvasBorder;
      }(Stimulus);
      exports.StartButton = StartButton = function (_super) {
        __extends(StartButton, _super);
        function StartButton(spec) {
          if (spec == null) {
            spec = {};
          }
          this.spec = _.defaults(spec, {
            width: 150,
            height: 75
          });
        }
        StartButton.prototype.render = function (context, layer) {
          var button, group, text, xcenter, ycenter;
          xcenter = context.width() / 2;
          ycenter = context.height() / 2;
          group = new Kinetic.Group({ id: this.spec.id });
          text = new Kinetic.Text({
            text: 'Start',
            x: xcenter - this.spec.width / 2,
            y: ycenter - this.spec.height / 2,
            width: this.spec.width,
            height: this.spec.height,
            fontSize: 30,
            fill: 'white',
            fontFamily: 'Arial',
            align: 'center',
            padding: 20
          });
          button = new Kinetic.Rect({
            x: xcenter - this.spec.width / 2,
            y: ycenter - text.getHeight() / 2,
            width: this.spec.width,
            height: text.getHeight(),
            fill: 'black',
            cornerRadius: 10,
            stroke: 'LightSteelBlue',
            strokeWidth: 5
          });
          group.add(button);
          group.add(text);
          return layer.add(group);
        };
        return StartButton;
      }(Stimulus);
      position = function (pos, offx, offy, width, height, xy) {
        switch (pos) {
        case 'center':
          return [
            offx + width * .5,
            offy + height * .5
          ];
        case 'center-left':
          return [
            offx + width * 1 / 6,
            offy + height * .5
          ];
        case 'center-right':
          return [
            offx + width * 5 / 6,
            offy + height * .5
          ];
        case 'top-left':
          return [
            offx + width * 1 / 6,
            offy + height * 1 / 6
          ];
        case 'top-right':
          return [
            offx + width * 5 / 6,
            offy + height * 1 / 6
          ];
        case 'top-center':
          return [
            offx + width * .5,
            offy + height * 1 / 6
          ];
        case 'bottom-left':
          return [
            offx + width * 1 / 6,
            offy + height * 5 / 6
          ];
        case 'bottom-right':
          return [
            offx + width * 5 / 6,
            offy + height * 5 / 6
          ];
        case 'bottom-center':
          return [
            offx + width * .5,
            offy + height * 5 / 6
          ];
        default:
          return xy;
        }
      };
      exports.Text = Text = function (_super) {
        __extends(Text, _super);
        function Text(spec) {
          if (spec == null) {
            spec = {};
          }
          this.spec = _.defaults(spec, {
            content: 'Text',
            x: 100,
            y: 100,
            fill: 'black',
            fontSize: 50,
            fontFamily: 'Arial',
            lineHeight: 1,
            textAlign: 'center',
            position: null
          });
        }
        Text.prototype.render = function (context, layer) {
          var text, xy;
          text = new Kinetic.Text({
            x: this.spec.x,
            y: this.spec.y,
            text: this.spec.content,
            fontSize: this.spec.fontSize,
            fontFamily: this.spec.fontFamily,
            fill: this.spec.fill,
            listening: false
          });
          if (this.spec.position) {
            xy = position(this.spec.position, -text.getWidth() / 2, -text.getHeight() / 2, context.width(), context.height(), [
              this.spec.x,
              this.spec.y
            ]);
            text.setPosition({
              x: xy[0],
              y: xy[1]
            });
          }
          return layer.add(text);
        };
        return Text;
      }(Stimulus);
      exports.KineticContext = KineticContext = function (_super) {
        __extends(KineticContext, _super);
        function KineticContext(stage) {
          this.stage = stage;
          this.contentLayer = new Kinetic.Layer({ clearBeforeDraw: true });
          this.backgroundLayer = new Kinetic.Layer({ clearBeforeDraw: true });
          this.background = new Background([], { fill: 'white' });
          this.stage.add(this.backgroundLayer);
          this.stage.add(this.contentLayer);
          this.backgroundLayer.on('click', function () {
            return console.log('background layer click');
          });
          this.stage.on('mousedown', function () {
            return console.log('stage mouse down');
          });
          this.stage.getContent().addEventListener('mousedown', function () {
            return console.log('stage dom click');
          });
        }
        KineticContext.prototype.setBackground = function (newBackground) {
          this.background = newBackground;
          this.backgroundLayer.removeChildren();
          return this.background.render(this, this.backgroundLayer);
        };
        KineticContext.prototype.drawBackground = function () {
          return this.backgroundLayer.draw();
        };
        KineticContext.prototype.clearBackground = function () {
          return this.backgroundLayer.removeChildren();
        };
        KineticContext.prototype.clearContent = function (draw) {
          if (draw == null) {
            draw = false;
          }
          this.contentLayer.removeChildren();
          if (draw) {
            return this.draw();
          }
        };
        KineticContext.prototype.draw = function () {
          this.backgroundLayer.draw();
          return this.contentLayer.draw();
        };
        KineticContext.prototype.width = function () {
          return this.stage.getWidth();
        };
        KineticContext.prototype.height = function () {
          return this.stage.getHeight();
        };
        KineticContext.prototype.offsetX = function () {
          return this.stage.getOffsetX();
        };
        KineticContext.prototype.offsetY = function () {
          return this.stage.getOffsetY();
        };
        KineticContext.prototype.keydownStream = function () {
          return Bacon.fromEventTarget(window, 'keydown');
        };
        KineticContext.prototype.keypressStream = function () {
          return Bacon.fromEventTarget(window, 'keypress');
        };
        KineticContext.prototype.mousepressStream = function () {
          var MouseBus;
          MouseBus = function () {
            function MouseBus() {
              var _this = this;
              this.stream = new Bacon.Bus;
              this.handler = function (x) {
                return _this.stream.push(x);
              };
              this.stage.on('mousedown', this.handler);
            }
            MouseBus.prototype.stop = function () {
              this.stage.off('mousedown', this.handler);
              return this.stream.end();
            };
            return MouseBus;
          }();
          return new MouseBus;
        };
        return KineticContext;
      }(Psy.ExperimentContext);
      exports.KineticStimFactory = KineticStimFactory = function (_super) {
        __extends(KineticStimFactory, _super);
        function KineticStimFactory() {
          return KineticStimFactory.__super__.constructor.apply(this, arguments);
        }
        KineticStimFactory.prototype.makeStimulus = function (name, params) {
          switch (name) {
          case 'FixationCross':
            return new FixationCross(params);
          case 'Text':
            return new Text(params);
          default:
            throw 'No Stimulus type of name ' + name;
          }
        };
        KineticStimFactory.prototype.makeResponse = function (name, params) {
          switch (name) {
          case 'KeyPressed':
            return new KeypressResponse(params);
          case 'Timeout':
            return new Timeout(params);
          default:
            throw 'No Response type of name ' + name;
          }
        };
        KineticStimFactory.prototype.makeEvent = function (stim, response) {
          return new Psy.Event(stim, response);
        };
        return KineticStimFactory;
      }(Psy.StimFactory);
      x = new Sequence([
        'a',
        'b',
        'c'
      ], [
        0,
        1e3,
        1500
      ]);
    }.call(this));
  });
  require.define('/lib/Bacon.js', function (module, exports, __dirname, __filename) {
    (function () {
      var Bacon, Bus, Dispatcher, End, Error, Event, EventStream, Initial, Next, None, Observable, Property, PropertyDispatcher, Some, addPropertyInitValueToStream, assert, assertArray, assertEvent, assertFunction, assertString, cloneArray, cloneObject, end, former, indexOf, initial, isEvent, isFieldKey, isFunction, latter, makeFunction, methodCall, next, nop, partiallyApplied, remove, sendWrapped, toCombinator, toEvent, toFieldExtractor, toFieldKey, toOption, toSimpleExtractor, _, _ref, __slice = [].slice, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor;
          child.__super__ = parent.prototype;
          return child;
        }, __bind = function (fn, me) {
          return function () {
            return fn.apply(me, arguments);
          };
        };
      (exports || this).Bacon = Bacon = {};
      Bacon.asEventStream = function (eventName, selector, eventTransformer) {
        var element;
        if (eventTransformer == null) {
          eventTransformer = _.id;
        }
        if (isFunction(selector)) {
          eventTransformer = selector;
          selector = null;
        }
        element = this;
        return new EventStream(function (sink) {
          var handler, unbind;
          handler = function () {
            var args, reply;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            reply = sink(next(eventTransformer.apply(null, args)));
            if (reply === Bacon.noMore) {
              return unbind();
            }
          };
          unbind = function () {
            return element.off(eventName, selector, handler);
          };
          element.on(eventName, selector, handler);
          return unbind;
        });
      };
      if (typeof window !== 'undefined' && window !== null) {
        if ((_ref = window.jQuery || window.Zepto) != null) {
          _ref.fn.asEventStream = Bacon.asEventStream;
        }
      }
      Bacon.fromPromise = function (promise) {
        return new EventStream(function (sink) {
          var onError, onSuccess;
          onSuccess = function (value) {
            sink(next(value));
            return sink(end());
          };
          onError = function (e) {
            sink(new Error(e));
            return sink(end());
          };
          promise.then(onSuccess, onError);
          return nop;
        });
      };
      Bacon.noMore = ['<no-more>'];
      Bacon.more = ['<more>'];
      Bacon.later = function (delay, value) {
        return Bacon.sequentially(delay, [value]);
      };
      Bacon.sequentially = function (delay, values) {
        var index, poll;
        index = -1;
        poll = function () {
          var valueEvent;
          index++;
          valueEvent = toEvent(values[index]);
          if (index < values.length - 1) {
            return valueEvent;
          } else {
            return [
              valueEvent,
              end()
            ];
          }
        };
        return Bacon.fromPoll(delay, poll);
      };
      Bacon.repeatedly = function (delay, values) {
        var index, poll;
        index = -1;
        poll = function () {
          index++;
          return toEvent(values[index % values.length]);
        };
        return Bacon.fromPoll(delay, poll);
      };
      Bacon.fromCallback = function () {
        var args, f;
        f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        f = makeFunction(f, args);
        return new EventStream(function (sink) {
          var handler;
          handler = function (value) {
            sink(next(value));
            return sink(end());
          };
          f(handler);
          return nop;
        });
      };
      Bacon.fromPoll = function (delay, poll) {
        return new EventStream(function (sink) {
          var handler, id, unbind;
          id = void 0;
          handler = function () {
            var event, events, reply, _i, _len, _results;
            events = _.toArray(poll());
            _results = [];
            for (_i = 0, _len = events.length; _i < _len; _i++) {
              event = events[_i];
              reply = sink(event);
              if (reply === Bacon.noMore || event.isEnd()) {
                _results.push(unbind());
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          };
          unbind = function () {
            return clearInterval(id);
          };
          id = setInterval(handler, delay);
          return unbind;
        });
      };
      Bacon.fromEventTarget = function (target, eventName, eventTransformer) {
        if (eventTransformer == null) {
          eventTransformer = _.id;
        }
        return new EventStream(function (sink) {
          var handler, unbind;
          handler = function () {
            var args, reply;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            reply = sink(next(eventTransformer.apply(null, args)));
            if (reply === Bacon.noMore) {
              return unbind();
            }
          };
          if (target.addEventListener) {
            unbind = function () {
              return target.removeEventListener(eventName, handler, false);
            };
            target.addEventListener(eventName, handler, false);
          } else {
            unbind = function () {
              return target.removeListener(eventName, handler);
            };
            target.addListener(eventName, handler);
          }
          return unbind;
        });
      };
      Bacon.interval = function (delay, value) {
        var poll;
        if (value == null) {
          value = {};
        }
        poll = function () {
          return next(value);
        };
        return Bacon.fromPoll(delay, poll);
      };
      Bacon.constant = function (value) {
        return new Property(sendWrapped([value], initial));
      };
      Bacon.never = function () {
        return Bacon.fromArray([]);
      };
      Bacon.once = function (value) {
        return Bacon.fromArray([value]);
      };
      Bacon.fromArray = function (values) {
        return new EventStream(sendWrapped(values, next));
      };
      sendWrapped = function (values, wrapper) {
        return function (sink) {
          var value, _i, _len;
          for (_i = 0, _len = values.length; _i < _len; _i++) {
            value = values[_i];
            sink(wrapper(value));
          }
          sink(end());
          return nop;
        };
      };
      Bacon.combineAll = function (streams, f) {
        var next, stream, _i, _len, _ref1;
        assertArray(streams);
        stream = _.head(streams);
        _ref1 = _.tail(streams);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          next = _ref1[_i];
          stream = f(stream, next);
        }
        return stream;
      };
      Bacon.mergeAll = function (streams) {
        return Bacon.combineAll(streams, function (s1, s2) {
          return s1.merge(s2);
        });
      };
      Bacon.combineAsArray = function () {
        var more, next, stream, streams, _i, _len, _ref1;
        streams = arguments[0], more = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (!(streams instanceof Array)) {
          streams = [streams].concat(more);
        }
        if (streams.length) {
          stream = _.head(streams).toProperty().map(function (x) {
            return [x];
          });
          _ref1 = _.tail(streams);
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            next = _ref1[_i];
            stream = stream.combine(next, function (xs, x) {
              return xs.concat([x]);
            });
          }
          return stream;
        } else {
          return Bacon.constant([]);
        }
      };
      Bacon.combineWith = function (streams, f) {
        return Bacon.combineAll(streams, function (s1, s2) {
          return s1.toProperty().combine(s2, f);
        });
      };
      Bacon.combineTemplate = function (template) {
        var applyStreamValue, combinator, compile, compileTemplate, constantValue, current, funcs, mkContext, setValue, streams;
        funcs = [];
        streams = [];
        current = function (ctxStack) {
          return ctxStack[ctxStack.length - 1];
        };
        setValue = function (ctxStack, key, value) {
          return current(ctxStack)[key] = value;
        };
        applyStreamValue = function (key, index) {
          return function (ctxStack, values) {
            return setValue(ctxStack, key, values[index]);
          };
        };
        constantValue = function (key, value) {
          return function (ctxStack, values) {
            return setValue(ctxStack, key, value);
          };
        };
        mkContext = function (template) {
          if (template instanceof Array) {
            return [];
          } else {
            return {};
          }
        };
        compile = function (key, value) {
          var popContext, pushContext;
          if (value instanceof Observable) {
            streams.push(value);
            return funcs.push(applyStreamValue(key, streams.length - 1));
          } else if (typeof value === 'object') {
            pushContext = function (key) {
              return function (ctxStack, values) {
                var newContext;
                newContext = mkContext(value);
                setValue(ctxStack, key, newContext);
                return ctxStack.push(newContext);
              };
            };
            popContext = function (ctxStack, values) {
              return ctxStack.pop();
            };
            funcs.push(pushContext(key));
            compileTemplate(value);
            return funcs.push(popContext);
          } else {
            return funcs.push(constantValue(key, value));
          }
        };
        compileTemplate = function (template) {
          return _.each(template, compile);
        };
        compileTemplate(template);
        combinator = function (values) {
          var ctxStack, f, rootContext, _i, _len;
          rootContext = mkContext(template);
          ctxStack = [rootContext];
          for (_i = 0, _len = funcs.length; _i < _len; _i++) {
            f = funcs[_i];
            f(ctxStack, values);
          }
          return rootContext;
        };
        return Bacon.combineAsArray(streams).map(combinator);
      };
      Event = function () {
        function Event() {
        }
        Event.prototype.isEvent = function () {
          return true;
        };
        Event.prototype.isEnd = function () {
          return false;
        };
        Event.prototype.isInitial = function () {
          return false;
        };
        Event.prototype.isNext = function () {
          return false;
        };
        Event.prototype.isError = function () {
          return false;
        };
        Event.prototype.hasValue = function () {
          return false;
        };
        Event.prototype.filter = function (f) {
          return true;
        };
        Event.prototype.getOriginalEvent = function () {
          if (this.sourceEvent != null) {
            return this.sourceEvent.getOriginalEvent();
          } else {
            return this;
          }
        };
        Event.prototype.onDone = function (listener) {
          return listener();
        };
        return Event;
      }();
      Next = function (_super) {
        __extends(Next, _super);
        function Next(value, sourceEvent) {
          this.value = isFunction(value) ? value : _.always(value);
        }
        Next.prototype.isNext = function () {
          return true;
        };
        Next.prototype.hasValue = function () {
          return true;
        };
        Next.prototype.fmap = function (f) {
          return this.apply(f(this.value()));
        };
        Next.prototype.apply = function (value) {
          return next(value, this.getOriginalEvent());
        };
        Next.prototype.filter = function (f) {
          return f(this.value());
        };
        Next.prototype.describe = function () {
          return this.value();
        };
        return Next;
      }(Event);
      Initial = function (_super) {
        __extends(Initial, _super);
        function Initial() {
          return Initial.__super__.constructor.apply(this, arguments);
        }
        Initial.prototype.isInitial = function () {
          return true;
        };
        Initial.prototype.isNext = function () {
          return false;
        };
        Initial.prototype.apply = function (value) {
          return initial(value, this.getOriginalEvent());
        };
        Initial.prototype.toNext = function () {
          return new Next(this.value, this.getOriginalEvent());
        };
        return Initial;
      }(Next);
      End = function (_super) {
        __extends(End, _super);
        function End() {
          return End.__super__.constructor.apply(this, arguments);
        }
        End.prototype.isEnd = function () {
          return true;
        };
        End.prototype.fmap = function () {
          return this;
        };
        End.prototype.apply = function () {
          return this;
        };
        End.prototype.describe = function () {
          return '<end>';
        };
        return End;
      }(Event);
      Error = function (_super) {
        __extends(Error, _super);
        function Error(error) {
          this.error = error;
        }
        Error.prototype.isError = function () {
          return true;
        };
        Error.prototype.fmap = function () {
          return this;
        };
        Error.prototype.apply = function () {
          return this;
        };
        Error.prototype.describe = function () {
          return '<error> ' + this.error;
        };
        return Error;
      }(Event);
      Observable = function () {
        function Observable() {
          this.flatMapLatest = __bind(this.flatMapLatest, this);
          this.scan = __bind(this.scan, this);
          this.takeUntil = __bind(this.takeUntil, this);
          this.assign = this.onValue;
        }
        Observable.prototype.onValue = function () {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          f = makeFunction(f, args);
          return this.subscribe(function (event) {
            if (event.hasValue()) {
              return f(event.value());
            }
          });
        };
        Observable.prototype.onValues = function (f) {
          return this.onValue(function (args) {
            return f.apply(null, args);
          });
        };
        Observable.prototype.onError = function () {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          f = makeFunction(f, args);
          return this.subscribe(function (event) {
            if (event.isError()) {
              return f(event.error);
            }
          });
        };
        Observable.prototype.onEnd = function () {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          f = makeFunction(f, args);
          return this.subscribe(function (event) {
            if (event.isEnd()) {
              return f();
            }
          });
        };
        Observable.prototype.errors = function () {
          return this.filter(function () {
            return false;
          });
        };
        Observable.prototype.filter = function () {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          f = makeFunction(f, args);
          return this.withHandler(function (event) {
            if (event.filter(f)) {
              return this.push(event);
            } else {
              return Bacon.more;
            }
          });
        };
        Observable.prototype.takeWhile = function () {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          f = makeFunction(f, args);
          return this.withHandler(function (event) {
            if (event.filter(f)) {
              return this.push(event);
            } else {
              this.push(end());
              return Bacon.noMore;
            }
          });
        };
        Observable.prototype.endOnError = function () {
          return this.withHandler(function (event) {
            if (event.isError()) {
              this.push(event);
              return this.push(end());
            } else {
              return this.push(event);
            }
          });
        };
        Observable.prototype.take = function (count) {
          assert('take: count must >= 1', count >= 1);
          return this.withHandler(function (event) {
            if (!event.hasValue()) {
              return this.push(event);
            } else if (count === 1) {
              this.push(event);
              this.push(end());
              return Bacon.noMore;
            } else {
              count--;
              return this.push(event);
            }
          });
        };
        Observable.prototype.map = function () {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          f = makeFunction(f, args);
          return this.withHandler(function (event) {
            return this.push(event.fmap(f));
          });
        };
        Observable.prototype.mapError = function () {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          f = makeFunction(f, args);
          return this.withHandler(function (event) {
            if (event.isError()) {
              return this.push(next(f(event.error)));
            } else {
              return this.push(event);
            }
          });
        };
        Observable.prototype.doAction = function () {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          f = makeFunction(f, args);
          return this.withHandler(function (event) {
            if (event.hasValue()) {
              f(event.value());
            }
            return this.push(event);
          });
        };
        Observable.prototype.takeUntil = function (stopper) {
          var src;
          src = this;
          return this.withSubscribe(function (sink) {
            var srcSink, stopperSink, unsubBoth, unsubSrc, unsubStopper, unsubscribed;
            unsubscribed = false;
            unsubSrc = nop;
            unsubStopper = nop;
            unsubBoth = function () {
              unsubSrc();
              unsubStopper();
              return unsubscribed = true;
            };
            srcSink = function (event) {
              if (event.isEnd()) {
                unsubStopper();
                sink(event);
                return Bacon.noMore;
              } else {
                event.getOriginalEvent().onDone(function () {
                  var reply;
                  if (!unsubscribed) {
                    reply = sink(event);
                    if (reply === Bacon.noMore) {
                      return unsubBoth();
                    }
                  }
                });
                return Bacon.more;
              }
            };
            stopperSink = function (event) {
              if (event.isError()) {
                return Bacon.more;
              } else if (event.isEnd()) {
                return Bacon.noMore;
              } else {
                unsubSrc();
                sink(end());
                return Bacon.noMore;
              }
            };
            unsubSrc = src.subscribe(srcSink);
            if (!unsubscribed) {
              unsubStopper = stopper.subscribe(stopperSink);
            }
            return unsubBoth;
          });
        };
        Observable.prototype.skip = function (count) {
          assert('skip: count must >= 0', count >= 0);
          return this.withHandler(function (event) {
            if (!event.hasValue()) {
              return this.push(event);
            } else if (count > 0) {
              count--;
              return Bacon.more;
            } else {
              return this.push(event);
            }
          });
        };
        Observable.prototype.distinctUntilChanged = function () {
          return this.skipDuplicates();
        };
        Observable.prototype.skipDuplicates = function (isEqual) {
          if (isEqual == null) {
            isEqual = function (a, b) {
              return a === b;
            };
          }
          return this.withStateMachine(None, function (prev, event) {
            if (!event.hasValue()) {
              return [
                prev,
                [event]
              ];
            } else if (prev === None || !isEqual(prev.get(), event.value())) {
              return [
                new Some(event.value()),
                [event]
              ];
            } else {
              return [
                prev,
                []
              ];
            }
          });
        };
        Observable.prototype.withStateMachine = function (initState, f) {
          var state;
          state = initState;
          return this.withHandler(function (event) {
            var fromF, newState, output, outputs, reply, _i, _len;
            fromF = f(state, event);
            assertArray(fromF);
            newState = fromF[0], outputs = fromF[1];
            assertArray(outputs);
            state = newState;
            reply = Bacon.more;
            for (_i = 0, _len = outputs.length; _i < _len; _i++) {
              output = outputs[_i];
              reply = this.push(output);
              if (reply === Bacon.noMore) {
                return reply;
              }
            }
            return reply;
          });
        };
        Observable.prototype.scan = function (seed, f) {
          var acc, subscribe, _this = this;
          f = toCombinator(f);
          acc = toOption(seed);
          subscribe = function (sink) {
            var initSent, unsub;
            initSent = false;
            unsub = _this.subscribe(function (event) {
              if (event.hasValue()) {
                if (initSent && event.isInitial()) {
                  return Bacon.more;
                } else {
                  initSent = true;
                  acc = new Some(f(acc.getOrElse(void 0), event.value()));
                  return sink(event.apply(acc.get()));
                }
              } else {
                if (event.isEnd()) {
                  initSent = true;
                }
                return sink(event);
              }
            });
            if (!initSent) {
              acc.forEach(function (value) {
                var reply;
                reply = sink(initial(value));
                if (reply === Bacon.noMore) {
                  unsub();
                  return unsub = nop;
                }
              });
            }
            return unsub;
          };
          return new Property(new PropertyDispatcher(subscribe).subscribe);
        };
        Observable.prototype.diff = function (start, f) {
          f = toCombinator(f);
          return this.scan([start], function (prevTuple, next) {
            return [
              next,
              f(prevTuple[0], next)
            ];
          }).filter(function (tuple) {
            return tuple.length === 2;
          }).map(function (tuple) {
            return tuple[1];
          });
        };
        Observable.prototype.flatMap = function (f) {
          var root;
          root = this;
          return new EventStream(function (sink) {
            var checkEnd, children, rootEnd, spawner, unbind, unsubRoot;
            children = [];
            rootEnd = false;
            unsubRoot = function () {
            };
            unbind = function () {
              var unsubChild, _i, _len;
              unsubRoot();
              for (_i = 0, _len = children.length; _i < _len; _i++) {
                unsubChild = children[_i];
                unsubChild();
              }
              return children = [];
            };
            checkEnd = function () {
              if (rootEnd && children.length === 0) {
                return sink(end());
              }
            };
            spawner = function (event) {
              var child, childEnded, handler, removeChild, unsubChild;
              if (event.isEnd()) {
                rootEnd = true;
                return checkEnd();
              } else if (event.isError()) {
                return sink(event);
              } else {
                child = f(event.value());
                unsubChild = void 0;
                childEnded = false;
                removeChild = function () {
                  if (unsubChild != null) {
                    remove(unsubChild, children);
                  }
                  return checkEnd();
                };
                handler = function (event) {
                  var reply;
                  if (event.isEnd()) {
                    removeChild();
                    childEnded = true;
                    return Bacon.noMore;
                  } else {
                    if (event instanceof Initial) {
                      event = event.toNext();
                    }
                    reply = sink(event);
                    if (reply === Bacon.noMore) {
                      unbind();
                    }
                    return reply;
                  }
                };
                unsubChild = child.subscribe(handler);
                if (!childEnded) {
                  return children.push(unsubChild);
                }
              }
            };
            unsubRoot = root.subscribe(spawner);
            return unbind;
          });
        };
        Observable.prototype.flatMapLatest = function (f) {
          var stream, _this = this;
          stream = this.toEventStream();
          return stream.flatMap(function (value) {
            return f(value).takeUntil(stream);
          });
        };
        Observable.prototype.not = function () {
          return this.map(function (x) {
            return !x;
          });
        };
        Observable.prototype.log = function () {
          this.subscribe(function (event) {
            return console.log(event.describe());
          });
          return this;
        };
        Observable.prototype.slidingWindow = function (n) {
          return this.scan([], function (window, value) {
            return window.concat([value]).slice(-n);
          });
        };
        return Observable;
      }();
      EventStream = function (_super) {
        __extends(EventStream, _super);
        function EventStream(subscribe) {
          var dispatcher;
          EventStream.__super__.constructor.call(this);
          assertFunction(subscribe);
          dispatcher = new Dispatcher(subscribe);
          this.subscribe = dispatcher.subscribe;
          this.hasSubscribers = dispatcher.hasSubscribers;
        }
        EventStream.prototype.map = function () {
          var args, p;
          p = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (p instanceof Property) {
            return p.sampledBy(this, former);
          } else {
            return EventStream.__super__.map.apply(this, [p].concat(__slice.call(args)));
          }
        };
        EventStream.prototype.filter = function () {
          var args, p;
          p = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (p instanceof Property) {
            return p.sampledBy(this, function (p, s) {
              return [
                p,
                s
              ];
            }).filter(function (_arg) {
              var p, s;
              p = _arg[0], s = _arg[1];
              return p;
            }).map(function (_arg) {
              var p, s;
              p = _arg[0], s = _arg[1];
              return s;
            });
          } else {
            return EventStream.__super__.filter.apply(this, [p].concat(__slice.call(args)));
          }
        };
        EventStream.prototype.delay = function (delay) {
          return this.flatMap(function (value) {
            return Bacon.later(delay, value);
          });
        };
        EventStream.prototype.throttle = function (delay) {
          return this.flatMapLatest(function (value) {
            return Bacon.later(delay, value);
          });
        };
        EventStream.prototype.throttle2 = function (delay) {
          return this.bufferWithTime(delay).map(function (values) {
            return values[values.length - 1];
          });
        };
        EventStream.prototype.bufferWithTime = function (delay) {
          var schedule, _this = this;
          schedule = function (buffer) {
            return buffer.schedule();
          };
          return this.buffer(delay, schedule, schedule);
        };
        EventStream.prototype.bufferWithCount = function (count) {
          var flushOnCount;
          flushOnCount = function (buffer) {
            if (buffer.values.length === count) {
              return buffer.flush();
            }
          };
          return this.buffer(0, flushOnCount);
        };
        EventStream.prototype.buffer = function (delay, onInput, onFlush) {
          var buffer, delayMs, reply;
          if (onInput == null) {
            onInput = function () {
            };
          }
          if (onFlush == null) {
            onFlush = function () {
            };
          }
          buffer = {
            scheduled: false,
            end: null,
            values: [],
            flush: function () {
              var reply;
              this.scheduled = false;
              if (this.values.length > 0) {
                reply = this.push(next(this.values));
                this.values = [];
                if (this.end != null) {
                  return this.push(this.end);
                } else if (reply !== Bacon.noMore) {
                  return onFlush(this);
                }
              } else {
                if (this.end != null) {
                  return this.push(this.end);
                }
              }
            },
            schedule: function () {
              var _this = this;
              if (!this.scheduled) {
                this.scheduled = true;
                return delay(function () {
                  return _this.flush();
                });
              }
            }
          };
          reply = Bacon.more;
          if (!isFunction(delay)) {
            delayMs = delay;
            delay = function (f) {
              return setTimeout(f, delayMs);
            };
          }
          return this.withHandler(function (event) {
            buffer.push = this.push;
            if (event.isError()) {
              reply = this.push(event);
            } else if (event.isEnd()) {
              buffer.end = event;
              if (!buffer.scheduled) {
                buffer.flush();
              }
            } else {
              buffer.values.push(event.value());
              onInput(buffer);
            }
            return reply;
          });
        };
        EventStream.prototype.merge = function (right) {
          var left;
          left = this;
          return new EventStream(function (sink) {
            var ends, smartSink, unsubBoth, unsubLeft, unsubRight, unsubscribed;
            unsubLeft = nop;
            unsubRight = nop;
            unsubscribed = false;
            unsubBoth = function () {
              unsubLeft();
              unsubRight();
              return unsubscribed = true;
            };
            ends = 0;
            smartSink = function (event) {
              var reply;
              if (event.isEnd()) {
                ends++;
                if (ends === 2) {
                  return sink(end());
                } else {
                  return Bacon.more;
                }
              } else {
                reply = sink(event);
                if (reply === Bacon.noMore) {
                  unsubBoth();
                }
                return reply;
              }
            };
            unsubLeft = left.subscribe(smartSink);
            if (!unsubscribed) {
              unsubRight = right.subscribe(smartSink);
            }
            return unsubBoth;
          });
        };
        EventStream.prototype.toProperty = function (initValue) {
          if (arguments.length === 0) {
            initValue = None;
          }
          return this.scan(initValue, latter);
        };
        EventStream.prototype.toEventStream = function () {
          return this;
        };
        EventStream.prototype.concat = function (right) {
          var left;
          left = this;
          return new EventStream(function (sink) {
            var unsub;
            unsub = left.subscribe(function (e) {
              if (e.isEnd()) {
                return unsub = right.subscribe(sink);
              } else {
                return sink(e);
              }
            });
            return function () {
              return unsub();
            };
          });
        };
        EventStream.prototype.awaiting = function (other) {
          return this.map(true).merge(other.map(false)).toProperty(false);
        };
        EventStream.prototype.startWith = function (seed) {
          return Bacon.once(seed).concat(this);
        };
        EventStream.prototype.mapEnd = function () {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          f = makeFunction(f, args);
          return this.withHandler(function (event) {
            if (event.isEnd()) {
              this.push(next(f(event)));
              this.push(end());
              return Bacon.noMore;
            } else {
              return this.push(event);
            }
          });
        };
        EventStream.prototype.withHandler = function (handler) {
          var dispatcher;
          dispatcher = new Dispatcher(this.subscribe, handler);
          return new EventStream(dispatcher.subscribe);
        };
        EventStream.prototype.withSubscribe = function (subscribe) {
          return new EventStream(subscribe);
        };
        return EventStream;
      }(Observable);
      Property = function (_super) {
        __extends(Property, _super);
        function Property(subscribe) {
          var combine, _this = this;
          this.subscribe = subscribe;
          this.toEventStream = __bind(this.toEventStream, this);
          this.toProperty = __bind(this.toProperty, this);
          this.changes = __bind(this.changes, this);
          this.sample = __bind(this.sample, this);
          Property.__super__.constructor.call(this);
          combine = function (other, leftSink, rightSink) {
            var myVal, otherVal;
            myVal = None;
            otherVal = None;
            return new Property(function (sink) {
              var checkEnd, combiningSink, initialSent, myEnd, mySink, otherEnd, otherSink, unsubBoth, unsubMe, unsubOther, unsubscribed;
              unsubscribed = false;
              unsubMe = nop;
              unsubOther = nop;
              unsubBoth = function () {
                unsubMe();
                unsubOther();
                return unsubscribed = true;
              };
              myEnd = false;
              otherEnd = false;
              checkEnd = function () {
                var reply;
                if (myEnd && otherEnd) {
                  reply = sink(end());
                  if (reply === Bacon.noMore) {
                    unsubBoth();
                  }
                  return reply;
                }
              };
              initialSent = false;
              combiningSink = function (markEnd, setValue, thisSink) {
                return function (event) {
                  var reply;
                  if (event.isEnd()) {
                    markEnd();
                    checkEnd();
                    return Bacon.noMore;
                  } else if (event.isError()) {
                    reply = sink(event);
                    if (reply === Bacon.noMore) {
                      unsubBoth();
                    }
                    return reply;
                  } else {
                    setValue(new Some(event.value()));
                    if (myVal.isDefined && otherVal.isDefined) {
                      if (initialSent && event.isInitial()) {
                        return Bacon.more;
                      } else {
                        initialSent = true;
                        reply = thisSink(sink, event, myVal.value, otherVal.value);
                        if (reply === Bacon.noMore) {
                          unsubBoth();
                        }
                        return reply;
                      }
                    } else {
                      return Bacon.more;
                    }
                  }
                };
              };
              mySink = combiningSink(function () {
                return myEnd = true;
              }, function (value) {
                return myVal = value;
              }, leftSink);
              otherSink = combiningSink(function () {
                return otherEnd = true;
              }, function (value) {
                return otherVal = value;
              }, rightSink);
              unsubMe = _this.subscribe(mySink);
              if (!unsubscribed) {
                unsubOther = other.subscribe(otherSink);
              }
              return unsubBoth;
            });
          };
          this.combine = function (other, f) {
            var combinator, combineAndPush;
            combinator = toCombinator(f);
            combineAndPush = function (sink, event, myVal, otherVal) {
              return sink(event.apply(combinator(myVal, otherVal)));
            };
            return combine(other, combineAndPush, combineAndPush);
          };
          this.sampledBy = function (sampler, combinator) {
            var pushPropertyValue;
            if (combinator == null) {
              combinator = former;
            }
            combinator = toCombinator(combinator);
            pushPropertyValue = function (sink, event, propertyVal, streamVal) {
              return sink(event.apply(combinator(propertyVal, streamVal)));
            };
            return combine(sampler, nop, pushPropertyValue).changes().takeUntil(sampler.filter(false).mapEnd());
          };
        }
        Property.prototype.sample = function (interval) {
          return this.sampledBy(Bacon.interval(interval, {}));
        };
        Property.prototype.changes = function () {
          var _this = this;
          return new EventStream(function (sink) {
            return _this.subscribe(function (event) {
              if (!event.isInitial()) {
                return sink(event);
              }
            });
          });
        };
        Property.prototype.withHandler = function (handler) {
          return new Property(new PropertyDispatcher(this.subscribe, handler).subscribe);
        };
        Property.prototype.withSubscribe = function (subscribe) {
          return new Property(new PropertyDispatcher(subscribe).subscribe);
        };
        Property.prototype.toProperty = function () {
          return this;
        };
        Property.prototype.toEventStream = function () {
          var _this = this;
          return new EventStream(function (sink) {
            return _this.subscribe(function (event) {
              if (event.isInitial()) {
                event = event.toNext();
              }
              return sink(event);
            });
          });
        };
        Property.prototype.and = function (other) {
          return this.combine(other, function (x, y) {
            return x && y;
          });
        };
        Property.prototype.or = function (other) {
          return this.combine(other, function (x, y) {
            return x || y;
          });
        };
        Property.prototype.decode = function (cases) {
          return this.combine(Bacon.combineTemplate(cases), function (key, values) {
            return values[key];
          });
        };
        Property.prototype.delay = function (delay) {
          return this.delayChanges(function (changes) {
            return changes.delay(delay);
          });
        };
        Property.prototype.throttle = function (delay) {
          return this.delayChanges(function (changes) {
            return changes.throttle(delay);
          });
        };
        Property.prototype.throttle2 = function (delay) {
          return this.delayChanges(function (changes) {
            return changes.throttle2(delay);
          });
        };
        Property.prototype.delayChanges = function (f) {
          return addPropertyInitValueToStream(this, f(this.changes()));
        };
        return Property;
      }(Observable);
      addPropertyInitValueToStream = function (property, stream) {
        var getInitValue;
        getInitValue = function (property) {
          var value;
          value = None;
          property.subscribe(function (event) {
            if (event.isInitial()) {
              value = new Some(event.value());
            }
            return Bacon.noMore;
          });
          return value;
        };
        return stream.toProperty(getInitValue(property));
      };
      Dispatcher = function () {
        function Dispatcher(subscribe, handleEvent) {
          var ended, removeSink, sinks, unsubscribeFromSource, _this = this;
          if (subscribe == null) {
            subscribe = function () {
              return nop;
            };
          }
          sinks = [];
          ended = false;
          this.hasSubscribers = function () {
            return sinks.length > 0;
          };
          unsubscribeFromSource = nop;
          removeSink = function (sink) {
            return remove(sink, sinks);
          };
          this.push = function (event) {
            var done, reply, sink, waiters, _i, _len, _ref1;
            waiters = void 0;
            done = function () {
              var w, ws, _i, _len;
              if (waiters != null) {
                ws = waiters;
                waiters = void 0;
                for (_i = 0, _len = ws.length; _i < _len; _i++) {
                  w = ws[_i];
                  w();
                }
              }
              return event.onDone = Event.prototype.onDone;
            };
            event.onDone = function (listener) {
              if (waiters != null && !_.contains(waiters, listener)) {
                return waiters.push(listener);
              } else {
                return waiters = [listener];
              }
            };
            assertEvent(event);
            _ref1 = cloneArray(sinks);
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              sink = _ref1[_i];
              reply = sink(event);
              if (reply === Bacon.noMore || event.isEnd()) {
                removeSink(sink);
              }
            }
            done();
            if (_this.hasSubscribers()) {
              return Bacon.more;
            } else {
              return Bacon.noMore;
            }
          };
          if (handleEvent == null) {
            handleEvent = function (event) {
              return this.push(event);
            };
          }
          this.handleEvent = function (event) {
            assertEvent(event);
            if (event.isEnd()) {
              ended = true;
            }
            return handleEvent.apply(_this, [event]);
          };
          this.subscribe = function (sink) {
            if (ended) {
              sink(end());
              return nop;
            } else {
              assertFunction(sink);
              sinks.push(sink);
              if (sinks.length === 1) {
                unsubscribeFromSource = subscribe(_this.handleEvent);
              }
              assertFunction(unsubscribeFromSource);
              return function () {
                removeSink(sink);
                if (!_this.hasSubscribers()) {
                  return unsubscribeFromSource();
                }
              };
            }
          };
        }
        return Dispatcher;
      }();
      PropertyDispatcher = function (_super) {
        __extends(PropertyDispatcher, _super);
        function PropertyDispatcher(subscribe, handleEvent) {
          var current, ended, push, _this = this;
          PropertyDispatcher.__super__.constructor.call(this, subscribe, handleEvent);
          current = None;
          push = this.push;
          subscribe = this.subscribe;
          ended = false;
          this.push = function (event) {
            if (event.isEnd()) {
              ended = true;
            }
            if (event.hasValue()) {
              current = new Some(event.value());
            }
            return push.apply(_this, [event]);
          };
          this.subscribe = function (sink) {
            var initSent, reply, shouldBounceInitialValue;
            initSent = false;
            shouldBounceInitialValue = function () {
              return _this.hasSubscribers() || ended;
            };
            reply = current.filter(shouldBounceInitialValue).map(function (val) {
              return sink(initial(val));
            });
            if (reply.getOrElse(Bacon.more) === Bacon.noMore) {
              return nop;
            } else if (ended) {
              sink(end());
              return nop;
            } else {
              return subscribe.apply(_this, [sink]);
            }
          };
        }
        return PropertyDispatcher;
      }(Dispatcher);
      Bus = function (_super) {
        __extends(Bus, _super);
        function Bus() {
          var dispatcher, ended, guardedSink, sink, subscribeAll, subscribeInput, subscribeThis, subscriptions, unsubAll, unsubscribeInput, _this = this;
          sink = void 0;
          subscriptions = [];
          ended = false;
          guardedSink = function (input) {
            return function (event) {
              if (event.isEnd()) {
                unsubscribeInput(input);
                return Bacon.noMore;
              } else {
                return sink(event);
              }
            };
          };
          unsubAll = function () {
            var sub, _i, _len;
            for (_i = 0, _len = subscriptions.length; _i < _len; _i++) {
              sub = subscriptions[_i];
              if (sub.unsub != null) {
                sub.unsub();
              }
            }
            return subscriptions = [];
          };
          subscribeInput = function (subscription) {
            return subscription.unsub = subscription.input.subscribe(guardedSink(subscription.input));
          };
          unsubscribeInput = function (input) {
            var i, sub, _i, _len;
            for (i = _i = 0, _len = subscriptions.length; _i < _len; i = ++_i) {
              sub = subscriptions[i];
              if (sub.input === input) {
                if (sub.unsub != null) {
                  sub.unsub();
                }
                subscriptions.splice(i, 1);
                return;
              }
            }
          };
          subscribeAll = function (newSink) {
            var subscription, unsubFuncs, _i, _len, _ref1;
            sink = newSink;
            unsubFuncs = [];
            _ref1 = cloneArray(subscriptions);
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              subscription = _ref1[_i];
              subscribeInput(subscription);
            }
            return unsubAll;
          };
          dispatcher = new Dispatcher(subscribeAll);
          subscribeThis = function (sink) {
            return dispatcher.subscribe(sink);
          };
          Bus.__super__.constructor.call(this, subscribeThis);
          this.plug = function (input) {
            var sub;
            if (ended) {
              return;
            }
            sub = { input: input };
            subscriptions.push(sub);
            if (sink != null) {
              subscribeInput(sub);
            }
            return function () {
              return unsubscribeInput(input);
            };
          };
          this.push = function (value) {
            if (sink != null) {
              return sink(next(value));
            }
          };
          this.error = function (error) {
            if (sink != null) {
              return sink(new Error(error));
            }
          };
          this.end = function () {
            ended = true;
            unsubAll();
            if (sink != null) {
              return sink(end());
            }
          };
        }
        return Bus;
      }(EventStream);
      Some = function () {
        function Some(value) {
          this.value = value;
        }
        Some.prototype.getOrElse = function () {
          return this.value;
        };
        Some.prototype.get = function () {
          return this.value;
        };
        Some.prototype.filter = function (f) {
          if (f(this.value)) {
            return new Some(this.value);
          } else {
            return None;
          }
        };
        Some.prototype.map = function (f) {
          return new Some(f(this.value));
        };
        Some.prototype.forEach = function (f) {
          return f(this.value);
        };
        Some.prototype.isDefined = true;
        Some.prototype.toArray = function () {
          return [this.value];
        };
        return Some;
      }();
      None = {
        getOrElse: function (value) {
          return value;
        },
        filter: function () {
          return None;
        },
        map: function () {
          return None;
        },
        forEach: function () {
        },
        isDefined: false,
        toArray: function () {
          return [];
        }
      };
      Bacon.EventStream = EventStream;
      Bacon.Property = Property;
      Bacon.Observable = Observable;
      Bacon.Bus = Bus;
      Bacon.Initial = Initial;
      Bacon.Next = Next;
      Bacon.End = End;
      Bacon.Error = Error;
      nop = function () {
      };
      latter = function (_, x) {
        return x;
      };
      former = function (x, _) {
        return x;
      };
      initial = function (value) {
        return new Initial(_.always(value));
      };
      next = function (value) {
        return new Next(_.always(value));
      };
      end = function () {
        return new End;
      };
      isEvent = function (x) {
        return x != null && x.isEvent != null && x.isEvent();
      };
      toEvent = function (x) {
        if (isEvent(x)) {
          return x;
        } else {
          return next(x);
        }
      };
      cloneArray = function (xs) {
        return xs.slice(0);
      };
      cloneObject = function (src) {
        var clone, key, value;
        clone = {};
        for (key in src) {
          value = src[key];
          clone[key] = value;
        }
        return clone;
      };
      indexOf = Array.prototype.indexOf ? function (xs, x) {
        return xs.indexOf(x);
      } : function (xs, x) {
        var i, y, _i, _len;
        for (i = _i = 0, _len = xs.length; _i < _len; i = ++_i) {
          y = xs[i];
          if (x === y) {
            return i;
          }
        }
        return -1;
      };
      remove = function (x, xs) {
        var i;
        i = indexOf(xs, x);
        if (i >= 0) {
          return xs.splice(i, 1);
        }
      };
      assert = function (message, condition) {
        if (!condition) {
          throw message;
        }
      };
      assertEvent = function (event) {
        assert('not an event : ' + event, event.isEvent != null);
        return assert('not event', event.isEvent());
      };
      assertFunction = function (f) {
        return assert('not a function : ' + f, isFunction(f));
      };
      isFunction = function (f) {
        return typeof f === 'function';
      };
      assertArray = function (xs) {
        return assert('not an array : ' + xs, xs instanceof Array);
      };
      assertString = function (x) {
        return assert('not a string : ' + x, typeof x === 'string');
      };
      methodCall = function (obj, method, args) {
        assertString(method);
        if (args === void 0) {
          args = [];
        }
        return function (value) {
          return obj[method].apply(obj, args.concat([value]));
        };
      };
      partiallyApplied = function (f, args) {
        return function (value) {
          return f.apply(null, args.concat([value]));
        };
      };
      makeFunction = function (f, args) {
        if (isFunction(f)) {
          if (args.length) {
            return partiallyApplied(f, args);
          } else {
            return f;
          }
        } else if (isFieldKey(f)) {
          return toFieldExtractor(f, args);
        } else if (typeof f === 'object' && args.length) {
          return methodCall(f, _.head(args), _.tail(args));
        } else {
          return _.always(f);
        }
      };
      isFieldKey = function (f) {
        return typeof f === 'string' && f.length > 1 && f.charAt(0) === '.';
      };
      Bacon.isFieldKey = isFieldKey;
      toFieldExtractor = function (f, args) {
        var partFuncs, parts;
        parts = f.slice(1).split('.');
        partFuncs = _.map(toSimpleExtractor(args), parts);
        return function (value) {
          var _i, _len;
          for (_i = 0, _len = partFuncs.length; _i < _len; _i++) {
            f = partFuncs[_i];
            value = f(value);
          }
          return value;
        };
      };
      toSimpleExtractor = function (args) {
        return function (key) {
          return function (value) {
            var fieldValue;
            fieldValue = value[key];
            if (isFunction(fieldValue)) {
              return fieldValue.apply(value, args);
            } else {
              return fieldValue;
            }
          };
        };
      };
      toFieldKey = function (f) {
        return f.slice(1);
      };
      toCombinator = function (f) {
        var key;
        if (isFunction(f)) {
          return f;
        } else if (isFieldKey(f)) {
          key = toFieldKey(f);
          return function (left, right) {
            return left[key](right);
          };
        } else {
          return assert('not a function or a field key: ' + f, false);
        }
      };
      toOption = function (v) {
        if (v instanceof Some || v === None) {
          return v;
        } else {
          return new Some(v);
        }
      };
      if (typeof define !== 'undefined' && define !== null && define.amd != null) {
        if (typeof define === 'function') {
          define(function () {
            return Bacon;
          });
        }
      }
      _ = {
        head: function (xs) {
          return xs[0];
        },
        always: function (x) {
          return function () {
            return x;
          };
        },
        empty: function (xs) {
          return xs.length === 0;
        },
        tail: function (xs) {
          return xs.slice(1, xs.length);
        },
        filter: function (f, xs) {
          var filtered, x, _i, _len;
          filtered = [];
          for (_i = 0, _len = xs.length; _i < _len; _i++) {
            x = xs[_i];
            if (f(x)) {
              filtered.push(x);
            }
          }
          return filtered;
        },
        map: function (f, xs) {
          var x, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = xs.length; _i < _len; _i++) {
            x = xs[_i];
            _results.push(f(x));
          }
          return _results;
        },
        each: function (xs, f) {
          var key, value, _results;
          _results = [];
          for (key in xs) {
            value = xs[key];
            _results.push(f(key, value));
          }
          return _results;
        },
        toArray: function (xs) {
          if (xs instanceof Array) {
            return xs;
          } else {
            return [xs];
          }
        },
        contains: function (xs, x) {
          return indexOf(xs, x) !== -1;
        },
        id: function (x) {
          return x;
        },
        last: function (xs) {
          return xs[xs.length - 1];
        }
      };
      Bacon._ = _;
    }.call(this));
  });
  global.Psy = require('/main.coffee');
}.call(this, this));