// Generated by CoffeeScript 1.6.3
(function() {
  var DataTable, utils, _,
    __hasProp = {}.hasOwnProperty;

  _ = require('lodash');

  utils = require("./utils");

  DataTable = (function() {
    function DataTable(vars) {
      var key, samelen, value, varlen;
      if (vars == null) {
        vars = {};
      }
      varlen = _.map(vars, function(x) {
        return x.length;
      });
      samelen = _.all(varlen, function(x) {
        return x === varlen[0];
      });
      if (!samelen) {
        throw "arguments to DataTable must all have same length.";
      }
      for (key in vars) {
        value = vars[key];
        this[key] = value;
      }
    }

    DataTable.prototype.show = function() {
      var i, _i, _ref, _results;
      console.log("DataTable: rows: " + (this.nrow()) + " columns: " + (this.ncol()));
      _results = [];
      for (i = _i = 0, _ref = this.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(console.log(this.record(i)));
      }
      return _results;
    };

    DataTable.fromRecords = function(records, union) {
      var allkeys, key, rec, vars, _i, _j, _k, _len, _len1, _len2;
      if (union == null) {
        union = true;
      }
      allkeys = _.uniq(_.flatten(_.map(records, function(rec) {
        return _.keys(rec);
      })));
      vars = {};
      for (_i = 0, _len = allkeys.length; _i < _len; _i++) {
        key = allkeys[_i];
        vars[key] = [];
      }
      for (_j = 0, _len1 = records.length; _j < _len1; _j++) {
        rec = records[_j];
        for (_k = 0, _len2 = allkeys.length; _k < _len2; _k++) {
          key = allkeys[_k];
          vars[key].push(rec[key] || null);
        }
      }
      return new DataTable(vars);
    };

    DataTable.build = function(vars) {
      if (vars == null) {
        vars = {};
      }
      return Object.seal(new DataTable(vars));
    };

    DataTable.rbind = function(tab1, tab2, union) {
      var col1, col2, keys1, keys2, name, out, sharedKeys, _i, _len;
      if (union == null) {
        union = false;
      }
      keys1 = _.keys(tab1);
      keys2 = _.keys(tab2);
      sharedKeys = union ? _.union(keys1, keys2) : _.intersection(keys1, keys2);
      out = {};
      for (_i = 0, _len = sharedKeys.length; _i < _len; _i++) {
        name = sharedKeys[_i];
        col1 = tab1[name];
        col2 = tab2[name];
        if (!col1) {
          col1 = utils.repLen([null], tab1.nrow());
        }
        if (!col2) {
          col2 = utils.repLen([null], tab2.nrow());
        }
        out[name] = col1.concat(col2);
      }
      return new DataTable(out);
    };

    DataTable.cbind = function(tab1, tab2) {
      var diffkeys, key, out, _i, _len;
      if (tab1.nrow() !== tab2.nrow()) {
        throw "cbind requires arguments to have same number of rows";
      }
      out = _.cloneDeep(tab1);
      diffkeys = _.difference(_.keys(tab2), _.keys(tab1));
      for (_i = 0, _len = diffkeys.length; _i < _len; _i++) {
        key = diffkeys[_i];
        out[key] = tab2[key];
      }
      return out;
    };

    DataTable.expand = function(vars, unique, nreps) {
      var d, i, key, name, nargs, nm, nx, orep, out, r1, r2, r3, repfac, value, _i, _j, _results;
      if (vars == null) {
        vars = {};
      }
      if (unique == null) {
        unique = true;
      }
      if (nreps == null) {
        nreps = 1;
      }
      if (unique) {
        out = {};
        for (name in vars) {
          value = vars[name];
          out[name] = _.unique(value);
        }
        vars = out;
      }
      nargs = _.size(vars);
      nm = _.keys(vars);
      repfac = 1;
      d = _.map(vars, function(x) {
        return x.length;
      });
      orep = _.reduce(d, function(x, acc) {
        return x * acc;
      });
      out = {};
      for (key in vars) {
        value = vars[key];
        nx = value.length;
        orep = orep / nx;
        r1 = utils.rep([repfac], nx);
        r2 = utils.rep((function() {
          _results = [];
          for (var _i = 0; 0 <= nx ? _i < nx : _i > nx; 0 <= nx ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this), r1);
        r3 = utils.rep(r2, orep);
        out[key] = (function() {
          var _j, _len, _results1;
          _results1 = [];
          for (_j = 0, _len = r3.length; _j < _len; _j++) {
            i = r3[_j];
            _results1.push(value[i]);
          }
          return _results1;
        })();
        repfac = repfac * nx;
      }
      if (nreps > 1) {
        for (i = _j = 1; 1 <= nreps ? _j <= nreps : _j >= nreps; i = 1 <= nreps ? ++_j : --_j) {
          out = _.merge(out, out);
        }
      }
      return new DataTable(out);
    };

    DataTable.prototype.subset = function(key, filter) {
      var el, i, keep, name, out, val, value;
      keep = (function() {
        var _i, _len, _ref, _results;
        _ref = this[key];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          val = _ref[_i];
          if (filter(val)) {
            _results.push(true);
          } else {
            _results.push(false);
          }
        }
        return _results;
      }).call(this);
      out = {};
      for (name in this) {
        if (!__hasProp.call(this, name)) continue;
        value = this[name];
        out[name] = (function() {
          var _i, _len, _results;
          _results = [];
          for (i = _i = 0, _len = value.length; _i < _len; i = ++_i) {
            el = value[i];
            if (keep[i] === true) {
              _results.push(el);
            }
          }
          return _results;
        })();
      }
      return new DataTable(out);
    };

    DataTable.prototype.whichRow = function(where) {
      var count, i, key, nkeys, out, rec, value, _i, _ref;
      out = [];
      nkeys = _.keys(where).length;
      for (i = _i = 0, _ref = this.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        rec = this.record(i);
        count = utils.asArray((function() {
          var _results;
          _results = [];
          for (key in where) {
            value = where[key];
            _results.push(rec[key] === value);
          }
          return _results;
        })());
        count = _.map(count, function(x) {
          if (x) {
            return 1;
          } else {
            return 0;
          }
        });
        count = _.reduce(utils.asArray(count), function(sum, num) {
          return sum + num;
        });
        if (count === nkeys) {
          out.push(i);
        }
      }
      return out;
    };

    DataTable.prototype.select = function(where) {
      var count, i, key, nkeys, out, rec, value, _i, _ref;
      out = [];
      nkeys = _.keys(where).length;
      for (i = _i = 0, _ref = this.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        rec = this.record(i);
        count = utils.asArray((function() {
          var _results;
          _results = [];
          for (key in where) {
            value = where[key];
            _results.push(rec[key] === value);
          }
          return _results;
        })());
        count = _.map(count, function(x) {
          if (x) {
            return 1;
          } else {
            return 0;
          }
        });
        count = _.reduce(utils.asArray(count), function(sum, num) {
          return sum + num;
        });
        if (count === nkeys) {
          out.push(rec);
        }
      }
      return out;
    };

    DataTable.prototype.nrow = function() {
      var lens, name, value;
      lens = (function() {
        var _results;
        _results = [];
        for (name in this) {
          if (!__hasProp.call(this, name)) continue;
          value = this[name];
          _results.push(value.length);
        }
        return _results;
      }).call(this);
      return _.max(lens);
    };

    DataTable.prototype.ncol = function() {
      return Object.keys(this).length;
    };

    DataTable.prototype.colnames = function() {
      return Object.keys(this);
    };

    DataTable.prototype.record = function(index) {
      var name, rec, value;
      rec = {};
      for (name in this) {
        if (!__hasProp.call(this, name)) continue;
        value = this[name];
        rec[name] = value[index];
      }
      return rec;
    };

    DataTable.prototype.replicate = function(nreps) {
      var name, out, value,
        _this = this;
      out = {};
      for (name in this) {
        if (!__hasProp.call(this, name)) continue;
        value = this[name];
        out[name] = _.flatten(_.times(nreps, function(n) {
          return value;
        }));
      }
      return new DataTable(out);
    };

    DataTable.prototype.bindcol = function(name, column) {
      if (column.length !== this.nrow()) {
        throw "new column must be same length as existing DataTable object: column.length is  " + column.length + " and this.length is  " + (this.nrow());
      }
      this[name] = column;
      return this;
    };

    DataTable.prototype.bindrow = function(rows) {
      var key, record, value, _i, _len;
      if (!_.isArray(rows)) {
        rows = [rows];
      }
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        record = rows[_i];
        console.log(record);
        for (key in record) {
          if (!__hasProp.call(record, key)) continue;
          value = record[key];
          if (!_.has(this, key)) {
            throw new Error("DataTable has no field named " + key);
          } else {
            this[key].push(value);
          }
        }
      }
      return this;
    };

    return DataTable;

  })();

  exports.DataTable = DataTable;

}).call(this);

/*
//@ sourceMappingURL=datatable.map
*/
