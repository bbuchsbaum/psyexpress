// Generated by CoffeeScript 1.6.3
(function() {
  var AbsoluteLayout, Arrow, Background, Bacon, Blank, CanvasBorder, Circle, Clear, ClickResponse, Confirm, FirstResponse, FixationCross, GridLayout, GridLines, Group, KeypressResponse, KineticContext, KineticStimFactory, Layout, Markdown, MousepressResponse, MultipleChoice, Paragraph, Picture, Prompt, Psy, Q, Rectangle, Response, Sequence, Sound, SpaceKeyResponse, StartButton, Stimulus, Text, TextInput, Timeout, TypedResponse, computeGridCells, convertPercentageToFraction, convertToCoordinate, disableBrowserBack, doTimer, getTimestamp, isPercentage, position, _, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Psy = require("./PsyCloud");

  Bacon = require("./lib/Bacon").Bacon;

  _ = require('lodash');

  Q = require("q");

  if (typeof window !== "undefined" && window !== null ? window.performance.now : void 0) {
    console.log("Using high performance timer");
    getTimestamp = function() {
      return window.performance.now();
    };
  } else if (typeof window !== "undefined" && window !== null ? window.performance.webkitNow : void 0) {
    console.log("Using webkit high performance timer");
    getTimestamp = function() {
      return window.performance.webkitNow();
    };
  } else {
    console.log("Using low performance timer");
    getTimestamp = function() {
      return new Date().getTime();
    };
  }

  doTimer = function(length, oncomplete) {
    var instance, start;
    start = getTimestamp();
    instance = function() {
      var diff, half;
      diff = getTimestamp() - start;
      if (diff >= length) {
        return oncomplete(diff);
      } else {
        half = Math.max((length - diff) / 2, 1);
        if (half < 20) {
          half = 1;
        }
        return window.setTimeout(instance, half);
      }
    };
    return window.setTimeout(instance, 1);
  };

  this.browserBackDisabled = false;

  disableBrowserBack = function() {
    var rx;
    if (!this.browserBackDisabled) {
      rx = /INPUT|SELECT|TEXTAREA/i;
      this.browserBackDisabled = true;
      return $(document).bind("keydown keypress", function(e) {
        if (e.which === 8) {
          if (!rx.test(e.target.tagName) || e.target.disabled || e.target.readOnly) {
            return e.preventDefault();
          }
        }
      });
    }
  };

  isPercentage = function(perc) {
    return _.isString(perc) && perc.slice(-1) === "%";
  };

  convertPercentageToFraction = function(perc, dim) {
    var frac;
    frac = parseFloat(perc) / 100;
    frac = Math.min(1, frac);
    frac = Math.max(0, frac);
    return frac * dim;
  };

  convertToCoordinate = function(val, d) {
    if (isPercentage(val)) {
      return val = convertPercentageToFraction(val, d);
    } else {
      return Math.min(val, d);
    }
  };

  computeGridCells = function(rows, cols, bounds) {
    var col, row, _i, _results;
    _results = [];
    for (row = _i = 0; 0 <= rows ? _i < rows : _i > rows; row = 0 <= rows ? ++_i : --_i) {
      _results.push((function() {
        var _j, _results1;
        _results1 = [];
        for (col = _j = 0; 0 <= cols ? _j < cols : _j > cols; col = 0 <= cols ? ++_j : --_j) {
          _results1.push({
            x: bounds.x + bounds.width / cols * col,
            y: bounds.y + bounds.height / rows * row,
            width: bounds.width / cols,
            height: bounds.height / rows
          });
        }
        return _results1;
      })());
    }
    return _results;
  };

  exports.Layout = Layout = (function() {
    function Layout() {}

    Layout.prototype.computePosition = function(dim, stim, constraints) {};

    return Layout;

  })();

  exports.AbsoluteLayout = AbsoluteLayout = (function(_super) {
    __extends(AbsoluteLayout, _super);

    function AbsoluteLayout() {
      _ref = AbsoluteLayout.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    AbsoluteLayout.prototype.computePosition = function(dim, constraints) {
      var x, y;
      x = convertToCoordinate(constraints[0], dim[0]);
      y = convertToCoordinate(constraints[1], dim[1]);
      return [x, y];
    };

    return AbsoluteLayout;

  })(Layout);

  exports.GridLayout = GridLayout = (function(_super) {
    __extends(GridLayout, _super);

    function GridLayout(rows, cols, bounds) {
      this.rows = rows;
      this.cols = cols;
      this.bounds = bounds;
      this.ncells = this.rows * this.cols;
      this.cells = this.computeCells();
    }

    GridLayout.prototype.computeCells = function() {
      return computeGridCells(this.rows, this.cols, this.bounds);
    };

    GridLayout.prototype.computePosition = function(dim, constraints) {
      var cell;
      console.log("grid layout computing position");
      if (dim[0] !== this.bounds.width && dim[1] !== this.bounds.height) {
        this.bounds.width = dim[0];
        this.bounds.height = dim[1];
        this.cells = this.computeCells();
      }
      console.log("constraints", constraints);
      cell = this.cells[constraints[0]][constraints[1]];
      console.log("grid cell is", cell);
      return [cell.x + cell.width / 2, cell.y + cell.height / 2];
    };

    return GridLayout;

  })(Layout);

  exports.Stimulus = Stimulus = (function() {
    function Stimulus() {}

    Stimulus.prototype.spec = {};

    Stimulus.overlay = false;

    Stimulus.prototype.layout = new AbsoluteLayout();

    Stimulus.prototype.stopped = false;

    Stimulus.prototype.computeCoordinates = function(context, position) {
      var cpos;
      console.log("computing coordinates");
      if (position) {
        console.log("position", position);
        cpos = this.layout.computePosition([context.width(), context.height()], position);
        console.log("cpos", cpos);
        return cpos;
      } else if (this.spec.x && this.spec.y) {
        return [this.spec.x, this.spec.y];
      } else {
        return [0, 0];
      }
    };

    Stimulus.prototype.reset = function() {
      return this.stopped = false;
    };

    Stimulus.prototype.render = function(context, layer) {};

    Stimulus.prototype.stop = function() {
      return this.stopped = true;
    };

    Stimulus.prototype.id = function() {
      return this.spec.id || _.uniqueId();
    };

    return Stimulus;

  })();

  exports.Response = Response = (function(_super) {
    __extends(Response, _super);

    function Response() {
      _ref1 = Response.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    Response.prototype.activate = function(context) {};

    return Response;

  })(Stimulus);

  exports.Timeout = Timeout = (function(_super) {
    __extends(Timeout, _super);

    function Timeout(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        duration: 2000
      });
      this.oninstance = function(steps, count) {
        return console.log(steps, count);
      };
    }

    Timeout.prototype.activate = function(context) {
      var deferred, start,
        _this = this;
      deferred = Q.defer();
      start = getTimestamp();
      console.log("time stamp", start);
      doTimer(this.spec.duration, function(diff) {
        return deferred.resolve(diff);
      });
      return deferred.promise;
    };

    return Timeout;

  })(Response);

  exports.Prompt = Prompt = (function(_super) {
    __extends(Prompt, _super);

    function Prompt(spec) {
      this.spec = spec != null ? spec : {};
      this.spec = _.defaults(this.spec, {
        title: "",
        delay: 0,
        defaultValue: ""
      });
    }

    Prompt.prototype.activate = function(context) {
      var deferred, promise,
        _this = this;
      deferred = Q.defer();
      promise = Q.delay(this.spec.delay);
      promise.then(function(f) {
        return vex.dialog.prompt({
          message: _this.spec.title,
          placeholder: _this.spec.defaultValue,
          className: 'vex-theme-wireframe',
          callback: function(value) {
            return deferred.resolve(value);
          }
        });
      });
      return deferred.promise;
    };

    return Prompt;

  })(Response);

  exports.Confirm = Confirm = (function(_super) {
    __extends(Confirm, _super);

    function Confirm(spec) {
      this.spec = spec != null ? spec : {};
      this.spec = _.defaults(this.spec, {
        message: "",
        delay: 0,
        defaultValue: ""
      });
    }

    Confirm.prototype.activate = function(context) {
      var deferred, promise,
        _this = this;
      deferred = Q.defer();
      promise = Q.delay(this.spec.delay);
      promise.then(function(f) {
        return vex.dialog.confirm({
          message: _this.spec.message,
          className: 'vex-theme-wireframe',
          callback: function(value) {
            return deferred.resolve(value);
          }
        });
      });
      return deferred.promise;
    };

    return Confirm;

  })(Response);

  exports.TypedResponse = TypedResponse = (function() {
    function TypedResponse(spec) {
      this.spec = spec != null ? spec : {};
      this.spec = _.defaults(this.spec, {
        left: 250,
        top: 250,
        defaultValue: ""
      });
    }

    TypedResponse.prototype.activate = function(context) {
      var cursor, deferred, enterPressed, freeText, keyStream, text, xoffset,
        _this = this;
      deferred = Q.defer();
      enterPressed = false;
      freeText = "____";
      text = new fabric.Text(freeText, {
        top: this.spec.top,
        left: this.spec.left,
        fontSize: 50,
        textAlign: "left"
      });
      context.canvas.add(text);
      xoffset = text.width / 2;
      cursor = new fabric.Line([this.spec.left, this.spec.top + text.height / 2, this.spec.left, this.spec.top - (text.height / 2)]);
      context.canvas.add(cursor);
      keyStream = context.keypressStream();
      keyStream.takeWhile(function(x) {
        return enterPressed === false;
      }).onValue(function(event) {
        var char;
        if (event.keyCode === 13) {
          enterPressed = true;
          return deferred.resolve(freeText);
        } else {
          char = String.fromCharCode(event.keyCode);
          freeText = freeText + char;
          text.setText(freeText);
          text.set({
            "left": _this.spec.left + (text.width / 2 - xoffset)
          });
          console.log(text.width);
          console.log(text.height);
          return context.canvas.renderAll();
        }
      });
      return deferred.promise;
    };

    return TypedResponse;

  })();

  exports.MousepressResponse = MousepressResponse = (function(_super) {
    __extends(MousepressResponse, _super);

    function MousepressResponse() {}

    MousepressResponse.prototype.activate = function(context) {
      var deferred, mouse,
        _this = this;
      deferred = Q.defer();
      mouse = context.mousepressStream();
      mouse.stream.take(1).onValue(function(event) {
        mouse.stop();
        return deferred.resolve(event);
      });
      return deferred.promise;
    };

    return MousepressResponse;

  })(Response);

  exports.KeypressResponse = KeypressResponse = (function(_super) {
    __extends(KeypressResponse, _super);

    function KeypressResponse(spec) {
      this.spec = spec != null ? spec : {};
      this.spec = _.defaults(this.spec, {
        keys: ['n', 'm'],
        correct: ['n'],
        timeout: 3000
      });
    }

    KeypressResponse.prototype.activate = function(context) {
      var deferred, keyStream,
        _this = this;
      deferred = Q.defer();
      keyStream = context.keypressStream();
      keyStream.filter(function(event) {
        var char;
        char = String.fromCharCode(event.keyCode);
        return _.contains(_this.spec.keys, char);
      }).take(1).onValue(function(filtered) {
        var Acc;
        Acc = _.contains(_this.spec.correct, String.fromCharCode(filtered.keyCode));
        context.logEvent("KeyPress", getTimestamp());
        context.logEvent("$ACC", Acc);
        return deferred.resolve(event);
      });
      return deferred.promise;
    };

    return KeypressResponse;

  })(Response);

  exports.SpaceKeyResponse = SpaceKeyResponse = (function(_super) {
    __extends(SpaceKeyResponse, _super);

    function SpaceKeyResponse(spec) {
      this.spec = spec != null ? spec : {};
    }

    SpaceKeyResponse.prototype.activate = function(context) {
      var deferred, keyStream,
        _this = this;
      deferred = Q.defer();
      keyStream = context.keypressStream();
      keyStream.filter(function(event) {
        var char;
        char = String.fromCharCode(event.keyCode);
        console.log(char);
        console.log(event.keyCode);
        return event.keyCode === 32;
      }).take(1).onValue(function(event) {
        console.log("resolving space key");
        context.logEvent("SpaceKey", getTimestamp());
        return deferred.resolve(event);
      });
      return deferred.promise;
    };

    return SpaceKeyResponse;

  })(Response);

  exports.FirstResponse = FirstResponse = (function(_super) {
    __extends(FirstResponse, _super);

    function FirstResponse(responses) {
      this.responses = responses;
    }

    FirstResponse.prototype.activate = function(context) {
      var deferred, promises,
        _this = this;
      deferred = Q.defer();
      promises = _.map(this.responses, function(resp) {
        return resp.activate(context).then(function() {
          return deferred.resolve(resp);
        });
      });
      return deferred.promise;
    };

    return FirstResponse;

  })(Response);

  exports.ClickResponse = ClickResponse = (function(_super) {
    __extends(ClickResponse, _super);

    function ClickResponse(id) {
      this.id = id;
    }

    ClickResponse.prototype.activate = function(context) {
      var deferred, element,
        _this = this;
      element = context.stage.get("#" + this.id);
      if (!element) {
        throw "cannot find element with id" + this.id;
      }
      deferred = Q.defer();
      element.on("click", function(ev) {
        context.logEvent("Click", getTimestamp());
        return deferred.resolve(ev);
      });
      return deferred.promise;
    };

    return ClickResponse;

  })(Response);

  exports.GridLines = GridLines = (function(_super) {
    __extends(GridLines, _super);

    function GridLines(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        x: 0,
        y: 0,
        rows: 3,
        cols: 3,
        stroke: "black",
        strokeWidth: 2
      });
    }

    GridLines.prototype.render = function(context, layer) {
      var i, line, x, y, _i, _j, _ref2, _ref3, _results;
      for (i = _i = 0, _ref2 = this.spec.rows; 0 <= _ref2 ? _i <= _ref2 : _i >= _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        y = this.spec.y + (i * context.height() / this.spec.rows);
        line = new Kinetic.Line({
          points: [this.spec.x, y, this.spec.x + context.width(), y],
          stroke: this.spec.stroke,
          strokeWidth: this.spec.strokeWidth,
          dashArray: this.spec.dashArray
        });
        layer.add(line);
      }
      _results = [];
      for (i = _j = 0, _ref3 = this.spec.cols; 0 <= _ref3 ? _j <= _ref3 : _j >= _ref3; i = 0 <= _ref3 ? ++_j : --_j) {
        x = this.spec.x + (i * context.width() / this.spec.cols);
        line = new Kinetic.Line({
          points: [x, this.spec.y, x, this.spec.y + context.height()],
          stroke: this.spec.stroke,
          strokeWidth: this.spec.strokeWidth,
          dashArray: this.spec.dashArray
        });
        _results.push(layer.add(line));
      }
      return _results;
    };

    return GridLines;

  })(Stimulus);

  exports.TextInput = TextInput = (function(_super) {
    __extends(TextInput, _super);

    function TextInput(spec) {
      if (spec == null) {
        spec = {};
      }
      disableBrowserBack();
      this.spec = _.defaults(spec, {
        x: 100,
        y: 100,
        width: 200,
        height: 40,
        defaultValue: "",
        fill: "#FAF5E6",
        stroke: "#0099FF",
        strokeWidth: 1,
        content: ""
      });
    }

    TextInput.prototype.getChar = function(e) {
      if (e.keyCode !== 16) {
        if (e.keyCode >= 65 && e.keyCode <= 90) {
          if (e.shiftKey) {
            return String.fromCharCode(e.keyCode);
          } else {
            return String.fromCharCode(e.keyCode + 32);
          }
        } else if (e.keyCode >= 48 && e.keyCode <= 57) {
          return String.fromCharCode(e.keyCode);
        } else {
          console.log("key code is", e.keyCode);
          switch (e.keyCode) {
            case 186:
              return ";";
            case 187:
              return "=";
            case 188:
              return ",";
            case 189:
              return "-";
            default:
              return "";
          }
        }
      } else {
        return String.fromCharCode(e.keyCode);
      }
    };

    TextInput.prototype.animateCursor = function(layer, cursor) {
      var flashTime,
        _this = this;
      flashTime = 0;
      return new Kinetic.Animation(function(frame) {
        if (frame.time > (flashTime + 500)) {
          flashTime = frame.time;
          if (cursor.getOpacity() === 1) {
            cursor.setOpacity(0);
          } else {
            cursor.setOpacity(1);
          }
          return layer.draw();
        }
      }, layer);
    };

    TextInput.prototype.render = function(context, layer) {
      var cursor, cursorBlink, enterPressed, fsize, group, keyStream, text, textContent, textRect,
        _this = this;
      textRect = new Kinetic.Rect({
        x: this.spec.x,
        y: this.spec.y,
        width: this.spec.width,
        height: this.spec.height,
        fill: this.spec.fill,
        cornerRadius: 4,
        lineJoin: "round",
        stroke: this.spec.stroke,
        strokeWidth: this.spec.strokeWidth
      });
      textContent = this.spec.content;
      fsize = .85 * this.spec.height;
      text = new Kinetic.Text({
        text: this.spec.content,
        x: this.spec.x + 2,
        y: this.spec.y - 5,
        height: this.spec.height,
        fontSize: fsize,
        fill: "black",
        padding: 10,
        align: "left"
      });
      cursor = new Kinetic.Rect({
        x: text.getX() + text.getWidth() - 7,
        y: this.spec.y + 5,
        width: 1.5,
        height: text.getHeight() - 10,
        fill: "black"
      });
      enterPressed = false;
      keyStream = context.keydownStream();
      keyStream.takeWhile(function(x) {
        return enterPressed === false && !_this.stopped;
      }).onValue(function(event) {
        var char;
        if (event.keyCode === 13) {
          return enterPressed = true;
        } else if (event.keyCode === 8) {
          console.log("delete key");
          textContent = textContent.slice(0, -1);
          text.setText(textContent);
          cursor.setX(text.getX() + text.getWidth() - 7);
          return layer.draw();
        } else if (text.getWidth() > textRect.getWidth()) {

        } else {
          char = _this.getChar(event);
          console.log("char is", char);
          textContent += char;
          text.setText(textContent);
          cursor.setX(text.getX() + text.getWidth() - 7);
          return layer.draw();
        }
      });
      cursorBlink = this.animateCursor(layer, cursor);
      cursorBlink.start();
      group = new Kinetic.Group({});
      group.add(textRect);
      group.add(cursor);
      group.add(text);
      return layer.add(group);
    };

    return TextInput;

  })(Stimulus);

  exports.Sound = Sound = (function() {
    function Sound(url) {
      this.url = url;
      this.sound = new buzz.sound(this.url);
    }

    Sound.prototype.render = function(context) {
      return this.sound.play();
    };

    return Sound;

  })();

  exports.Picture = Picture = (function(_super) {
    __extends(Picture, _super);

    function Picture(spec) {
      var _this = this;
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        url: "http://www.html5canvastutorials.com/demos/assets/yoda.jpg",
        x: 0,
        y: 0
      });
      this.imageObj = new Image();
      this.image = null;
      this.imageObj.onload = function() {
        return _this.image = new Kinetic.Image({
          x: _this.spec.x,
          y: _this.spec.y,
          image: _this.imageObj,
          width: _this.spec.width || _this.imageObj.width,
          height: _this.spec.height || _this.imageObj.height
        });
      };
      this.imageObj.src = this.spec.url;
    }

    Picture.prototype.render = function(context, layer) {
      return layer.add(this.image);
    };

    return Picture;

  })(Stimulus);

  exports.Group = Group = (function(_super) {
    __extends(Group, _super);

    function Group(stims, layout) {
      var stim, _i, _len, _ref2;
      this.stims = stims;
      if (layout) {
        this.layout = layout;
        _ref2 = this.stims;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          stim = _ref2[_i];
          stim.layout = layout;
        }
      }
    }

    Group.prototype.render = function(context, layer) {
      var stim, _i, _len, _ref2, _results;
      console.log("rendering group");
      _ref2 = this.stims;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        stim = _ref2[_i];
        console.log("rendering stim of group", stim);
        _results.push(stim.render(context, layer));
      }
      return _results;
    };

    return Group;

  })(Stimulus);

  exports.Background = Background = (function(_super) {
    __extends(Background, _super);

    function Background(stims, fill) {
      this.stims = stims != null ? stims : [];
      this.fill = fill != null ? fill : "white";
    }

    Background.prototype.render = function(context, layer) {
      var background, stim, _i, _len, _ref2, _results;
      background = new Kinetic.Rect({
        x: 0,
        y: 0,
        width: context.width(),
        height: context.height(),
        name: 'background',
        fill: this.fill
      });
      layer.add(background);
      _ref2 = this.stims;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        stim = _ref2[_i];
        _results.push(stim.render(context, layer));
      }
      return _results;
    };

    return Background;

  })(Stimulus);

  exports.Sequence = Sequence = (function(_super) {
    __extends(Sequence, _super);

    Sequence.prototype.stopped = false;

    function Sequence(stims, soa, clear, times) {
      var i;
      this.stims = stims;
      this.soa = soa;
      this.clear = clear != null ? clear : true;
      this.times = times != null ? times : 1;
      if (this.soa.length !== this.stims.length) {
        this.soa = Psy.repLen(this.soa, this.stims.length);
      }
      this.onsets = (function() {
        var _i, _ref2, _results;
        _results = [];
        for (i = _i = 0, _ref2 = this.soa.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
          _results.push(_.reduce(this.soa.slice(0, +i + 1 || 9e9), function(x, acc) {
            return x + acc;
          }));
        }
        return _results;
      }).call(this);
    }

    Sequence.prototype.genseq = function(context, layer) {
      var deferred, _i, _ref2, _results,
        _this = this;
      deferred = Q.defer();
      _.forEach((function() {
        _results = [];
        for (var _i = 0, _ref2 = this.stims.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; 0 <= _ref2 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this), function(i) {
        var ev, stim;
        console.log("genseq", i);
        ev = new Timeout({
          duration: _this.onsets[i]
        });
        stim = _this.stims[i];
        return ev.activate(context).then(function() {
          if (!_this.stopped) {
            if (_this.clear) {
              context.clearContent();
            }
            stim.render(context, layer);
            context.draw();
          }
          if (i === _this.stims.length - 1) {
            console.log("resolving promise", i);
            return deferred.resolve(1);
          }
        });
      });
      return deferred.promise;
    };

    Sequence.prototype.render = function(context, layer) {
      var i, result, _i, _ref2,
        _this = this;
      result = Q.resolve(0);
      for (i = _i = 0, _ref2 = this.times; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        result = result.then(function() {
          return _this.genseq(context, layer);
        });
      }
      return result;
    };

    Sequence.prototype.stop = function() {
      return this.stopped = true;
    };

    return Sequence;

  })(Stimulus);

  exports.Blank = Blank = (function(_super) {
    __extends(Blank, _super);

    function Blank(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        fill: "white"
      });
    }

    Blank.prototype.render = function(context, layer) {
      var blank;
      blank = new Kinetic.Rect({
        x: 0,
        y: 0,
        width: context.width(),
        height: context.height(),
        fill: this.spec.fill
      });
      return layer.add(blank);
    };

    return Blank;

  })(Stimulus);

  exports.Clear = Clear = (function(_super) {
    __extends(Clear, _super);

    function Clear(spec) {
      this.spec = spec != null ? spec : {};
    }

    Clear.prototype.render = function(context, layer) {
      return context.clearContent(true);
    };

    return Clear;

  })(Stimulus);

  exports.Arrow = Arrow = (function(_super) {
    __extends(Arrow, _super);

    function Arrow(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        x: 100,
        y: 100,
        length: 100,
        angle: 0,
        thickness: 40,
        fill: "red",
        arrowSize: 50
      });
    }

    Arrow.prototype.render = function(context, layer) {
      var group, rect, triangle, _this;
      rect = new Kinetic.Rect({
        x: 0,
        y: 0,
        width: this.spec.length,
        height: this.spec.thickness,
        fill: this.spec.fill,
        stroke: this.spec.stroke,
        strokeWidth: this.spec.strokeWidth,
        opacity: this.spec.opacity
      });
      _this = this;
      triangle = new Kinetic.Shape({
        drawFunc: function(cx) {
          cx.beginPath();
          cx.moveTo(_this.spec.length, -_this.spec.arrowSize / 2.0);
          cx.lineTo(_this.spec.length + _this.spec.arrowSize, _this.spec.thickness / 2.0);
          cx.lineTo(_this.spec.length, _this.spec.thickness + _this.spec.arrowSize / 2.0);
          cx.closePath();
          return cx.fillStrokeShape(this);
        },
        fill: _this.spec.fill,
        stroke: this.spec.stroke,
        strokeWidth: this.spec.strokeWidth,
        opacity: this.spec.opacity
      });
      group = new Kinetic.Group({
        x: this.spec.x,
        y: this.spec.y,
        rotationDeg: this.spec.angle,
        offset: [0, this.spec.thickness / 2.0]
      });
      group.add(rect);
      group.add(triangle);
      return layer.add(group);
    };

    return Arrow;

  })(Stimulus);

  exports.Rectangle = Rectangle = (function(_super) {
    __extends(Rectangle, _super);

    function Rectangle(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        x: 0,
        y: 0,
        width: 100,
        height: 100,
        fill: 'red'
      });
      this.spec = _.omit(this.spec, function(value, key) {
        return !value;
      });
      if (this.spec.layout) {
        this.layout = this.spec.layout;
      }
    }

    Rectangle.prototype.render = function(context, layer) {
      var coords, rect;
      console.log("rendering rectangle");
      coords = this.computeCoordinates(context, this.spec.position);
      console.log("position is", coords);
      rect = new Kinetic.Rect({
        x: coords[0],
        y: coords[1],
        width: this.spec.width,
        height: this.spec.height,
        fill: this.spec.fill,
        stroke: this.spec.stroke,
        strokeWidth: this.spec.strokeWidth
      });
      console.log("adding rect to layer", rect);
      return layer.add(rect);
    };

    return Rectangle;

  })(Stimulus);

  exports.Circle = Circle = (function(_super) {
    __extends(Circle, _super);

    function Circle(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        x: 100,
        y: 100,
        radius: 50,
        fill: 'red',
        opacity: 1
      });
    }

    Circle.prototype.render = function(context, layer) {
      var circ;
      circ = new Kinetic.Circle({
        x: this.spec.x,
        y: this.spec.y,
        radius: this.spec.radius,
        fill: this.spec.fill,
        stroke: this.spec.stroke,
        strokeWidth: this.spec.strokeWidth,
        opacity: this.spec.opacity
      });
      return layer.add(circ);
    };

    return Circle;

  })(Stimulus);

  exports.FixationCross = FixationCross = (function(_super) {
    __extends(FixationCross, _super);

    function FixationCross(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        strokeWidth: 8,
        length: 150,
        fill: 'black'
      });
    }

    FixationCross.prototype.render = function(context, layer) {
      var group, horz, vert, x, y;
      x = context.width() / 2;
      y = context.height() / 2;
      horz = new Kinetic.Rect({
        x: x - this.spec.length / 2,
        y: y,
        width: this.spec.length,
        height: this.spec.strokeWidth,
        fill: this.spec.fill
      });
      vert = new Kinetic.Rect({
        x: x - this.spec.strokeWidth / 2,
        y: y - this.spec.length / 2 + this.spec.strokeWidth / 2,
        width: this.spec.strokeWidth,
        height: this.spec.length,
        fill: this.spec.fill
      });
      group = new Kinetic.Group();
      group.add(horz);
      group.add(vert);
      return layer.add(group);
    };

    return FixationCross;

  })(Stimulus);

  exports.CanvasBorder = CanvasBorder = (function(_super) {
    __extends(CanvasBorder, _super);

    function CanvasBorder(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        strokeWidth: 5,
        stroke: "black"
      });
    }

    CanvasBorder.prototype.render = function(context, layer) {
      var border;
      border = new Kinetic.Rect({
        x: 0,
        y: 0,
        width: context.width(),
        height: context.height(),
        strokeWidth: this.spec.strokeWidth,
        stroke: this.spec.stroke
      });
      return layer.add(border);
    };

    return CanvasBorder;

  })(Stimulus);

  exports.StartButton = StartButton = (function(_super) {
    __extends(StartButton, _super);

    function StartButton(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        width: 150,
        height: 75
      });
    }

    StartButton.prototype.render = function(context, layer) {
      var button, group, text, xcenter, ycenter;
      xcenter = context.width() / 2;
      ycenter = context.height() / 2;
      group = new Kinetic.Group({
        id: this.spec.id
      });
      text = new Kinetic.Text({
        text: "Start",
        x: xcenter - this.spec.width / 2,
        y: ycenter - this.spec.height / 2,
        width: this.spec.width,
        height: this.spec.height,
        fontSize: 30,
        fill: "white",
        fontFamily: "Arial",
        align: "center",
        padding: 20
      });
      button = new Kinetic.Rect({
        x: xcenter - this.spec.width / 2,
        y: ycenter - text.getHeight() / 2,
        width: this.spec.width,
        height: text.getHeight(),
        fill: "black",
        cornerRadius: 10,
        stroke: "LightSteelBlue",
        strokeWidth: 5
      });
      group.add(button);
      group.add(text);
      return layer.add(group);
    };

    return StartButton;

  })(Stimulus);

  position = function(pos, offx, offy, width, height, xy) {
    switch (pos) {
      case "center":
        return [offx + width * .5, offy + height * .5];
      case "center-left":
        return [offx + width * 1 / 6, offy + height * .5];
      case "center-right":
        return [offx + width * 5 / 6, offy + height * .5];
      case "top-left":
        return [offx + width * 1 / 6, offy + height * 1 / 6];
      case "top-right":
        return [offx + width * 5 / 6, offy + height * 1 / 6];
      case "top-center":
        return [offx + width * .5, offy + height * 1 / 6];
      case "bottom-left":
        return [offx + width * 1 / 6, offy + height * 5 / 6];
      case "bottom-right":
        return [offx + width * 5 / 6, offy + height * 5 / 6];
      case "bottom-center":
        return [offx + width * .5, offy + height * 5 / 6];
      default:
        return xy;
    }
  };

  exports.Text = Text = (function(_super) {
    __extends(Text, _super);

    function Text(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        content: "Text",
        x: 5,
        y: 5,
        width: null,
        fill: "black",
        fontSize: 50,
        fontFamily: "Arial",
        lineHeight: 1,
        textAlign: "center",
        position: null
      });
    }

    Text.prototype.render = function(context, layer) {
      var text, xy;
      text = new Kinetic.Text({
        x: this.spec.x,
        y: this.spec.y,
        text: this.spec.content,
        fontSize: this.spec.fontSize,
        fontFamily: this.spec.fontFamily,
        fill: this.spec.fill,
        listening: false
      });
      if (this.spec.position) {
        xy = position(this.spec.position, -text.getWidth() / 2, -text.getHeight() / 2, context.width(), context.height(), [this.spec.x, this.spec.y]);
        text.setPosition({
          x: xy[0],
          y: xy[1]
        });
      }
      return layer.add(text);
    };

    return Text;

  })(Stimulus);

  exports.Paragraph = Paragraph = (function(_super) {
    __extends(Paragraph, _super);

    function Paragraph(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        content: "",
        x: 50,
        y: 50,
        width: 600,
        fill: "black",
        fontSize: 18,
        fontFamily: "Arial",
        lineHeight: 1,
        textAlign: "center",
        position: null
      });
    }

    return Paragraph;

  })(Stimulus);

  exports.Markdown = Markdown = (function(_super) {
    __extends(Markdown, _super);

    function Markdown(input) {
      this.html = markdown.toHTML(input);
    }

    Markdown.prototype.render = function(context, layer) {
      console.log(this.html);
      context.clearHtml();
      return context.appendHtml(this.html);
    };

    return Markdown;

  })(Stimulus);

  exports.MultipleChoice = MultipleChoice = (function(_super) {
    __extends(MultipleChoice, _super);

    function MultipleChoice(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        question: "What is your name?",
        options: ["Bill", "John", "Fred"],
        x: 10,
        y: 10,
        fill: "black",
        fontSize: 24,
        fontFamily: "Arial",
        textAlign: "center",
        position: null
      });
    }

    MultipleChoice.prototype.render = function(context, layer) {
      var choice, i, questionText, _i, _ref2, _results;
      questionText = new Kinetic.Text({
        x: this.spec.x,
        y: this.spec.y,
        text: this.spec.question,
        fontSize: this.spec.fontSize,
        fontFamily: this.spec.fontFamily,
        fill: this.spec.fill
      });
      layer.add(questionText);
      _results = [];
      for (i = _i = 0, _ref2 = this.spec.options.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        choice = new Kinetic.Text({
          x: this.spec.x + 5,
          y: questionText.getHeight() * (i + 1) + 30,
          text: (i + 1) + ") " + this.spec.options[i],
          fontSize: this.spec.fontSize,
          fontFamily: this.spec.fontFamily,
          fill: this.spec.fill,
          padding: 20,
          align: 'left'
        });
        _results.push(layer.add(choice));
      }
      return _results;
    };

    return MultipleChoice;

  })(Stimulus);

  exports.KineticContext = KineticContext = (function(_super) {
    __extends(KineticContext, _super);

    function KineticContext(stage) {
      this.stage = stage;
      this.contentLayer = new Kinetic.Layer({
        clearBeforeDraw: true
      });
      this.backgroundLayer = new Kinetic.Layer({
        clearBeforeDraw: true
      });
      this.background = new Background([], {
        fill: "white"
      });
      this.stage.add(this.backgroundLayer);
      this.stage.add(this.contentLayer);
      this.backgroundLayer.on("click", function() {
        return console.log("background layer click");
      });
      this.stage.on("mousedown", function() {
        return console.log("stage mouse down");
      });
      this.stage.getContent().addEventListener('mousedown', function() {
        return console.log("stage dom click");
      });
      this.insertHTMLDiv();
      $("document").keydown(function() {
        return console.log("container key down!!!!");
      });
    }

    KineticContext.prototype.insertHTMLDiv = function() {
      $("canvas").css("position", "absolute");
      $(".kineticjs-content").css("position", "absolute");
      $("#container").append("<div id=\"htmlcontainer\" class=\"htmllayer\">\n        <p>This <em>is</em> heading 1</p>\n\n</div>");
      $("#htmlcontainer").css("position", "absolute");
      $("#htmlcontainer").css("z-index", 999);
      return $("#container").attr("tabindex", 0);
    };

    KineticContext.prototype.clearHtml = function() {
      return $("#htmlcontainer").empty();
    };

    KineticContext.prototype.appendHtml = function(input) {
      $("#htmlcontainer").addClass("htmllayer");
      $("#htmlcontainer").append(input);
      return $("#htmlcontainer").show();
    };

    KineticContext.prototype.hideHtml = function() {
      return $("#htmlcontainer").hide();
    };

    KineticContext.prototype.setBackground = function(newBackground) {
      this.background = newBackground;
      this.backgroundLayer.removeChildren();
      return this.background.render(this, this.backgroundLayer);
    };

    KineticContext.prototype.drawBackground = function() {
      return this.backgroundLayer.draw();
    };

    KineticContext.prototype.clearBackground = function() {
      return this.backgroundLayer.removeChildren();
    };

    KineticContext.prototype.clearContent = function(draw) {
      if (draw == null) {
        draw = false;
      }
      console.log("clearing html");
      this.hideHtml();
      this.contentLayer.removeChildren();
      if (draw) {
        this.draw();
      }
      return console.log("finished clearing content");
    };

    KineticContext.prototype.draw = function() {
      $('#container').focus();
      this.backgroundLayer.draw();
      return this.contentLayer.draw();
    };

    KineticContext.prototype.width = function() {
      return this.stage.getWidth();
    };

    KineticContext.prototype.height = function() {
      return this.stage.getHeight();
    };

    KineticContext.prototype.offsetX = function() {
      return this.stage.getOffsetX();
    };

    KineticContext.prototype.offsetY = function() {
      return this.stage.getOffsetY();
    };

    KineticContext.prototype.keydownStream = function() {
      return $("body").asEventStream("keydown");
    };

    KineticContext.prototype.keypressStream = function() {
      return $("body").asEventStream("keypress");
    };

    KineticContext.prototype.mousepressStream = function() {
      var MouseBus;
      MouseBus = (function() {
        function MouseBus() {
          var _this = this;
          this.stream = new Bacon.Bus();
          this.handler = function(x) {
            return _this.stream.push(x);
          };
          this.stage.on("mousedown", this.handler);
        }

        MouseBus.prototype.stop = function() {
          this.stage.off("mousedown", this.handler);
          return this.stream.end();
        };

        return MouseBus;

      })();
      return new MouseBus();
    };

    return KineticContext;

  })(Psy.ExperimentContext);

  exports.KineticStimFactory = KineticStimFactory = (function(_super) {
    __extends(KineticStimFactory, _super);

    function KineticStimFactory() {
      _ref2 = KineticStimFactory.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    KineticStimFactory.prototype.makeLayout = function(name, params, context) {
      switch (name) {
        case "Grid":
          console.log("Grid params", params);
          return new GridLayout(params[0], params[1], {
            x: 0,
            y: 0,
            width: context.width(),
            height: context.height()
          });
      }
    };

    KineticStimFactory.prototype.makeStimulus = function(name, params, context) {
      var callee, i, layoutName, layoutParams, names, props, stims;
      callee = arguments.callee;
      switch (name) {
        case "FixationCross":
          return new FixationCross(params);
        case "Clear":
          return new Clear(params);
        case "Rectangle":
          console.log("when Rectangle", params);
          return new Rectangle(params);
        case "Text":
          return new Text(params);
        case "Group":
          names = _.map(params.stims, function(stim) {
            return _.keys(stim)[0];
          });
          props = _.map(params.stims, function(stim) {
            return _.values(stim)[0];
          });
          stims = (function() {
            var _i, _ref3, _results;
            _results = [];
            for (i = _i = 0, _ref3 = names.length; 0 <= _ref3 ? _i < _ref3 : _i > _ref3; i = 0 <= _ref3 ? ++_i : --_i) {
              _results.push(callee(names[i], props[i]));
            }
            return _results;
          })();
          console.log("Group stims", stims);
          layoutName = _.keys(params.layout)[0];
          layoutParams = _.values(params.layout)[0];
          return new Group(stims, this.makeLayout(layoutName, layoutParams, context));
        default:
          throw "No Stimulus type of name " + name;
      }
    };

    KineticStimFactory.prototype.makeResponse = function(name, params, context) {
      switch (name) {
        case "KeyPressed":
          return new KeypressResponse(params);
        case "Timeout":
          return new Timeout(params);
        default:
          throw "No Response type of name " + name;
      }
    };

    KineticStimFactory.prototype.makeEvent = function(stim, response) {
      return new Psy.Event(stim, response);
    };

    return KineticStimFactory;

  })(Psy.StimFactory);

}).call(this);

/*
//@ sourceMappingURL=Elements.map
*/
