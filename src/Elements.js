// Generated by CoffeeScript 1.4.0
(function() {
  var AbsoluteLayout, Arrow, Background, Bacon, Blank, CanvasBorder, Circle, Clear, ClickResponse, FirstResponse, FixationCross, GridLayout, GridLines, Group, KeypressResponse, KineticContext, KineticStimFactory, Layout, MousepressResponse, Picture, Prompt, Psy, Q, Rectangle, Response, Sequence, Sound, SpaceKeyResponse, StartButton, Stimulus, Text, TextInput, Timeout, TypedResponse, computeGridCells, convertPercentageToFraction, convertToCoordinate, disableBrowserBack, doTimer, getTimestamp, isPercentage, position, x, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Psy = require("./PsyCloud");

  Bacon = require("./lib/Bacon").Bacon;

  _ = require('lodash');

  Q = require("q");

  if (typeof window !== "undefined" && window !== null ? window.performance.now : void 0) {
    console.log("Using high performance timer");
    getTimestamp = function() {
      return window.performance.now();
    };
  } else if (typeof window !== "undefined" && window !== null ? window.performance.webkitNow : void 0) {
    console.log("Using webkit high performance timer");
    getTimestamp = function() {
      return window.performance.webkitNow();
    };
  } else {
    console.log("Using low performance timer");
    getTimestamp = function() {
      return new Date().getTime();
    };
  }

  doTimer = function(length, oncomplete) {
    var instance, start;
    start = getTimestamp();
    instance = function() {
      var diff, half;
      diff = getTimestamp() - start;
      if (diff >= length) {
        return oncomplete(diff);
      } else {
        half = Math.max((length - diff) / 2, 1);
        if (half < 20) {
          half = 1;
        }
        return window.setTimeout(instance, half);
      }
    };
    return window.setTimeout(instance, 1);
  };

  this.browserBackDisabled = false;

  disableBrowserBack = function() {
    var rx;
    if (!this.browserBackDisabled) {
      rx = /INPUT|SELECT|TEXTAREA/i;
      this.browserBackDisabled = true;
      return $(document).bind("keydown keypress", function(e) {
        if (e.which === 8) {
          if (!rx.test(e.target.tagName) || e.target.disabled || e.target.readOnly) {
            return e.preventDefault();
          }
        }
      });
    }
  };

  isPercentage = function(perc) {
    return _.isString(perc) && perc.slice(-1) === "%";
  };

  convertPercentageToFraction = function(perc, dim) {
    var frac;
    frac = parseFloat(perc) / 100;
    frac = Math.min(1, frac);
    frac = Math.max(0, frac);
    return frac * dim;
  };

  convertToCoordinate = function(val, d) {
    if (isPercentage(val)) {
      return val = convertPercentageToFraction(val, d);
    } else {
      return Math.min(val, d);
    }
  };

  computeGridCells = function(rows, cols, bounds) {
    var col, row, _i, _results;
    _results = [];
    for (row = _i = 0; 0 <= rows ? _i < rows : _i > rows; row = 0 <= rows ? ++_i : --_i) {
      _results.push((function() {
        var _j, _results1;
        _results1 = [];
        for (col = _j = 0; 0 <= cols ? _j < cols : _j > cols; col = 0 <= cols ? ++_j : --_j) {
          _results1.push({
            x: bounds.x + bounds.width / cols * col,
            y: bounds.y + bounds.height / rows * row,
            width: bounds.width / cols,
            height: bounds.height / rows
          });
        }
        return _results1;
      })());
    }
    return _results;
  };

  exports.Layout = Layout = (function() {

    function Layout() {}

    Layout.prototype.computePosition = function(dim, stim, constraints) {};

    return Layout;

  })();

  exports.AbsoluteLayout = AbsoluteLayout = (function(_super) {

    __extends(AbsoluteLayout, _super);

    function AbsoluteLayout() {
      return AbsoluteLayout.__super__.constructor.apply(this, arguments);
    }

    AbsoluteLayout.prototype.computePosition = function(dim, constraints) {
      var x, y;
      x = convertToCoordinate(constraints[0], dim[0]);
      y = convertToCoordinate(constraints[1], dim[1]);
      return [x, y];
    };

    return AbsoluteLayout;

  })(Layout);

  exports.GridLayout = GridLayout = (function(_super) {

    __extends(GridLayout, _super);

    function GridLayout(rows, cols, bounds) {
      this.rows = rows;
      this.cols = cols;
      this.bounds = bounds;
      this.ncells = this.rows * this.cols;
      this.cells = this.computeCells();
    }

    GridLayout.prototype.computeCells = function() {
      return computeGridCells(this.rows, this.cols, this.bounds);
    };

    GridLayout.prototype.computePosition = function(dim, constraints) {
      var cell;
      if (dim[0] !== this.bounds.width && dim[1] !== this.bounds.height) {
        this.bounds.width = dim[0];
        this.bounds.height = dim[1];
        this.cells = this.computeCells();
      }
      cell = this.cells[constraints[0]][constraints[1]];
      return [cell.x + cell.width / 2, cell.y + cell.height / 2];
    };

    return GridLayout;

  })(Layout);

  exports.Stimulus = Stimulus = (function() {

    function Stimulus() {}

    Stimulus.prototype.spec = {};

    Stimulus.prototype.layout = new AbsoluteLayout();

    Stimulus.prototype.overlay = false;

    Stimulus.prototype.stopped = false;

    Stimulus.prototype.computeCoordinates = function(context, position) {
      if (position) {
        console.log(position);
        return this.layout.computePosition([context.width(), context.height()], position);
      } else if (this.spec.x && this.spec.y) {
        return [this.spec.x, this.spec.y];
      } else {
        return [0, 0];
      }
    };

    Stimulus.prototype.reset = function() {
      return this.stopped = false;
    };

    Stimulus.prototype.render = function(context, layer) {};

    Stimulus.prototype.stop = function() {
      return this.stopped = true;
    };

    Stimulus.prototype.id = function() {
      return this.spec.id || _.uniqueId();
    };

    return Stimulus;

  })();

  exports.Response = Response = (function(_super) {

    __extends(Response, _super);

    function Response() {
      return Response.__super__.constructor.apply(this, arguments);
    }

    Response.prototype.activate = function(context) {};

    return Response;

  })(Stimulus);

  exports.Timeout = Timeout = (function(_super) {

    __extends(Timeout, _super);

    function Timeout(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        duration: 2000
      });
      this.oninstance = function(steps, count) {
        return console.log(steps, count);
      };
    }

    Timeout.prototype.activate = function(context) {
      var deferred, start,
        _this = this;
      deferred = Q.defer();
      start = getTimestamp();
      console.log("time stamp", start);
      doTimer(this.spec.duration, function(diff) {
        return deferred.resolve(diff);
      });
      return deferred.promise;
    };

    return Timeout;

  })(Response);

  exports.Prompt = Prompt = (function(_super) {

    __extends(Prompt, _super);

    function Prompt(spec) {
      this.spec = spec != null ? spec : {};
      this.spec = _.defaults(this.spec, {
        title: "",
        delay: 0,
        defaultValue: ""
      });
    }

    Prompt.prototype.activate = function(context) {
      var deferred, promise,
        _this = this;
      deferred = Q.defer();
      promise = Q.delay(this.spec.delay);
      promise.then(function(f) {
        var result;
        result = window.prompt(_this.spec.title, _this.spec.defaultValue);
        return deferred.resolve(result);
      });
      return deferred.promise;
    };

    return Prompt;

  })(Response);

  exports.TypedResponse = TypedResponse = (function() {

    function TypedResponse(spec) {
      this.spec = spec != null ? spec : {};
      this.spec = _.defaults(this.spec, {
        left: 250,
        top: 250,
        defaultValue: ""
      });
    }

    TypedResponse.prototype.activate = function(context) {
      var cursor, deferred, enterPressed, freeText, keyStream, text, xoffset,
        _this = this;
      deferred = Q.defer();
      enterPressed = false;
      freeText = "____";
      text = new fabric.Text(freeText, {
        top: this.spec.top,
        left: this.spec.left,
        fontSize: 50,
        textAlign: "left"
      });
      context.canvas.add(text);
      xoffset = text.width / 2;
      cursor = new fabric.Line([this.spec.left, this.spec.top + text.height / 2, this.spec.left, this.spec.top - (text.height / 2)]);
      context.canvas.add(cursor);
      keyStream = context.keypressStream();
      keyStream.takeWhile(function(x) {
        return enterPressed === false;
      }).onValue(function(event) {
        var char;
        if (event.keyCode === 13) {
          enterPressed = true;
          return deferred.resolve(freeText);
        } else {
          char = String.fromCharCode(event.keyCode);
          freeText = freeText + char;
          text.setText(freeText);
          text.set({
            "left": _this.spec.left + (text.width / 2 - xoffset)
          });
          console.log(text.width);
          console.log(text.height);
          return context.canvas.renderAll();
        }
      });
      return deferred.promise;
    };

    return TypedResponse;

  })();

  exports.MousepressResponse = MousepressResponse = (function(_super) {

    __extends(MousepressResponse, _super);

    function MousepressResponse() {}

    MousepressResponse.prototype.activate = function(context) {
      var deferred, mouse,
        _this = this;
      deferred = Q.defer();
      mouse = context.mousepressStream();
      mouse.stream.take(1).onValue(function(event) {
        mouse.stop();
        return deferred.resolve(event);
      });
      return deferred.promise;
    };

    return MousepressResponse;

  })(Response);

  exports.KeypressResponse = KeypressResponse = (function(_super) {

    __extends(KeypressResponse, _super);

    function KeypressResponse(spec) {
      this.spec = spec != null ? spec : {};
      this.spec = _.defaults(this.spec, {
        keys: ['n', 'm'],
        correct: ['n'],
        timeout: 3000
      });
    }

    KeypressResponse.prototype.activate = function(context) {
      var deferred, keyStream,
        _this = this;
      deferred = Q.defer();
      keyStream = context.keypressStream();
      keyStream.filter(function(event) {
        var char;
        char = String.fromCharCode(event.keyCode);
        return _.contains(_this.spec.keys, char);
      }).take(1).onValue(function(filtered) {
        var Acc;
        Acc = _.contains(_this.spec.correct, String.fromCharCode(filtered.keyCode));
        context.logEvent("KeyPress", getTimestamp());
        context.logEvent("$ACC", Acc);
        return deferred.resolve(event);
      });
      return deferred.promise;
    };

    return KeypressResponse;

  })(Response);

  exports.SpaceKeyResponse = SpaceKeyResponse = (function(_super) {

    __extends(SpaceKeyResponse, _super);

    function SpaceKeyResponse(spec) {
      this.spec = spec != null ? spec : {};
    }

    SpaceKeyResponse.prototype.activate = function(context) {
      var deferred, keyStream,
        _this = this;
      deferred = Q.defer();
      keyStream = context.keypressStream();
      keyStream.filter(function(event) {
        var char;
        char = String.fromCharCode(event.keyCode);
        console.log(char);
        console.log(event.keyCode);
        return event.keyCode === 32;
      }).take(1).onValue(function(event) {
        context.logEvent("SpaceKey", getTimestamp());
        return deferred.resolve(event);
      });
      return deferred.promise;
    };

    return SpaceKeyResponse;

  })(Response);

  exports.FirstResponse = FirstResponse = (function(_super) {

    __extends(FirstResponse, _super);

    function FirstResponse(responses) {
      this.responses = responses;
    }

    FirstResponse.prototype.activate = function(context) {
      var deferred, promises,
        _this = this;
      deferred = Q.defer();
      promises = _.map(this.responses, function(resp) {
        return resp.activate(context).then(function() {
          return deferred.resolve(resp);
        });
      });
      return deferred.promise;
    };

    return FirstResponse;

  })(Response);

  exports.ClickResponse = ClickResponse = (function(_super) {

    __extends(ClickResponse, _super);

    function ClickResponse(id) {
      this.id = id;
    }

    ClickResponse.prototype.activate = function(context) {
      var deferred, element,
        _this = this;
      element = context.stage.get("#" + this.id);
      if (!element) {
        throw "cannot find element with id" + this.id;
      }
      deferred = Q.defer();
      element.on("click", function(ev) {
        context.logEvent("Click", getTimestamp());
        return deferred.resolve(ev);
      });
      return deferred.promise;
    };

    return ClickResponse;

  })(Response);

  exports.GridLines = GridLines = (function(_super) {

    __extends(GridLines, _super);

    function GridLines(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        x: 0,
        y: 0,
        rows: 3,
        cols: 3,
        stroke: "black",
        strokeWidth: 2
      });
    }

    GridLines.prototype.render = function(context, layer) {
      var i, line, x, y, _i, _j, _ref, _ref1, _results;
      for (i = _i = 0, _ref = this.spec.rows; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        y = this.spec.y + (i * context.height() / this.spec.rows);
        line = new Kinetic.Line({
          points: [this.spec.x, y, this.spec.x + context.width(), y],
          stroke: this.spec.stroke,
          strokeWidth: this.spec.strokeWidth,
          dashArray: this.spec.dashArray
        });
        layer.add(line);
      }
      _results = [];
      for (i = _j = 0, _ref1 = this.spec.cols; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        x = this.spec.x + (i * context.width() / this.spec.cols);
        line = new Kinetic.Line({
          points: [x, this.spec.y, x, this.spec.y + context.height()],
          stroke: this.spec.stroke,
          strokeWidth: this.spec.strokeWidth,
          dashArray: this.spec.dashArray
        });
        _results.push(layer.add(line));
      }
      return _results;
    };

    return GridLines;

  })(Stimulus);

  exports.TextInput = TextInput = (function(_super) {

    __extends(TextInput, _super);

    function TextInput(spec) {
      if (spec == null) {
        spec = {};
      }
      disableBrowserBack();
      this.spec = _.defaults(spec, {
        x: 100,
        y: 100,
        width: 200,
        height: 40,
        defaultValue: "",
        fill: "#FAF5E6",
        stroke: "#0099FF",
        strokeWidth: 1,
        content: ""
      });
    }

    TextInput.prototype.getChar = function(e) {
      if (e.keyCode !== 16) {
        if (e.keyCode >= 65 && e.keyCode <= 90) {
          if (e.shiftKey) {
            return String.fromCharCode(e.keyCode);
          } else {
            return String.fromCharCode(e.keyCode + 32);
          }
        } else if (e.keyCode >= 48 && e.keyCode <= 57) {
          return String.fromCharCode(e.keyCode);
        } else {
          console.log("key code is", e.keyCode);
          switch (e.keyCode) {
            case 186:
              return ";";
            case 187:
              return "=";
            case 188:
              return ",";
            case 189:
              return "-";
            default:
              return "";
          }
        }
      } else {
        return String.fromCharCode(e.keyCode);
      }
    };

    TextInput.prototype.animateCursor = function(layer, cursor) {
      var flashTime,
        _this = this;
      flashTime = 0;
      return new Kinetic.Animation(function(frame) {
        if (frame.time > (flashTime + 500)) {
          flashTime = frame.time;
          if (cursor.getOpacity() === 1) {
            cursor.setOpacity(0);
          } else {
            cursor.setOpacity(1);
          }
          return layer.draw();
        }
      }, layer);
    };

    TextInput.prototype.render = function(context, layer) {
      var cursor, cursorBlink, enterPressed, fsize, group, keyStream, text, textContent, textRect,
        _this = this;
      textRect = new Kinetic.Rect({
        x: this.spec.x,
        y: this.spec.y,
        width: this.spec.width,
        height: this.spec.height,
        fill: this.spec.fill,
        cornerRadius: 4,
        lineJoin: "round",
        stroke: this.spec.stroke,
        strokeWidth: this.spec.strokeWidth
      });
      textContent = this.spec.content;
      fsize = .85 * this.spec.height;
      text = new Kinetic.Text({
        text: this.spec.content,
        x: this.spec.x + 2,
        y: this.spec.y - 5,
        height: this.spec.height,
        fontSize: fsize,
        fill: "black",
        padding: 10,
        align: "left"
      });
      cursor = new Kinetic.Rect({
        x: text.getX() + text.getWidth() - 7,
        y: this.spec.y + 5,
        width: 1.5,
        height: text.getHeight() - 10,
        fill: "black"
      });
      enterPressed = false;
      keyStream = context.keydownStream();
      keyStream.takeWhile(function(x) {
        return enterPressed === false && !_this.stopped;
      }).onValue(function(event) {
        var char;
        if (event.keyCode === 13) {
          return enterPressed = true;
        } else if (event.keyCode === 8) {
          console.log("delete key");
          textContent = textContent.slice(0, -1);
          text.setText(textContent);
          cursor.setX(text.getX() + text.getWidth() - 7);
          return layer.draw();
        } else if (text.getWidth() > textRect.getWidth()) {

        } else {
          char = _this.getChar(event);
          console.log("char is", char);
          textContent += char;
          text.setText(textContent);
          cursor.setX(text.getX() + text.getWidth() - 7);
          return layer.draw();
        }
      });
      cursorBlink = this.animateCursor(layer, cursor);
      cursorBlink.start();
      group = new Kinetic.Group({});
      group.add(textRect);
      group.add(cursor);
      group.add(text);
      return layer.add(group);
    };

    return TextInput;

  })(Stimulus);

  exports.Sound = Sound = (function() {

    function Sound(url) {
      this.url = url;
      this.sound = new buzz.sound(this.url);
    }

    Sound.prototype.render = function(context) {
      return this.sound.play();
    };

    return Sound;

  })();

  exports.Picture = Picture = (function(_super) {

    __extends(Picture, _super);

    function Picture(spec) {
      var _this = this;
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        url: "http://www.html5canvastutorials.com/demos/assets/yoda.jpg",
        x: 0,
        y: 0
      });
      this.imageObj = new Image();
      this.image = null;
      this.imageObj.onload = function() {
        return _this.image = new Kinetic.Image({
          x: _this.spec.x,
          y: _this.spec.y,
          image: _this.imageObj,
          width: _this.spec.width || _this.imageObj.width,
          height: _this.spec.height || _this.imageObj.height
        });
      };
      this.imageObj.src = this.spec.url;
    }

    Picture.prototype.render = function(context, layer) {
      return layer.add(this.image);
    };

    return Picture;

  })(Stimulus);

  exports.Group = Group = (function(_super) {

    __extends(Group, _super);

    function Group(stims, layout) {
      var stim, _i, _len, _ref;
      this.stims = stims;
      this.overlay = true;
      if (layout) {
        this.layout = layout;
        _ref = this.stims;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          stim = _ref[_i];
          stim.layout = layout;
        }
      }
    }

    Group.prototype.render = function(context, layer) {
      var stim, _i, _len, _ref, _results;
      _ref = this.stims;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        stim = _ref[_i];
        _results.push(stim.render(context, layer));
      }
      return _results;
    };

    return Group;

  })(Stimulus);

  exports.Background = Background = (function(_super) {

    __extends(Background, _super);

    function Background(stims, fill) {
      this.stims = stims != null ? stims : [];
      this.fill = fill != null ? fill : "white";
    }

    Background.prototype.render = function(context, layer) {
      var background, stim, _i, _len, _ref, _results;
      background = new Kinetic.Rect({
        x: 0,
        y: 0,
        width: context.width(),
        height: context.height(),
        name: 'background',
        fill: this.fill
      });
      layer.add(background);
      _ref = this.stims;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        stim = _ref[_i];
        _results.push(stim.render(context, layer));
      }
      return _results;
    };

    return Background;

  })(Stimulus);

  exports.Sequence = Sequence = (function(_super) {

    __extends(Sequence, _super);

    Sequence.prototype.stopped = false;

    function Sequence(stims, soa, clear, times) {
      var i;
      this.stims = stims;
      this.soa = soa;
      this.clear = clear != null ? clear : true;
      this.times = times != null ? times : 1;
      if (this.soa.length !== this.stims.length) {
        this.soa = Psy.repLen(this.soa, this.stims.length);
      }
      this.onsets = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.soa.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(_.reduce(this.soa.slice(0, +i + 1 || 9e9), function(x, acc) {
            return x + acc;
          }));
        }
        return _results;
      }).call(this);
    }

    Sequence.prototype.genseq = function(context, layer) {
      var deferred, _i, _ref, _results,
        _this = this;
      deferred = Q.defer();
      _.forEach((function() {
        _results = [];
        for (var _i = 0, _ref = this.stims.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this), function(i) {
        var ev, stim;
        console.log("genseq", i);
        ev = new Timeout({
          duration: _this.onsets[i]
        });
        stim = _this.stims[i];
        return ev.activate(context).then(function() {
          if (!_this.stopped) {
            if (_this.clear) {
              context.clearContent();
            }
            stim.render(context, layer);
            context.draw();
          }
          if (i === _this.stims.length - 1) {
            console.log("resolving promise", i);
            return deferred.resolve(1);
          }
        });
      });
      return deferred.promise;
    };

    Sequence.prototype.render = function(context, layer) {
      var i, result, _i, _ref,
        _this = this;
      result = Q.resolve(0);
      for (i = _i = 0, _ref = this.times; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        result = result.then(function() {
          return _this.genseq(context, layer);
        });
      }
      return result;
    };

    Sequence.prototype.stop = function() {
      return this.stopped = true;
    };

    return Sequence;

  })(Stimulus);

  exports.Blank = Blank = (function(_super) {

    __extends(Blank, _super);

    function Blank(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        fill: "white"
      });
    }

    Blank.prototype.render = function(context, layer) {
      var blank;
      blank = new Kinetic.Rect({
        x: 0,
        y: 0,
        width: context.width(),
        height: context.height(),
        fill: this.spec.fill
      });
      return layer.add(blank);
    };

    return Blank;

  })(Stimulus);

  exports.Clear = Clear = (function(_super) {

    __extends(Clear, _super);

    function Clear(spec) {
      this.spec = spec != null ? spec : {};
    }

    Clear.prototype.render = function(context, layer) {
      return context.clearContent(true);
    };

    return Clear;

  })(Stimulus);

  exports.Arrow = Arrow = (function(_super) {

    __extends(Arrow, _super);

    function Arrow(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        x: 100,
        y: 100,
        length: 100,
        angle: 0,
        thickness: 40,
        fill: "red",
        arrowSize: 50
      });
    }

    Arrow.prototype.render = function(context, layer) {
      var group, rect, triangle, _this;
      rect = new Kinetic.Rect({
        x: 0,
        y: 0,
        width: this.spec.length,
        height: this.spec.thickness,
        fill: this.spec.fill,
        stroke: this.spec.stroke,
        strokeWidth: this.spec.strokeWidth,
        opacity: this.spec.opacity
      });
      _this = this;
      triangle = new Kinetic.Shape({
        drawFunc: function(cx) {
          cx.beginPath();
          cx.moveTo(_this.spec.length, -_this.spec.arrowSize / 2.0);
          cx.lineTo(_this.spec.length + _this.spec.arrowSize, _this.spec.thickness / 2.0);
          cx.lineTo(_this.spec.length, _this.spec.thickness + _this.spec.arrowSize / 2.0);
          cx.closePath();
          return cx.fillStrokeShape(this);
        },
        fill: _this.spec.fill,
        stroke: this.spec.stroke,
        strokeWidth: this.spec.strokeWidth,
        opacity: this.spec.opacity
      });
      group = new Kinetic.Group({
        x: this.spec.x,
        y: this.spec.y,
        rotationDeg: this.spec.angle,
        offset: [0, this.spec.thickness / 2.0]
      });
      group.add(rect);
      group.add(triangle);
      return layer.add(group);
    };

    return Arrow;

  })(Stimulus);

  exports.Rectangle = Rectangle = (function(_super) {

    __extends(Rectangle, _super);

    function Rectangle(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        x: 0,
        y: 0,
        width: 100,
        height: 100,
        fill: 'red'
      });
      this.spec = _.omit(this.spec, function(value, key) {
        return !value;
      });
      if (this.spec.layout) {
        this.layout = this.spec.layout;
      }
    }

    Rectangle.prototype.render = function(context, layer) {
      var coords, rect;
      coords = this.computeCoordinates(context, this.spec.position);
      rect = new Kinetic.Rect({
        x: coords[0],
        y: coords[1],
        width: this.spec.width,
        height: this.spec.height,
        fill: this.spec.fill,
        stroke: this.spec.stroke,
        strokeWidth: this.spec.strokeWidth
      });
      return layer.add(rect);
    };

    return Rectangle;

  })(Stimulus);

  exports.Circle = Circle = (function(_super) {

    __extends(Circle, _super);

    function Circle(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        x: 100,
        y: 100,
        radius: 50,
        fill: 'red',
        opacity: 1
      });
    }

    Circle.prototype.render = function(context, layer) {
      var circ;
      circ = new Kinetic.Circle({
        x: this.spec.x,
        y: this.spec.y,
        radius: this.spec.radius,
        fill: this.spec.fill,
        stroke: this.spec.stroke,
        strokeWidth: this.spec.strokeWidth,
        opacity: this.spec.opacity
      });
      return layer.add(circ);
    };

    return Circle;

  })(Stimulus);

  exports.FixationCross = FixationCross = (function(_super) {

    __extends(FixationCross, _super);

    function FixationCross(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        strokeWidth: 8,
        length: 150,
        fill: 'black'
      });
    }

    FixationCross.prototype.render = function(context, layer) {
      var group, horz, vert, x, y;
      x = context.width() / 2;
      y = context.height() / 2;
      horz = new Kinetic.Rect({
        x: x - this.spec.length / 2,
        y: y,
        width: this.spec.length,
        height: this.spec.strokeWidth,
        fill: this.spec.fill
      });
      vert = new Kinetic.Rect({
        x: x - this.spec.strokeWidth / 2,
        y: y - this.spec.length / 2 + this.spec.strokeWidth / 2,
        width: this.spec.strokeWidth,
        height: this.spec.length,
        fill: this.spec.fill
      });
      group = new Kinetic.Group();
      group.add(horz);
      group.add(vert);
      return layer.add(group);
    };

    return FixationCross;

  })(Stimulus);

  exports.CanvasBorder = CanvasBorder = (function(_super) {

    __extends(CanvasBorder, _super);

    function CanvasBorder(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        strokeWidth: 5,
        stroke: "black"
      });
    }

    CanvasBorder.prototype.render = function(context, layer) {
      var border;
      border = new Kinetic.Rect({
        x: 0,
        y: 0,
        width: context.width(),
        height: context.height(),
        strokeWidth: this.spec.strokeWidth,
        stroke: this.spec.stroke
      });
      return layer.add(border);
    };

    return CanvasBorder;

  })(Stimulus);

  exports.StartButton = StartButton = (function(_super) {

    __extends(StartButton, _super);

    function StartButton(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        width: 150,
        height: 75
      });
    }

    StartButton.prototype.render = function(context, layer) {
      var button, group, text, xcenter, ycenter;
      xcenter = context.width() / 2;
      ycenter = context.height() / 2;
      group = new Kinetic.Group({
        id: this.spec.id
      });
      text = new Kinetic.Text({
        text: "Start",
        x: xcenter - this.spec.width / 2,
        y: ycenter - this.spec.height / 2,
        width: this.spec.width,
        height: this.spec.height,
        fontSize: 30,
        fill: "white",
        fontFamily: "Arial",
        align: "center",
        padding: 20
      });
      button = new Kinetic.Rect({
        x: xcenter - this.spec.width / 2,
        y: ycenter - text.getHeight() / 2,
        width: this.spec.width,
        height: text.getHeight(),
        fill: "black",
        cornerRadius: 10,
        stroke: "LightSteelBlue",
        strokeWidth: 5
      });
      group.add(button);
      group.add(text);
      return layer.add(group);
    };

    return StartButton;

  })(Stimulus);

  position = function(pos, offx, offy, width, height, xy) {
    switch (pos) {
      case "center":
        return [offx + width * .5, offy + height * .5];
      case "center-left":
        return [offx + width * 1 / 6, offy + height * .5];
      case "center-right":
        return [offx + width * 5 / 6, offy + height * .5];
      case "top-left":
        return [offx + width * 1 / 6, offy + height * 1 / 6];
      case "top-right":
        return [offx + width * 5 / 6, offy + height * 1 / 6];
      case "top-center":
        return [offx + width * .5, offy + height * 1 / 6];
      case "bottom-left":
        return [offx + width * 1 / 6, offy + height * 5 / 6];
      case "bottom-right":
        return [offx + width * 5 / 6, offy + height * 5 / 6];
      case "bottom-center":
        return [offx + width * .5, offy + height * 5 / 6];
      default:
        return xy;
    }
  };

  exports.Text = Text = (function(_super) {

    __extends(Text, _super);

    function Text(spec) {
      if (spec == null) {
        spec = {};
      }
      this.spec = _.defaults(spec, {
        content: "Text",
        x: 100,
        y: 100,
        fill: "black",
        fontSize: 50,
        fontFamily: "Arial",
        lineHeight: 1,
        textAlign: "center",
        position: null
      });
    }

    Text.prototype.render = function(context, layer) {
      var text, xy;
      text = new Kinetic.Text({
        x: this.spec.x,
        y: this.spec.y,
        text: this.spec.content,
        fontSize: this.spec.fontSize,
        fontFamily: this.spec.fontFamily,
        fill: this.spec.fill,
        listening: false
      });
      if (this.spec.position) {
        xy = position(this.spec.position, -text.getWidth() / 2, -text.getHeight() / 2, context.width(), context.height(), [this.spec.x, this.spec.y]);
        text.setPosition({
          x: xy[0],
          y: xy[1]
        });
      }
      return layer.add(text);
    };

    return Text;

  })(Stimulus);

  exports.KineticContext = KineticContext = (function(_super) {

    __extends(KineticContext, _super);

    function KineticContext(stage) {
      this.stage = stage;
      this.contentLayer = new Kinetic.Layer({
        clearBeforeDraw: true
      });
      this.backgroundLayer = new Kinetic.Layer({
        clearBeforeDraw: true
      });
      this.background = new Background([], {
        fill: "white"
      });
      this.stage.add(this.backgroundLayer);
      this.stage.add(this.contentLayer);
      this.backgroundLayer.on("click", function() {
        return console.log("background layer click");
      });
      this.stage.on("mousedown", function() {
        return console.log("stage mouse down");
      });
      this.stage.getContent().addEventListener('mousedown', function() {
        return console.log("stage dom click");
      });
    }

    KineticContext.prototype.setBackground = function(newBackground) {
      this.background = newBackground;
      this.backgroundLayer.removeChildren();
      return this.background.render(this, this.backgroundLayer);
    };

    KineticContext.prototype.drawBackground = function() {
      return this.backgroundLayer.draw();
    };

    KineticContext.prototype.clearBackground = function() {
      return this.backgroundLayer.removeChildren();
    };

    KineticContext.prototype.clearContent = function(draw) {
      if (draw == null) {
        draw = false;
      }
      this.contentLayer.removeChildren();
      if (draw) {
        return this.draw();
      }
    };

    KineticContext.prototype.draw = function() {
      this.backgroundLayer.draw();
      return this.contentLayer.draw();
    };

    KineticContext.prototype.width = function() {
      return this.stage.getWidth();
    };

    KineticContext.prototype.height = function() {
      return this.stage.getHeight();
    };

    KineticContext.prototype.offsetX = function() {
      return this.stage.getOffsetX();
    };

    KineticContext.prototype.offsetY = function() {
      return this.stage.getOffsetY();
    };

    KineticContext.prototype.keydownStream = function() {
      return Bacon.fromEventTarget(window, "keydown");
    };

    KineticContext.prototype.keypressStream = function() {
      return Bacon.fromEventTarget(window, "keypress");
    };

    KineticContext.prototype.mousepressStream = function() {
      var MouseBus;
      MouseBus = (function() {

        function MouseBus() {
          var _this = this;
          this.stream = new Bacon.Bus();
          this.handler = function(x) {
            return _this.stream.push(x);
          };
          this.stage.on("mousedown", this.handler);
        }

        MouseBus.prototype.stop = function() {
          this.stage.off("mousedown", this.handler);
          return this.stream.end();
        };

        return MouseBus;

      })();
      return new MouseBus();
    };

    return KineticContext;

  })(Psy.ExperimentContext);

  exports.KineticStimFactory = KineticStimFactory = (function(_super) {

    __extends(KineticStimFactory, _super);

    function KineticStimFactory() {
      return KineticStimFactory.__super__.constructor.apply(this, arguments);
    }

    KineticStimFactory.prototype.makeStimulus = function(name, params) {
      switch (name) {
        case "FixationCross":
          return new FixationCross(params);
        case "Text":
          return new Text(params);
        default:
          throw "No Stimulus type of name " + name;
      }
    };

    KineticStimFactory.prototype.makeResponse = function(name, params) {
      switch (name) {
        case "KeyPressed":
          return new KeypressResponse(params);
        case "Timeout":
          return new Timeout(params);
        default:
          throw "No Response type of name " + name;
      }
    };

    KineticStimFactory.prototype.makeEvent = function(stim, response) {
      return new Psy.Event(stim, response);
    };

    return KineticStimFactory;

  })(Psy.StimFactory);

  x = new Sequence(['a', 'b', 'c'], [0, 1000, 1500]);

}).call(this);
