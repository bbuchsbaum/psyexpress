// Generated by CoffeeScript 1.6.3
(function() {
  var AbsoluteLayout, Background, Bacon, Base, Blank, CanvasBorder, Circle, Clear, ClickResponse, Confirm, FirstResponse, GridLayout, GridLines, Group, HtmlRange, KeyPressResponse, KineticContext, KineticStimFactory, Layout, MousePressResponse, MultipleChoice, Page, Paragraph, Picture, Prompt, Psy, Q, Rectangle, Response, Sequence, Sound, SpaceKeyResponse, StartButton, Stimulus, TextInput, Timeout, TypedResponse, disableBrowserBack, doTimer, getTimestamp, input, lay, li, marked, renderable, ul, utils, _, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Psy = require("./psycloud");

  Bacon = require("./lib/Bacon").Bacon;

  _ = require('lodash');

  Q = require("q");

  marked = require("marked");

  utils = require("./utils");

  lay = require("./layout");

  Base = require("./stimresp");

  Stimulus = Base.Stimulus;

  Response = Base.Response;

  _ref = require('teacup'), renderable = _ref.renderable, ul = _ref.ul, li = _ref.li, input = _ref.input;

  Layout = lay.Layout;

  AbsoluteLayout = lay.AbsoluteLayout;

  GridLayout = lay.GridLayout;

  doTimer = utils.doTimer;

  disableBrowserBack = utils.disableBrowserBack;

  getTimestamp = utils.getTimeStamp;

  exports.Timeout = Timeout = (function(_super) {
    __extends(Timeout, _super);

    function Timeout(spec) {
      if (spec == null) {
        spec = {};
      }
      Timeout.__super__.constructor.call(this, spec, {
        duration: 2000
      });
      this.oninstance = function(steps, count) {
        return console.log(steps, count);
      };
    }

    Timeout.prototype.activate = function(context) {
      var deferred,
        _this = this;
      deferred = Q.defer();
      doTimer(this.spec.duration, function(diff) {
        return deferred.resolve({
          timeout: diff,
          requested: _this.spec.duration
        });
      });
      return deferred.promise;
    };

    return Timeout;

  })(Response);

  exports.Prompt = Prompt = (function(_super) {
    __extends(Prompt, _super);

    function Prompt(spec) {
      if (spec == null) {
        spec = {};
      }
      Prompt.__super__.constructor.call(this, spec, {
        title: "",
        delay: 0,
        defaultValue: ""
      });
    }

    Prompt.prototype.activate = function(context) {
      var deferred, promise,
        _this = this;
      deferred = Q.defer();
      promise = Q.delay(this.spec.delay);
      promise.then(function(f) {
        return vex.dialog.prompt({
          message: _this.spec.title,
          placeholder: _this.spec.defaultValue,
          className: 'vex-theme-wireframe',
          callback: function(value) {
            return deferred.resolve(value);
          }
        });
      });
      return deferred.promise;
    };

    return Prompt;

  })(Response);

  exports.Confirm = Confirm = (function(_super) {
    __extends(Confirm, _super);

    function Confirm(spec) {
      if (spec == null) {
        spec = {};
      }
      Confirm.__super__.constructor.call(this, spec, {
        message: "",
        delay: 0,
        defaultValue: ""
      });
    }

    Confirm.prototype.activate = function(context) {
      var deferred, promise,
        _this = this;
      deferred = Q.defer();
      promise = Q.delay(this.spec.delay);
      promise.then(function(f) {
        return vex.dialog.confirm({
          message: _this.spec.message,
          className: 'vex-theme-wireframe',
          callback: function(value) {
            return deferred.resolve(value);
          }
        });
      });
      return deferred.promise;
    };

    return Confirm;

  })(Response);

  exports.TypedResponse = TypedResponse = (function() {
    function TypedResponse(spec) {
      if (spec == null) {
        spec = {};
      }
      TypedResponse.__super__.constructor.call(this, spec, {
        left: 250,
        top: 250,
        defaultValue: ""
      });
    }

    TypedResponse.prototype.activate = function(context) {
      var cursor, deferred, enterPressed, freeText, keyStream, text, xoffset,
        _this = this;
      deferred = Q.defer();
      enterPressed = false;
      freeText = "____";
      text = new fabric.Text(freeText, {
        top: this.spec.top,
        left: this.spec.left,
        fontSize: 50,
        textAlign: "left"
      });
      context.canvas.add(text);
      xoffset = text.width / 2;
      cursor = new fabric.Line([this.spec.left, this.spec.top + text.height / 2, this.spec.left, this.spec.top - (text.height / 2)]);
      context.canvas.add(cursor);
      keyStream = context.keypressStream();
      keyStream.takeWhile(function(x) {
        return enterPressed === false;
      }).onValue(function(event) {
        var char;
        if (event.keyCode === 13) {
          enterPressed = true;
          return deferred.resolve(freeText);
        } else {
          char = String.fromCharCode(event.keyCode);
          freeText = freeText + char;
          text.setText(freeText);
          text.set({
            "left": _this.spec.left + (text.width / 2 - xoffset)
          });
          console.log(text.width);
          console.log(text.height);
          return context.canvas.renderAll();
        }
      });
      return deferred.promise;
    };

    return TypedResponse;

  })();

  exports.MousePressResponse = MousePressResponse = (function(_super) {
    __extends(MousePressResponse, _super);

    function MousePressResponse() {
      MousePressResponse.__super__.constructor.call(this, {}, {});
    }

    MousePressResponse.prototype.activate = function(context) {
      var deferred, mouse,
        _this = this;
      deferred = Q.de(fer());
      mouse = context.mousepressStream();
      mouse.stream.take(1).onValue(function(event) {
        mouse.stop();
        return deferred.resolve(event);
      });
      return deferred.promise;
    };

    return MousePressResponse;

  })(Response);

  exports.KeyPressResponse = KeyPressResponse = (function(_super) {
    __extends(KeyPressResponse, _super);

    function KeyPressResponse(spec) {
      if (spec == null) {
        spec = {};
      }
      KeyPressResponse.__super__.constructor.call(this, spec, {
        keys: ['n', 'm'],
        correct: ['n'],
        timeout: 3000
      });
      this.name = "KeyPress";
    }

    KeyPressResponse.prototype.activate = function(context) {
      var deferred, keyStream, myname,
        _this = this;
      this.startTime = getTimestamp();
      myname = this.name;
      deferred = Q.defer();
      keyStream = context.keypressStream();
      keyStream.filter(function(event) {
        var char;
        char = String.fromCharCode(event.keyCode);
        return _.contains(_this.spec.keys, char);
      }).take(1).onValue(function(filtered) {
        var Acc, resp, timestamp;
        Acc = _.contains(_this.spec.correct, String.fromCharCode(filtered.keyCode));
        timestamp = getTimestamp();
        resp = {
          name: myname,
          id: _this.id,
          KeyTime: timestamp,
          RT: timestamp - _this.startTime,
          Accuracy: Acc,
          KeyChar: String.fromCharCode(filtered.keyCode)
        };
        context.pushData(resp);
        context.logEvent("KeyPress", getTimestamp());
        context.logEvent("$ACC", Acc);
        console.log("resolving keypress");
        return deferred.resolve(resp);
      });
      return deferred.promise;
    };

    return KeyPressResponse;

  })(Response);

  exports.SpaceKeyResponse = SpaceKeyResponse = (function(_super) {
    __extends(SpaceKeyResponse, _super);

    function SpaceKeyResponse(spec) {
      if (spec == null) {
        spec = {};
      }
      SpaceKeyResponse.__super__.constructor.call(this, spec, {});
    }

    SpaceKeyResponse.prototype.activate = function(context) {
      var deferred, keyStream,
        _this = this;
      deferred = Q.defer();
      keyStream = context.keypressStream();
      keyStream.filter(function(event) {
        var char;
        char = String.fromCharCode(event.keyCode);
        return event.keyCode === 32;
      }).take(1).onValue(function(event) {
        context.logEvent("SpaceKey", getTimestamp());
        return deferred.resolve(event);
      });
      return deferred.promise;
    };

    return SpaceKeyResponse;

  })(Response);

  exports.FirstResponse = FirstResponse = (function(_super) {
    __extends(FirstResponse, _super);

    function FirstResponse(responses) {
      this.responses = responses;
      FirstResponse.__super__.constructor.call(this, {}, {});
    }

    FirstResponse.prototype.activate = function(context) {
      var deferred, promises,
        _this = this;
      deferred = Q.defer();
      promises = _.map(this.responses, function(resp) {
        return resp.activate(context).then(function() {
          return deferred.resolve(resp);
        });
      });
      return deferred.promise;
    };

    return FirstResponse;

  })(Response);

  exports.ClickResponse = ClickResponse = (function(_super) {
    __extends(ClickResponse, _super);

    function ClickResponse(refid) {
      this.refid = refid;
    }

    ClickResponse.prototype.activate = function(context) {
      var deferred, element,
        _this = this;
      element = context.stage.get("#" + this.refid);
      if (!element) {
        throw "cannot find element with id" + this.refid;
      }
      deferred = Q.defer();
      element.on("click", function(ev) {
        context.logEvent("Click", getTimestamp());
        return deferred.resolve(ev);
      });
      return deferred.promise;
    };

    return ClickResponse;

  })(Response);

  exports.GridLines = GridLines = (function(_super) {
    __extends(GridLines, _super);

    function GridLines(spec) {
      if (spec == null) {
        spec = {};
      }
      GridLines.__super__.constructor.call(this, spec, {
        x: 0,
        y: 0,
        rows: 3,
        cols: 3,
        stroke: "black",
        strokeWidth: 2
      });
    }

    GridLines.prototype.render = function(context, layer) {
      var i, line, x, y, _i, _j, _ref1, _ref2, _results;
      for (i = _i = 0, _ref1 = this.spec.rows; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        y = this.spec.y + (i * context.height() / this.spec.rows);
        line = new Kinetic.Line({
          points: [this.spec.x, y, this.spec.x + context.width(), y],
          stroke: this.spec.stroke,
          strokeWidth: this.spec.strokeWidth,
          dashArray: this.spec.dashArray
        });
        layer.add(line);
      }
      _results = [];
      for (i = _j = 0, _ref2 = this.spec.cols; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
        x = this.spec.x + (i * context.width() / this.spec.cols);
        line = new Kinetic.Line({
          points: [x, this.spec.y, x, this.spec.y + context.height()],
          stroke: this.spec.stroke,
          strokeWidth: this.spec.strokeWidth,
          dashArray: this.spec.dashArray
        });
        _results.push(layer.add(line));
      }
      return _results;
    };

    return GridLines;

  })(Stimulus);

  exports.TextInput = TextInput = (function(_super) {
    __extends(TextInput, _super);

    function TextInput(spec) {
      if (spec == null) {
        spec = {};
      }
      disableBrowserBack();
      TextInput.__super__.constructor.call(this, spec, {
        x: 100,
        y: 100,
        width: 200,
        height: 40,
        defaultValue: "",
        fill: "#FAF5E6",
        stroke: "#0099FF",
        strokeWidth: 1,
        content: ""
      });
    }

    TextInput.prototype.getChar = function(e) {
      if (e.keyCode !== 16) {
        if (e.keyCode >= 65 && e.keyCode <= 90) {
          if (e.shiftKey) {
            return String.fromCharCode(e.keyCode);
          } else {
            return String.fromCharCode(e.keyCode + 32);
          }
        } else if (e.keyCode >= 48 && e.keyCode <= 57) {
          return String.fromCharCode(e.keyCode);
        } else {
          switch (e.keyCode) {
            case 186:
              return ";";
            case 187:
              return "=";
            case 188:
              return ",";
            case 189:
              return "-";
            default:
              return "";
          }
        }
      } else {
        return String.fromCharCode(e.keyCode);
      }
    };

    TextInput.prototype.animateCursor = function(layer, cursor) {
      var flashTime,
        _this = this;
      flashTime = 0;
      return new Kinetic.Animation(function(frame) {
        if (frame.time > (flashTime + 500)) {
          flashTime = frame.time;
          if (cursor.getOpacity() === 1) {
            cursor.setOpacity(0);
          } else {
            cursor.setOpacity(1);
          }
          return layer.draw();
        }
      }, layer);
    };

    TextInput.prototype.render = function(context, layer) {
      var cursor, cursorBlink, enterPressed, fsize, group, keyStream, text, textContent, textRect,
        _this = this;
      textRect = new Kinetic.Rect({
        x: this.spec.x,
        y: this.spec.y,
        width: this.spec.width,
        height: this.spec.height,
        fill: this.spec.fill,
        cornerRadius: 4,
        lineJoin: "round",
        stroke: this.spec.stroke,
        strokeWidth: this.spec.strokeWidth
      });
      textContent = this.spec.content;
      fsize = .85 * this.spec.height;
      text = new Kinetic.Text({
        text: this.spec.content,
        x: this.spec.x + 2,
        y: this.spec.y - 5,
        height: this.spec.height,
        fontSize: fsize,
        fill: "black",
        padding: 10,
        align: "left"
      });
      cursor = new Kinetic.Rect({
        x: text.getX() + text.getWidth() - 7,
        y: this.spec.y + 5,
        width: 1.5,
        height: text.getHeight() - 10,
        fill: "black"
      });
      enterPressed = false;
      keyStream = context.keydownStream();
      keyStream.takeWhile(function(x) {
        return enterPressed === false && !_this.stopped;
      }).onValue(function(event) {
        var char;
        if (event.keyCode === 13) {
          return enterPressed = true;
        } else if (event.keyCode === 8) {
          textContent = textContent.slice(0, -1);
          text.setText(textContent);
          cursor.setX(text.getX() + text.getWidth() - 7);
          return layer.draw();
        } else if (text.getWidth() > textRect.getWidth()) {

        } else {
          char = _this.getChar(event);
          textContent += char;
          text.setText(textContent);
          cursor.setX(text.getX() + text.getWidth() - 7);
          return layer.draw();
        }
      });
      cursorBlink = this.animateCursor(layer, cursor);
      cursorBlink.start();
      group = new Kinetic.Group({});
      group.add(textRect);
      group.add(cursor);
      group.add(text);
      return layer.add(group);
    };

    return TextInput;

  })(Stimulus);

  exports.Sound = Sound = (function() {
    function Sound(url) {
      this.url = url;
      this.sound = new buzz.sound(this.url);
    }

    Sound.prototype.render = function(context) {
      return this.sound.play();
    };

    return Sound;

  })();

  exports.Picture = Picture = (function(_super) {
    __extends(Picture, _super);

    function Picture(spec) {
      var _this = this;
      if (spec == null) {
        spec = {};
      }
      Picture.__super__.constructor.call(this, spec, {
        url: "http://www.html5canvastutorials.com/demos/assets/yoda.jpg",
        x: 0,
        y: 0
      });
      this.imageObj = new Image();
      this.image = null;
      this.imageObj.onload = function() {
        return _this.image = new Kinetic.Image({
          x: _this.spec.x,
          y: _this.spec.y,
          image: _this.imageObj,
          width: _this.spec.width || _this.imageObj.width,
          height: _this.spec.height || _this.imageObj.height
        });
      };
      this.imageObj.src = this.spec.url;
    }

    Picture.prototype.render = function(context, layer) {
      return layer.add(this.image);
    };

    return Picture;

  })(Stimulus);

  exports.Group = Group = (function(_super) {
    __extends(Group, _super);

    function Group(stims, layout) {
      var stim, _i, _len, _ref1;
      this.stims = stims;
      Group.__super__.constructor.call(this, {}, {});
      if (layout) {
        this.layout = layout;
        _ref1 = this.stims;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          stim = _ref1[_i];
          stim.layout = layout;
        }
      }
    }

    Group.prototype.render = function(context, layer) {
      var stim, _i, _len, _ref1, _results;
      console.log("rendering group");
      _ref1 = this.stims;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        stim = _ref1[_i];
        _results.push(stim.render(context, layer));
      }
      return _results;
    };

    return Group;

  })(Stimulus);

  exports.Background = Background = (function(_super) {
    __extends(Background, _super);

    function Background(stims, fill) {
      this.stims = stims != null ? stims : [];
      this.fill = fill != null ? fill : "white";
      Background.__super__.constructor.call(this, {}, {});
    }

    Background.prototype.render = function(context, layer) {
      var background, stim, _i, _len, _ref1, _results;
      background = new Kinetic.Rect({
        x: 0,
        y: 0,
        width: context.width(),
        height: context.height(),
        name: 'background',
        fill: this.fill
      });
      layer.add(background);
      _ref1 = this.stims;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        stim = _ref1[_i];
        _results.push(stim.render(context, layer));
      }
      return _results;
    };

    return Background;

  })(Stimulus);

  exports.Sequence = Sequence = (function(_super) {
    __extends(Sequence, _super);

    function Sequence(stims, soa, clear, times) {
      var i;
      this.stims = stims;
      this.soa = soa;
      this.clear = clear != null ? clear : true;
      this.times = times != null ? times : 1;
      Sequence.__super__.constructor.call(this, {}, {});
      if (this.soa.length !== this.stims.length) {
        this.soa = utils.repLen(this.soa, this.stims.length);
      }
      this.onsets = (function() {
        var _i, _ref1, _results;
        _results = [];
        for (i = _i = 0, _ref1 = this.soa.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          _results.push(_.reduce(this.soa.slice(0, +i + 1 || 9e9), function(x, acc) {
            return x + acc;
          }));
        }
        return _results;
      }).call(this);
    }

    Sequence.prototype.genseq = function(context, layer) {
      var deferred, _i, _ref1, _results,
        _this = this;
      deferred = Q.defer();
      _.forEach((function() {
        _results = [];
        for (var _i = 0, _ref1 = this.stims.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; 0 <= _ref1 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this), function(i) {
        var ev, stim;
        ev = new Timeout({
          duration: _this.onsets[i]
        });
        stim = _this.stims[i];
        return ev.activate(context).then(function() {
          if (!_this.stopped) {
            if (_this.clear) {
              context.clearContent();
            }
            stim.render(context, layer);
            context.draw();
          }
          if (i === _this.stims.length - 1) {
            return deferred.resolve(1);
          }
        });
      });
      return deferred.promise;
    };

    Sequence.prototype.render = function(context, layer) {
      var i, result, _i, _ref1,
        _this = this;
      result = Q.resolve(0);
      for (i = _i = 0, _ref1 = this.times; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        result = result.then(function() {
          return _this.genseq(context, layer);
        });
      }
      return result.then(function() {
        return context.clearContent();
      });
    };

    return Sequence;

  })(Stimulus);

  exports.Blank = Blank = (function(_super) {
    __extends(Blank, _super);

    function Blank(spec) {
      if (spec == null) {
        spec = {};
      }
      Blank.__super__.constructor.call(this, spec, {
        fill: "white"
      });
    }

    Blank.prototype.render = function(context, layer) {
      var blank;
      blank = new Kinetic.Rect({
        x: 0,
        y: 0,
        width: context.width(),
        height: context.height(),
        fill: this.spec.fill
      });
      return layer.add(blank);
    };

    return Blank;

  })(Stimulus);

  exports.Clear = Clear = (function(_super) {
    __extends(Clear, _super);

    function Clear(spec) {
      if (spec == null) {
        spec = {};
      }
      Clear.__super__.constructor.call(this, spec, {});
    }

    Clear.prototype.render = function(context, layer) {
      return context.clearContent(true);
    };

    return Clear;

  })(Stimulus);

  exports.Rectangle = Rectangle = (function(_super) {
    __extends(Rectangle, _super);

    function Rectangle(spec) {
      if (spec == null) {
        spec = {};
      }
      Rectangle.__super__.constructor.call(this, spec, {
        x: 0,
        y: 0,
        width: 100,
        height: 100,
        fill: 'red'
      });
      this.spec = _.omit(this.spec, function(value, key) {
        return !value;
      });
      if (this.spec.layout != null) {
        this.layout = this.spec.layout;
      }
    }

    Rectangle.prototype.render = function(context, layer) {
      var coords, rect;
      console.log("rendering rect");
      console.log("spec is", this.spec);
      console.log("has computeCoordinates", this.computeCoordinates);
      console.log("position", this.spec.position);
      coords = this.computeCoordinates(context, this.spec.position);
      console.log("coords", coords);
      rect = new Kinetic.Rect({
        x: coords[0],
        y: coords[1],
        width: this.spec.width,
        height: this.spec.height,
        fill: this.spec.fill,
        stroke: this.spec.stroke,
        strokeWidth: this.spec.strokeWidth
      });
      return layer.add(rect);
    };

    return Rectangle;

  })(Stimulus);

  exports.Circle = Circle = (function(_super) {
    __extends(Circle, _super);

    function Circle(spec) {
      if (spec == null) {
        spec = {};
      }
      Circle.__super__.constructor.call(this, spec, {
        x: 100,
        y: 100,
        radius: 50,
        fill: 'red',
        opacity: 1
      });
    }

    Circle.prototype.render = function(context, layer) {
      var circ;
      circ = new Kinetic.Circle({
        x: this.spec.x,
        y: this.spec.y,
        radius: this.spec.radius,
        fill: this.spec.fill,
        stroke: this.spec.stroke,
        strokeWidth: this.spec.strokeWidth,
        opacity: this.spec.opacity
      });
      return layer.add(circ);
    };

    return Circle;

  })(Stimulus);

  exports.CanvasBorder = CanvasBorder = (function(_super) {
    __extends(CanvasBorder, _super);

    function CanvasBorder(spec) {
      if (spec == null) {
        spec = {};
      }
      CanvasBorder.__super__.constructor.call(this, spec, {
        strokeWidth: 5,
        stroke: "black"
      });
    }

    CanvasBorder.prototype.render = function(context, layer) {
      var border;
      border = new Kinetic.Rect({
        x: 0,
        y: 0,
        width: context.width(),
        height: context.height(),
        strokeWidth: this.spec.strokeWidth,
        stroke: this.spec.stroke
      });
      return layer.add(border);
    };

    return CanvasBorder;

  })(Stimulus);

  exports.StartButton = StartButton = (function(_super) {
    __extends(StartButton, _super);

    function StartButton(spec) {
      if (spec == null) {
        spec = {};
      }
      StartButton.__super__.constructor.call(this, spec, {
        width: 150,
        height: 75
      });
    }

    StartButton.prototype.render = function(context, layer) {
      var button, group, text, xcenter, ycenter;
      xcenter = context.width() / 2;
      ycenter = context.height() / 2;
      group = new Kinetic.Group({
        id: this.spec.id
      });
      text = new Kinetic.Text({
        text: "Start",
        x: xcenter - this.spec.width / 2,
        y: ycenter - this.spec.height / 2,
        width: this.spec.width,
        height: this.spec.height,
        fontSize: 30,
        fill: "white",
        fontFamily: "Arial",
        align: "center",
        padding: 20
      });
      button = new Kinetic.Rect({
        x: xcenter - this.spec.width / 2,
        y: ycenter - text.getHeight() / 2,
        width: this.spec.width,
        height: text.getHeight(),
        fill: "black",
        cornerRadius: 10,
        stroke: "LightSteelBlue",
        strokeWidth: 5
      });
      group.add(button);
      group.add(text);
      return layer.add(group);
    };

    return StartButton;

  })(Stimulus);

  exports.Paragraph = Paragraph = (function(_super) {
    __extends(Paragraph, _super);

    function Paragraph(spec) {
      if (spec == null) {
        spec = {};
      }
      Paragraph.__super__.constructor.call(this, spec, {
        content: "",
        x: 50,
        y: 50,
        width: 600,
        fill: "black",
        fontSize: 18,
        fontFamily: "Arial",
        lineHeight: 1,
        textAlign: "center",
        position: null
      });
    }

    return Paragraph;

  })(Stimulus);

  exports.Page = Page = (function(_super) {
    __extends(Page, _super);

    function Page(spec) {
      if (spec == null) {
        spec = {};
      }
      Page.__super__.constructor.call(this, spec, {
        html: "<div>HTML Page</div>"
      });
      this.html = this.spec.html;
    }

    Page.prototype.render = function(context, layer) {
      return context.appendHtml(this.html);
    };

    return Page;

  })(Stimulus);

  exports.HtmlRange = HtmlRange = (function(_super) {
    __extends(HtmlRange, _super);

    function HtmlRange(spec) {
      if (spec == null) {
        spec = {};
      }
      HtmlRange.__super__.constructor.call(this, spec, {
        min: 0,
        max: 100,
        value: 0,
        step: 1,
        height: 100,
        width: 300
      });
      this.html = $("<div></div>");
      this.input = $("<input type='range'>");
      this.input.attr({
        min: this.spec.min,
        max: this.spec.max,
        value: this.spec.value,
        step: this.spec.step
      });
      this.input.css({
        width: this.spec.width
      });
      this.html.append(this.input);
    }

    HtmlRange.prototype.render = function(context, layer) {
      return context.appendHtml(this.html);
    };

    return HtmlRange;

  })(Stimulus);

  exports.MultipleChoice = MultipleChoice = (function(_super) {
    __extends(MultipleChoice, _super);

    function MultipleChoice(spec) {
      if (spec == null) {
        spec = {};
      }
      MultipleChoice.__super__.constructor.call(this, spec, {
        question: "What is your name?",
        options: ["Bill", "John", "Fred"],
        x: 10,
        y: 10,
        fill: "black",
        fontSize: 24,
        fontFamily: "Arial",
        textAlign: "center",
        position: null
      });
    }

    MultipleChoice.prototype.render = function(context, layer) {
      var choice, i, questionText, _i, _ref1, _results;
      questionText = new Kinetic.Text({
        x: this.spec.x,
        y: this.spec.y,
        text: this.spec.question,
        fontSize: this.spec.fontSize,
        fontFamily: this.spec.fontFamily,
        fill: this.spec.fill
      });
      layer.add(questionText);
      _results = [];
      for (i = _i = 0, _ref1 = this.spec.options.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        choice = new Kinetic.Text({
          x: this.spec.x + 5,
          y: questionText.getHeight() * (i + 1) + 30,
          text: (i + 1) + ") " + this.spec.options[i],
          fontSize: this.spec.fontSize,
          fontFamily: this.spec.fontFamily,
          fill: this.spec.fill,
          padding: 20,
          align: 'left'
        });
        _results.push(layer.add(choice));
      }
      return _results;
    };

    return MultipleChoice;

  })(Stimulus);

  exports.KineticContext = KineticContext = (function(_super) {
    __extends(KineticContext, _super);

    function KineticContext(stage) {
      this.stage = stage;
      KineticContext.__super__.constructor.call(this, new KineticStimFactory());
      this.contentLayer = new Kinetic.Layer({
        clearBeforeDraw: true
      });
      this.backgroundLayer = new Kinetic.Layer({
        clearBeforeDraw: true
      });
      this.background = new Background([], {
        fill: "white"
      });
      this.stage.add(this.backgroundLayer);
      this.stage.add(this.contentLayer);
      this.insertHTMLDiv();
    }

    KineticContext.prototype.insertHTMLDiv = function() {
      KineticContext.__super__.insertHTMLDiv.apply(this, arguments);
      return $(".kineticjs-content").css("position", "absolute");
    };

    KineticContext.prototype.setBackground = function(newBackground) {
      this.background = newBackground;
      this.backgroundLayer.removeChildren();
      return this.background.render(this, this.backgroundLayer);
    };

    KineticContext.prototype.drawBackground = function() {
      return this.backgroundLayer.draw();
    };

    KineticContext.prototype.clearBackground = function() {
      return this.backgroundLayer.removeChildren();
    };

    KineticContext.prototype.clearContent = function(draw) {
      if (draw == null) {
        draw = false;
      }
      this.clearHtml();
      this.backgroundLayer.draw();
      this.contentLayer.removeChildren();
      if (draw) {
        return this.draw();
      }
    };

    KineticContext.prototype.draw = function() {
      $('#container').focus();
      return this.contentLayer.draw();
    };

    KineticContext.prototype.width = function() {
      return this.stage.getWidth();
    };

    KineticContext.prototype.height = function() {
      return this.stage.getHeight();
    };

    KineticContext.prototype.offsetX = function() {
      return this.stage.getOffsetX();
    };

    KineticContext.prototype.offsetY = function() {
      return this.stage.getOffsetY();
    };

    KineticContext.prototype.keydownStream = function() {
      return $("body").asEventStream("keydown");
    };

    KineticContext.prototype.keypressStream = function() {
      return $("body").asEventStream("keypress");
    };

    KineticContext.prototype.mousepressStream = function() {
      var MouseBus;
      MouseBus = (function() {
        function MouseBus() {
          var _this = this;
          this.stream = new Bacon.Bus();
          this.handler = function(x) {
            return _this.stream.push(x);
          };
          this.stage.on("mousedown", this.handler);
        }

        MouseBus.prototype.stop = function() {
          this.stage.off("mousedown", this.handler);
          return this.stream.end();
        };

        return MouseBus;

      })();
      return new MouseBus();
    };

    return KineticContext;

  })(Psy.ExperimentContext);

  exports.KineticStimFactory = KineticStimFactory = (function(_super) {
    __extends(KineticStimFactory, _super);

    function KineticStimFactory() {
      _ref1 = KineticStimFactory.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    KineticStimFactory.prototype.makeLayout = function(name, params, context) {
      switch (name) {
        case "Grid":
          return new GridLayout(params[0], params[1], {
            x: 0,
            y: 0,
            width: context.width(),
            height: context.height()
          });
      }
    };

    KineticStimFactory.prototype.makeInstructions = function(spec) {
      return new Instructions(spec);
    };

    KineticStimFactory.prototype.makeStimulus = function(name, params, context) {
      var callee, i, layoutName, layoutParams, names, props, stims;
      callee = arguments.callee;
      switch (name) {
        case "FixationCross":
          return new FixationCross(params);
        case "Clear":
          return new Clear(params);
        case "Group":
          names = _.map(params.stims, function(stim) {
            return _.keys(stim)[0];
          });
          props = _.map(params.stims, function(stim) {
            return _.values(stim)[0];
          });
          stims = (function() {
            var _i, _ref2, _results;
            _results = [];
            for (i = _i = 0, _ref2 = names.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
              _results.push(callee(names[i], props[i]));
            }
            return _results;
          })();
          layoutName = _.keys(params.layout)[0];
          layoutParams = _.values(params.layout)[0];
          return new Group(stims, this.makeLayout(layoutName, layoutParams, context));
        case "Instructions":
          return new Instructions(params);
        case "Rectangle":
          return new Rectangle(params);
        case "Text":
          return new Text(params);
        case "HtmlIcon":
          return new HtmlIcon(params);
        default:
          throw "No Stimulus type of name " + name;
      }
    };

    KineticStimFactory.prototype.makeResponse = function(name, params, context) {
      console.log("making response", name);
      switch (name) {
        case "KeyPress":
          return new KeyPressResponse(params);
        case "SpaceKey":
          return new SpaceKeyResponse(params);
        case "Timeout":
          return new Timeout(params);
        default:
          throw new Error("No Response type of name " + name);
      }
    };

    KineticStimFactory.prototype.makeEvent = function(stim, response) {
      return new Psy.Event(stim, response);
    };

    return KineticStimFactory;

  })(Psy.StimFactory);

}).call(this);

/*
//@ sourceMappingURL=elements.map
*/
