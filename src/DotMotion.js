// Generated by CoffeeScript 1.6.3
(function() {
  var Base, DotSet, RandomDotMotion, x, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Base = require("./stimresp");

  _ = require('lodash');

  DotSet = (function() {
    DotSet.randomDelta = function(distance) {
      var rads;
      rads = Math.random() * Math.PI * 2;
      return [distance * Math.cos(rads), distance * Math.sin(rads)];
    };

    DotSet.coherentDelta = function(distance, direction) {
      return [distance * Math.cos(Math.PI * direction / 180), distance * Math.sin(Math.PI * direction / 180)];
    };

    DotSet.pointInCircle = function() {
      var r, t, u;
      t = 2 * Math.PI * Math.random();
      u = Math.random() + Math.random();
      r = u > 1 ? 2 - u : u;
      return [r * Math.cos(t), r * Math.sin(t)];
    };

    DotSet.inCircle = function(center_x, center_y, radius, x, y) {
      var squareDist;
      squareDist = Math.pow(center_x - x, 2) + Math.pow(center_y - y, 2);
      return squareDist <= Math.pow(radius, 2);
    };

    function DotSet(ndots, nparts, coherence) {
      var _this = this;
      this.ndots = ndots;
      this.nparts = nparts != null ? nparts : 3;
      if (coherence == null) {
        coherence = .5;
      }
      this.frameNum = 0;
      this.dotsPerSet = Math.round(this.ndots / this.nparts);
      this.dotSets = _.map([0, 1, 2], function(i) {
        var _i, _ref, _results;
        return _.map((function() {
          _results = [];
          for (var _i = 0, _ref = _this.dotsPerSet; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this), function(d) {
          return [Math.random(), Math.random()];
        });
      });
    }

    DotSet.prototype.getDotPartition = function(i) {
      return this.dotSets[i];
    };

    DotSet.prototype.nextFrame = function(coherence, distance, direction) {
      var delta, dset, i, partition, res, xy;
      partition = this.frameNum % this.nparts;
      dset = this.dotSets[partition];
      res = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = dset.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          xy = dset[i];
          delta = Math.random() < coherence ? DotSet.coherentDelta(distance, direction) : DotSet.randomDelta(distance);
          xy = [xy[0] + delta[0], xy[1] + delta[1]];
          if (xy[0] < 0 || xy[0] > 1 || xy[1] < 0 || xy[1] > 1) {
            xy = [Math.random(), Math.random()];
          }
          _results.push(dset[i] = xy);
        }
        return _results;
      })();
      this.frameNum = this.frameNum + 1;
      return res;
    };

    return DotSet;

  })();

  exports.RandomDotMotion = RandomDotMotion = (function(_super) {
    __extends(RandomDotMotion, _super);

    function RandomDotMotion(spec) {
      if (spec == null) {
        spec = {
          x: 0,
          y: 0,
          numDots: 70,
          apRadius: 400,
          dotSpeed: .02,
          dotSize: 2,
          coherence: .55,
          partitions: 3
        };
      }
      this.numDots = spec.numDots;
      this.apRadius = spec.apRadius;
      this.dotSpeed = spec.dotSpeed;
      this.dotSize = spec.dotSize;
      this.coherence = spec.coherence;
      this.partitions = spec.partitions;
      this.x = spec.x;
      this.y = spec.y;
      this.dotSet = new DotSet(this.numDots, 3, .5);
    }

    RandomDotMotion.prototype.createDots = function() {
      var dots, xy, _i, _len, _results;
      dots = this.dotSet.nextFrame(this.coherence, this.dotSpeed, 180);
      _results = [];
      for (_i = 0, _len = dots.length; _i < _len; _i++) {
        xy = dots[_i];
        _results.push(new Kinetic.Rect({
          x: this.x + this.apRadius * xy[0],
          y: this.x + this.apRadius * xy[1],
          width: this.dotSize,
          height: this.dotSize,
          fill: "green"
        }));
      }
      return _results;
    };

    RandomDotMotion.prototype.createInitialDots = function() {
      var dpart, i, xy, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.partitions; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        dpart = this.dotSet.getDotPartition(i);
        _results.push((function() {
          var _j, _len, _results1;
          _results1 = [];
          for (_j = 0, _len = dpart.length; _j < _len; _j++) {
            xy = dpart[_j];
            _results1.push(new Kinetic.Rect({
              x: this.x + this.apRadius * xy[0],
              y: this.x + this.apRadius * xy[1],
              width: this.dotSize,
              height: this.dotSize,
              fill: "green"
            }));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    RandomDotMotion.prototype.displayInitialDots = function(nodes, group) {
      var node, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        node = nodes[_i];
        _results.push(group.add(node));
      }
      return _results;
    };

    RandomDotMotion.prototype.render = function(context, layer) {
      var i, nodeSets, _i, _ref,
        _this = this;
      this.groups = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.partitions; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(new Kinetic.Group({
            listening: false
          }));
        }
        return _results;
      }).call(this);
      _.map(this.groups, function(g) {
        return layer.add(g);
      });
      nodeSets = this.createInitialDots();
      for (i = _i = 0, _ref = this.partitions; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.displayInitialDots(nodeSets[i], this.groups[i]);
      }
      layer.draw();
      this.anim = new Kinetic.Animation(function(frame) {
        var curset, dx, part, xy, _j, _ref1, _results;
        dx = _this.dotSet.nextFrame(_this.coherence, _this.dotSpeed, 180);
        part = _this.dotSet.frameNum % _this.partitions;
        curset = nodeSets[part];
        _results = [];
        for (i = _j = 0, _ref1 = curset.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          xy = dx[i];
          xy = [xy[0] * _this.apRadius, xy[1] * _this.apRadius];
          console.log(xy);
          curset[i].setPosition(xy);
          if (!DotSet.inCircle(.5 * _this.apRadius, .5 * _this.apRadius, _this.apRadius / 2, xy[0], xy[1])) {
            _results.push(curset[i].hide());
          } else {
            _results.push(curset[i].show());
          }
        }
        return _results;
      }, layer);
      layer.draw();
      return this.anim.start();
    };

    RandomDotMotion.prototype.render2 = function(context, layer) {
      var i, nodeSets, _i, _ref,
        _this = this;
      this.layers = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.partitions; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(new Kinetic.Layer({
            listening: false
          }));
        }
        return _results;
      }).call(this);
      _.map(this.layers, function(l) {
        return context.stage.add(l);
      });
      nodeSets = this.createInitialDots();
      for (i = _i = 0, _ref = this.partitions; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.displayInitialDots(nodeSets[i], this.layers[i]);
      }
      this.anim = new Kinetic.Animation(function(frame) {
        var curset, dx, part, xy, _j, _ref1;
        dx = _this.dotSet.nextFrame(_this.coherence, _this.dotSpeed, 180);
        part = _this.dotSet.frameNum % _this.partitions;
        curset = nodeSets[part];
        for (i = _j = 0, _ref1 = curset.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          xy = dx[i];
          xy = [xy[0] * _this.apRadius, xy[1] * _this.apRadius];
          console.log(xy);
          curset[i].setPosition(xy);
        }
        return _this.layers[part].draw();
      });
      layer.draw();
      return this.anim.start();
    };

    RandomDotMotion.prototype.stop = function(context) {
      return this.anim.stop();
    };

    return RandomDotMotion;

  })(Base.Stimulus);

  x = new DotSet(51, 3);

  console.log(x.dotSets);

  console.log("NEXT", x.nextFrame(.5, .01, 180));

}).call(this);

/*
//@ sourceMappingURL=dotmotion.map
*/
