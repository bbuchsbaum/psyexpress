// Generated by CoffeeScript 1.6.3
(function() {
  var ArrayIterator, Block, BlockSeq, CellTable, CombinatoricSampler, ConditionalSampler, DataTable, Event, EventData, EventDataLog, ExhaustiveSampler, ExpDesign, Experiment, ExperimentContext, Factor, FactorNode, FactorSetNode, FactorSpec, GridSampler, ItemNode, Iterator, MatchSampler, MockStimFactory, Prelude, Presenter, Q, RunnableNode, Sampler, StimFactory, TaskNode, TaskSchema, Trial, TrialList, UniformSampler, VarSpec, VariablesNode, asArray, buildEvent, buildPrelude, buildResponse, buildStimulus, buildTrial, clone, deferred, des, msam, permute, prom, prom2, prom3, rep, repLen, sam, sample, _, _i, _ref, _results,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  _ = require('lodash');

  Q = require("q");

  clone = function(obj) {
    var flags, key, newInstance;
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (obj instanceof RegExp) {
      flags = '';
      if (obj.global != null) {
        flags += 'g';
      }
      if (obj.ignoreCase != null) {
        flags += 'i';
      }
      if (obj.multiline != null) {
        flags += 'm';
      }
      if (obj.sticky != null) {
        flags += 'y';
      }
      return new RegExp(obj.source, flags);
    }
    newInstance = new obj.constructor();
    for (key in obj) {
      newInstance[key] = clone(obj[key]);
    }
    return newInstance;
  };

  asArray = function(value) {
    if (_.isArray(value)) {
      return value;
    } else if (_.isNumber(value) || _.isBoolean(value)) {
      return [value];
    } else {
      return _.toArray(value);
    }
  };

  permute = function(input) {
    var main, permArr, usedChars;
    permArr = [];
    usedChars = [];
    exports.main = main = function(input) {
      var ch, i, _i, _ref;
      for (i = _i = 0, _ref = input.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        ch = input.splice(i, 1)[0];
        usedChars.push(ch);
        if (input.length === 0) {
          permArr.push(usedChars.slice());
        }
        main(input);
        input.splice(i, 0, ch);
        usedChars.pop();
      }
      return permArr;
    };
    return main(input);
  };

  rep = function(vec, times) {
    var el, i, j, out,
      _this = this;
    if (!(times instanceof Array)) {
      times = [times];
    }
    if (times.length !== 1 && vec.length !== times.length) {
      throw "vec.length must equal times.length or times.length must be 1";
    }
    if (vec.length === times.length) {
      out = (function() {
        var _i, _len, _results;
        _results = [];
        for (i = _i = 0, _len = vec.length; _i < _len; i = ++_i) {
          el = vec[i];
          _results.push((function() {
            var _j, _ref, _results1;
            _results1 = [];
            for (j = _j = 1, _ref = times[i]; 1 <= _ref ? _j <= _ref : _j >= _ref; j = 1 <= _ref ? ++_j : --_j) {
              _results1.push(el);
            }
            return _results1;
          })());
        }
        return _results;
      })();
      return _.flatten(out);
    } else {
      out = _.times(times[0], function(n) {
        return vec;
      });
      return _.flatten(out);
    }
  };

  repLen = function(vec, length) {
    var i, _i, _results;
    if (length < 1) {
      throw "repLen: length must be greater than or equal to 1";
    }
    _results = [];
    for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
      _results.push(vec[i % vec.length]);
    }
    return _results;
  };

  sample = function(elements, n, replace) {
    var i, _i, _results;
    if (replace == null) {
      replace = false;
    }
    if (n > elements.length && !replace) {
      throw "cannot take sample larger than the number of elements when 'replace' argument is false";
    }
    if (!replace) {
      return _.shuffle(elements).slice(0, n);
    } else {
      _results = [];
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        _results.push(Math.floor(Math.random() * elements.length));
      }
      return _results;
    }
  };

  exports.EventData = EventData = (function() {
    function EventData(name, id, data) {
      this.name = name;
      this.id = id;
      this.data = data;
    }

    return EventData;

  })();

  exports.EventDataLog = EventDataLog = (function() {
    function EventDataLog() {
      this.eventStack = [];
    }

    EventDataLog.prototype.push = function(ev) {
      return this.eventStack.push(ev);
    };

    EventDataLog.prototype.last = function() {
      if (this.eventStack.length < 1) {
        throw "EventLog is Empty, canot access last element";
      }
      return this.eventStack[this.eventStack.length - 1].data;
    };

    EventDataLog.prototype.findLast = function(id) {
      var i, len, _i;
      len = this.eventStack.length - 1;
      for (i = _i = len; len <= 0 ? _i <= 0 : _i >= 0; i = len <= 0 ? ++_i : --_i) {
        if (this.eventStack[i].id === id) {
          return this.eventStack[i];
        }
      }
    };

    return EventDataLog;

  })();

  exports.Sampler = Sampler = (function() {
    function Sampler(items) {
      this.items = items;
    }

    Sampler.prototype.sampleFrom = function(items, n) {
      return sample(items, n);
    };

    Sampler.prototype.take = function(n) {
      if (n > this.items.length) {
        throw "cannot take sample larger than the number of items when using non-replacing sampler";
      }
      return this.sampleFrom(this.items, n);
    };

    return Sampler;

  })();

  exports.ExhaustiveSampler = ExhaustiveSampler = (function(_super) {
    __extends(ExhaustiveSampler, _super);

    ExhaustiveSampler.fillBuffer = function(items, n) {
      var buf, i;
      buf = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
          _results.push(_.shuffle(items));
        }
        return _results;
      })();
      return _.flatten(buf);
    };

    function ExhaustiveSampler(items, buflen) {
      this.items = items;
      if (buflen == null) {
        buflen = 10;
      }
      this.buffer = ExhaustiveSampler.fillBuffer(this.items, buflen);
    }

    ExhaustiveSampler.prototype.take = function(n) {
      var buf, buflen, res;
      if (n <= this.buffer.length) {
        res = _.take(this.buffer, n);
        this.buffer = _.drop(this.buffer, n);
        return res;
      } else {
        buflen = Math.max(n, 10 * this.items.length);
        buf = ExhaustiveSampler.fillBuffer(this.items, buflen / this.items.length);
        this.buffer = this.buffer.concat(buf);
        return this.take(n);
      }
    };

    return ExhaustiveSampler;

  })(Sampler);

  exports.MatchSampler = MatchSampler = (function() {
    function MatchSampler(sampler) {
      this.sampler = sampler;
    }

    MatchSampler.prototype.take = function(n, match) {
      var probe, probeIndex, sam;
      if (match == null) {
        match = true;
      }
      sam = this.sampler.take(n);
      if (match) {
        probe = sample(sam, 1)[0];
      } else {
        probe = this.sampler.take(1)[0];
      }
      probeIndex = _.indexOf(sam, probe);
      return {
        targetSet: sam,
        probe: probe,
        probeIndex: probeIndex,
        match: match
      };
    };

    return MatchSampler;

  })();

  msam = new MatchSampler(new ExhaustiveSampler((function() {
    _results = [];
    for (_i = 0; _i <= 25; _i++){ _results.push(_i); }
    return _results;
  }).apply(this)));

  console.log("match:", msam.take(5));

  console.log("non match:", msam.take(5, false));

  exports.UniformSampler = UniformSampler = (function(_super) {
    __extends(UniformSampler, _super);

    UniformSampler.validate = function(range) {
      if (range.length !== 2) {
        throw "range must be an array with two values (min, max)";
      }
      if (range[1] <= range[0]) {
        throw "range[1] must > range[0]";
      }
    };

    function UniformSampler(range) {
      this.range = range;
      this.interval = this.range[1] - this.range[0];
    }

    UniformSampler.prototype.take = function(n) {
      var i, nums;
      nums = (function() {
        var _j, _results1;
        _results1 = [];
        for (i = _j = 1; 1 <= n ? _j <= n : _j >= n; i = 1 <= n ? ++_j : --_j) {
          _results1.push(Math.round(Math.random() * this.interval));
        }
        return _results1;
      }).call(this);
      return nums;
    };

    return UniformSampler;

  })(Sampler);

  exports.CombinatoricSampler = CombinatoricSampler = (function(_super) {
    __extends(CombinatoricSampler, _super);

    function CombinatoricSampler() {
      var samplers;
      samplers = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.samplers = samplers;
    }

    CombinatoricSampler.prototype.take = function(n) {
      var i, j, xs, _j, _results1;
      _results1 = [];
      for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
        xs = (function() {
          var _k, _ref, _results2;
          _results2 = [];
          for (j = _k = 0, _ref = this.samplers.length; 0 <= _ref ? _k < _ref : _k > _ref; j = 0 <= _ref ? ++_k : --_k) {
            _results2.push(this.samplers[j].take(1));
          }
          return _results2;
        }).call(this);
        _results1.push(_.flatten(xs));
      }
      return _results1;
    };

    return CombinatoricSampler;

  })(Sampler);

  exports.GridSampler = GridSampler = (function(_super) {
    __extends(GridSampler, _super);

    function GridSampler(x, y) {
      var i;
      this.x = x;
      this.y = y;
      this.grid = DataTable.expand({
        x: this.x,
        y: this.y
      });
      console.log("rows:", this.grid.nrow());
      this.tuples = (function() {
        var _j, _ref, _results1;
        _results1 = [];
        for (i = _j = 0, _ref = this.grid.nrow(); 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
          _results1.push(_.values(this.grid.record(i)));
        }
        return _results1;
      }).call(this);
    }

    GridSampler.prototype.take = function(n) {
      return sample(this.tuples, n);
    };

    return GridSampler;

  })(Sampler);

  exports.Factor = Factor = (function(_super) {
    __extends(Factor, _super);

    Factor.asFactor = function(arr) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Factor, arr, function(){});
    };

    function Factor(arr) {
      var arg, _j, _len;
      for (_j = 0, _len = arr.length; _j < _len; _j++) {
        arg = arr[_j];
        this.push(arg);
      }
      this.levels = _.uniq(arr).sort();
    }

    return Factor;

  })(Array);

  exports.DataTable = DataTable = (function() {
    DataTable.prototype.show = function() {
      var i, _j, _ref, _results1;
      console.log("DataTable: rows: " + (this.nrow()) + " columns: " + (this.ncol()));
      _results1 = [];
      for (i = _j = 0, _ref = this.nrow(); 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
        _results1.push(console.log(this.record(i)));
      }
      return _results1;
    };

    DataTable.fromRecords = function(records, union) {
      var allkeys, key, rec, vars, _j, _k, _l, _len, _len1, _len2;
      if (union == null) {
        union = true;
      }
      allkeys = _.uniq(_.flatten(_.map(records, function(rec) {
        return _.keys(rec);
      })));
      console.log(allkeys);
      vars = {};
      for (_j = 0, _len = allkeys.length; _j < _len; _j++) {
        key = allkeys[_j];
        vars[key] = [];
      }
      console.log(vars);
      for (_k = 0, _len1 = records.length; _k < _len1; _k++) {
        rec = records[_k];
        for (_l = 0, _len2 = allkeys.length; _l < _len2; _l++) {
          key = allkeys[_l];
          vars[key].push(rec[key] || null);
        }
      }
      return new DataTable(vars);
    };

    DataTable.build = function(vars) {
      if (vars == null) {
        vars = {};
      }
      return Object.seal(new DataTable(vars));
    };

    DataTable.rbind = function(tab1, tab2, union) {
      var col1, col2, keys1, keys2, name, out, sharedKeys, _j, _len;
      if (union == null) {
        union = false;
      }
      keys1 = _.keys(tab1);
      keys2 = _.keys(tab2);
      sharedKeys = union ? _.union(keys1, keys2) : _.intersection(keys1, keys2);
      console.log("shared keys", sharedKeys);
      out = {};
      for (_j = 0, _len = sharedKeys.length; _j < _len; _j++) {
        name = sharedKeys[_j];
        col1 = tab1[name];
        col2 = tab2[name];
        if (!col1) {
          col1 = repLen([null], tab1.nrow());
        }
        if (!col2) {
          col2 = repLen([null], tab2.nrow());
        }
        out[name] = col1.concat(col2);
      }
      return new DataTable(out);
    };

    DataTable.cbind = function(tab1, tab2) {
      var diffkeys, key, out, _j, _len;
      if (tab1.nrow() !== tab2.nrow()) {
        throw "cbind requires arguments to have same number of rows";
      }
      out = _.cloneDeep(tab1);
      diffkeys = _.difference(_.keys(tab2), _.keys(tab1));
      for (_j = 0, _len = diffkeys.length; _j < _len; _j++) {
        key = diffkeys[_j];
        out[key] = tab2[key];
      }
      return out;
    };

    DataTable.expand = function(vars, unique, nreps) {
      var d, i, key, name, nargs, nm, nx, orep, out, r1, r2, r3, repfac, value, _j, _results1;
      if (vars == null) {
        vars = {};
      }
      if (unique == null) {
        unique = true;
      }
      if (nreps == null) {
        nreps = 1;
      }
      if (unique) {
        out = {};
        for (name in vars) {
          value = vars[name];
          out[name] = _.unique(value);
        }
        vars = out;
      }
      nargs = _.size(vars);
      nm = _.keys(vars);
      repfac = 1;
      d = _.map(vars, function(x) {
        return x.length;
      });
      orep = _.reduce(d, function(x, acc) {
        return x * acc;
      });
      out = {};
      for (key in vars) {
        value = vars[key];
        nx = value.length;
        orep = orep / nx;
        r1 = rep([repfac], nx);
        r2 = rep((function() {
          _results1 = [];
          for (var _j = 0; 0 <= nx ? _j < nx : _j > nx; 0 <= nx ? _j++ : _j--){ _results1.push(_j); }
          return _results1;
        }).apply(this), r1);
        r3 = rep(r2, orep);
        out[key] = (function() {
          var _k, _len, _results2;
          _results2 = [];
          for (_k = 0, _len = r3.length; _k < _len; _k++) {
            i = r3[_k];
            _results2.push(value[i]);
          }
          return _results2;
        })();
        repfac = repfac * nx;
      }
      return new DataTable(out);
    };

    function DataTable(vars) {
      var key, samelen, value, varlen;
      if (vars == null) {
        vars = {};
      }
      varlen = _.map(vars, function(x) {
        return x.length;
      });
      samelen = _.all(varlen, function(x) {
        return x === varlen[0];
      });
      if (!samelen) {
        throw "arguments to DataTable must all have same length.";
      }
      for (key in vars) {
        value = vars[key];
        this[key] = value;
      }
    }

    DataTable.prototype.subset = function(key, filter) {
      var el, i, keep, name, out, val, value;
      keep = (function() {
        var _j, _len, _ref, _results1;
        _ref = this[key];
        _results1 = [];
        for (_j = 0, _len = _ref.length; _j < _len; _j++) {
          val = _ref[_j];
          if (filter(val)) {
            _results1.push(true);
          } else {
            _results1.push(false);
          }
        }
        return _results1;
      }).call(this);
      out = {};
      for (name in this) {
        if (!__hasProp.call(this, name)) continue;
        value = this[name];
        out[name] = (function() {
          var _j, _len, _results1;
          _results1 = [];
          for (i = _j = 0, _len = value.length; _j < _len; i = ++_j) {
            el = value[i];
            if (keep[i] === true) {
              _results1.push(el);
            }
          }
          return _results1;
        })();
      }
      return new DataTable(out);
    };

    DataTable.prototype.whichRow = function(where) {
      var count, i, key, nkeys, out, rec, value, _j, _ref;
      out = [];
      nkeys = _.keys(where).length;
      for (i = _j = 0, _ref = this.nrow(); 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
        rec = this.record(i);
        count = asArray((function() {
          var _results1;
          _results1 = [];
          for (key in where) {
            value = where[key];
            _results1.push(rec[key] === value);
          }
          return _results1;
        })());
        count = _.map(count, function(x) {
          if (x) {
            return 1;
          } else {
            return 0;
          }
        });
        count = _.reduce(asArray(count), function(sum, num) {
          return sum + num;
        });
        if (count === nkeys) {
          out.push(i);
        }
      }
      return out;
    };

    DataTable.prototype.select = function(where) {
      var count, i, key, nkeys, out, rec, value, _j, _ref;
      out = [];
      nkeys = _.keys(where).length;
      for (i = _j = 0, _ref = this.nrow(); 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
        rec = this.record(i);
        count = asArray((function() {
          var _results1;
          _results1 = [];
          for (key in where) {
            value = where[key];
            _results1.push(rec[key] === value);
          }
          return _results1;
        })());
        count = _.map(count, function(x) {
          if (x) {
            return 1;
          } else {
            return 0;
          }
        });
        count = _.reduce(asArray(count), function(sum, num) {
          return sum + num;
        });
        if (count === nkeys) {
          out.push(rec);
        }
      }
      return out;
    };

    DataTable.prototype.nrow = function() {
      var lens, name, value;
      lens = (function() {
        var _results1;
        _results1 = [];
        for (name in this) {
          if (!__hasProp.call(this, name)) continue;
          value = this[name];
          _results1.push(value.length);
        }
        return _results1;
      }).call(this);
      return _.max(lens);
    };

    DataTable.prototype.ncol = function() {
      return Object.keys(this).length;
    };

    DataTable.prototype.colnames = function() {
      return Object.keys(this);
    };

    DataTable.prototype.record = function(index) {
      var name, rec, value;
      rec = {};
      for (name in this) {
        if (!__hasProp.call(this, name)) continue;
        value = this[name];
        rec[name] = value[index];
      }
      return rec;
    };

    DataTable.prototype.replicate = function(nreps) {
      var name, out, value,
        _this = this;
      out = {};
      for (name in this) {
        if (!__hasProp.call(this, name)) continue;
        value = this[name];
        out[name] = _.flatten(_.times(nreps, function(n) {
          return value;
        }));
      }
      return new DataTable(out);
    };

    DataTable.prototype.bindcol = function(name, column) {
      if (column.length !== this.nrow()) {
        throw "new column must be same length as existing DataTable object: column.length is  " + column.length + " and this.length is  " + (this.nrow());
      }
      this[name] = column;
      return this;
    };

    DataTable.prototype.bindrow = function(rows) {
      var key, record, value, _j, _len;
      if (!_.isArray(rows)) {
        rows = [rows];
      }
      for (_j = 0, _len = rows.length; _j < _len; _j++) {
        record = rows[_j];
        console.log(record);
        for (key in record) {
          if (!__hasProp.call(record, key)) continue;
          value = record[key];
          if (!_.has(this, key)) {
            throw "DataTable has no field named " + key;
          } else {
            this[key].push(value);
          }
        }
      }
      return this;
    };

    return DataTable;

  })();

  exports.StimFactory = StimFactory = (function() {
    function StimFactory() {}

    StimFactory.prototype.buildStimulus = function(spec, context) {
      var params, stimType;
      stimType = _.keys(spec)[0];
      params = _.values(spec)[0];
      return this.makeStimulus(stimType, params, context);
    };

    StimFactory.prototype.buildResponse = function(spec, context) {
      var params, responseType;
      responseType = _.keys(spec)[0];
      params = _.values(spec)[0];
      return this.makeResponse(responseType, params, context);
    };

    StimFactory.prototype.buildEvent = function(spec, context) {
      var response, responseSpec, stim, stimSpec;
      stimSpec = _.omit(spec, "Next");
      responseSpec = _.pick(spec, "Next");
      stim = this.buildStimulus(stimSpec, context);
      response = this.buildResponse(responseSpec.Next, context);
      return this.makeEvent(stim, response, context);
    };

    StimFactory.prototype.makeStimulus = function(name, params, context) {
      throw "unimplemented";
    };

    StimFactory.prototype.makeResponse = function(name, params, context) {
      throw "unimplemented";
    };

    StimFactory.prototype.makeEvent = function(stim, response, context) {
      throw "unimplemented";
    };

    return StimFactory;

  })();

  exports.MockStimFactory = MockStimFactory = (function(_super) {
    __extends(MockStimFactory, _super);

    function MockStimFactory() {
      _ref = MockStimFactory.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    MockStimFactory.prototype.makeStimulus = function(name, params, context) {
      var ret;
      ret = {};
      ret[name] = params;
      return ret;
    };

    MockStimFactory.prototype.makeResponse = function(name, params, context) {
      var ret;
      ret = {};
      ret[name] = params;
      return ret;
    };

    MockStimFactory.prototype.makeEvent = function(stim, response, context) {
      return [stim, response];
    };

    return MockStimFactory;

  })(StimFactory);

  RunnableNode = (function() {
    function RunnableNode(children) {
      this.children = children;
    }

    RunnableNode.functionList = function(nodes, context, callback) {
      var _this = this;
      return _.map(nodes, function(node) {
        return function() {
          if (callback != null) {
            callback(node);
          }
          return node.start(context);
        };
      });
    };

    RunnableNode.before = function(context) {
      return function() {
        return 0;
      };
    };

    RunnableNode.after = function(context) {
      return function() {
        return 0;
      };
    };

    RunnableNode.chainFunctions = function(funArray) {
      var fun, result, _j, _len;
      result = Q.resolve(0);
      for (_j = 0, _len = funArray.length; _j < _len; _j++) {
        fun = funArray[_j];
        result = result.then(fun, function(err) {
          throw new Error("Error during execution: ", err);
        });
      }
      return result;
    };

    RunnableNode.prototype.numChildren = function() {
      return this.children.length;
    };

    RunnableNode.prototype.length = function() {
      return this.children.length;
    };

    RunnableNode.prototype.start = function(context) {
      var farray;
      farray = RunnableNode.functionList(this.children, context, function(node) {
        return console.log("callback", node);
      });
      return RunnableNode.chainFunctions(_.flatten([this.before(context), farray, this.after(context)]));
    };

    RunnableNode.prototype.stop = function(context) {};

    return RunnableNode;

  })();

  exports.RunnableNode = RunnableNode;

  exports.Event = Event = (function(_super) {
    __extends(Event, _super);

    function Event(stimulus, response) {
      this.stimulus = stimulus;
      this.response = response;
    }

    Event.prototype.stop = function(context) {
      this.stimulus.stop(context);
      return this.response.stop(context);
    };

    Event.prototype.start = function(context) {
      var _this = this;
      if (!this.stimulus.overlay) {
        context.clearContent();
      }
      this.stimulus.render(context, context.contentLayer);
      context.draw();
      return this.response.activate(context).then(function(ret) {
        _this.stimulus.stop(context);
        return ret;
      }, function(err) {
        throw new Error("Error during Response activation", err);
      });
    };

    return Event;

  })(RunnableNode);

  exports.Trial = Trial = (function(_super) {
    __extends(Trial, _super);

    function Trial(events, meta, feedback, background) {
      if (events == null) {
        events = [];
      }
      this.meta = meta != null ? meta : {};
      this.feedback = feedback;
      this.background = background;
      Trial.__super__.constructor.call(this, events);
    }

    Trial.prototype.numEvents = function() {
      return this.children.length;
    };

    Trial.prototype.push = function(event) {
      return this.children.push(event);
    };

    Trial.prototype.before = function(context) {
      var _this = this;
      return function() {
        context.clearBackground();
        if (_this.background != null) {
          context.setBackground(_this.background);
          return context.drawBackground();
        }
      };
    };

    Trial.prototype.after = function(context) {
      var _this = this;
      return function() {
        var event, spec;
        if (_this.feedback != null) {
          spec = _this.feedback(context.eventData);
          event = context.stimFactory.buildEvent(spec, context);
          return event.start(context);
        } else {
          return Q.fcall(0);
        }
      };
    };

    Trial.prototype.start = function(context) {
      var farray;
      farray = RunnableNode.functionList(this.children, context, function(event) {
        return console.log("event callback", event);
      });
      return RunnableNode.chainFunctions(_.flatten([this.before(context), farray, this.after(context)]));
    };

    Trial.prototype.stop = function(context) {};

    return Trial;

  })(RunnableNode);

  exports.Block = Block = (function(_super) {
    __extends(Block, _super);

    function Block(children, blockEventBuilder) {
      this.blockEventBuilder = blockEventBuilder;
      Block.__super__.constructor.call(this, children);
    }

    Block.prototype.before = function(context) {};

    Block.prototype.after = function(context) {};

    return Block;

  })(RunnableNode);

  exports.Prelude = Prelude = (function(_super) {
    __extends(Prelude, _super);

    function Prelude(children) {
      Prelude.__super__.constructor.call(this, children);
    }

    return Prelude;

  })(RunnableNode);

  exports.BlockSeq = BlockSeq = (function(_super) {
    __extends(BlockSeq, _super);

    function BlockSeq(children) {
      BlockSeq.__super__.constructor.call(this, children);
    }

    return BlockSeq;

  })(RunnableNode);

  exports.ExperimentContext = ExperimentContext = (function() {
    function ExperimentContext(stimFactory) {
      this.stimFactory = stimFactory;
      this.eventData = new EventDataLog();
      this.log = [];
      this.trialNumber = 0;
      this.currentTrial = new Trial([], {});
    }

    ExperimentContext.prototype.pushEventData = function(ev) {
      return this.eventData.push(ev);
    };

    ExperimentContext.prototype.logEvent = function(key, value) {
      var record;
      record = _.clone(this.currentTrial.meta);
      record[key] = value;
      this.log.push(record);
      return console.log(this.log);
    };

    ExperimentContext.prototype.showEvent = function(event) {
      return event.start(this);
    };

    ExperimentContext.prototype.start = function(blockList) {
      var error, farray;
      try {
        farray = RunnableNode.functionList(blockList, this, function(block) {
          return console.log("block callback", block);
        });
        return RunnableNode.chainFunctions(farray);
      } catch (_error) {
        error = _error;
        return console.log("caught error:", error);
      }
    };

    ExperimentContext.prototype.clearContent = function() {};

    ExperimentContext.prototype.clearBackground = function() {};

    ExperimentContext.prototype.keydownStream = function() {};

    ExperimentContext.prototype.keypressStream = function() {};

    ExperimentContext.prototype.mousepressStream = function() {};

    ExperimentContext.prototype.draw = function() {};

    return ExperimentContext;

  })();

  buildStimulus = function(spec, context) {
    var params, stimType;
    stimType = _.keys(spec)[0];
    params = _.values(spec)[0];
    return context.stimFactory.makeStimulus(stimType, params, context);
  };

  buildResponse = function(spec, context) {
    var params, responseType;
    responseType = _.keys(spec)[0];
    params = _.values(spec)[0];
    return context.stimFactory.makeResponse(responseType, params, context);
  };

  buildEvent = function(spec, context) {
    var response, responseSpec, stim, stimSpec;
    stimSpec = _.omit(spec, "Next");
    responseSpec = _.pick(spec, "Next");
    console.log("stim Spec", stimSpec);
    console.log("response Spec", responseSpec);
    if ((responseSpec == null) || _.isEmpty(responseSpec)) {
      console.log("keys of stimspec", _.keys(stimSpec));
      stim = buildStimulus(stimSpec, context);
      console.log("stim is", stim);
      return context.stimFactory.makeEvent(stim, stim, context);
    } else {
      response = buildResponse(responseSpec, context);
      return context.stimFactory.makeEvent(stim, response, context);
    }
  };

  buildTrial = function(eventSpec, record, context, feedback, background) {
    var events, key, response, responseSpec, stim, stimSpec, value;
    events = (function() {
      var _results1;
      _results1 = [];
      for (key in eventSpec) {
        value = eventSpec[key];
        stimSpec = _.omit(value, "Next");
        responseSpec = _.pick(value, "Next");
        stim = buildStimulus(stimSpec, context);
        response = buildResponse(responseSpec.Next, context);
        _results1.push(context.stimFactory.makeEvent(stim, response, context));
      }
      return _results1;
    })();
    return new Trial(events, record, feedback, background);
  };

  buildPrelude = function(preludeSpec, context) {
    var events, key, spec, value;
    console.log("building prelude");
    events = (function() {
      var _results1;
      _results1 = [];
      for (key in preludeSpec) {
        value = preludeSpec[key];
        spec = {};
        spec[key] = value;
        console.log("prelude spec", spec);
        _results1.push(buildEvent(spec, context));
      }
      return _results1;
    })();
    console.log("prelude events", events);
    return new Prelude(events);
  };

  exports.Presenter = Presenter = (function() {
    function Presenter(trialList, display, context) {
      this.trialList = trialList;
      this.display = display;
      this.context = context;
      this.trialBuilder = this.display.Trial;
      this.prelude = this.display.Prelude != null ? buildPrelude(this.display.Prelude, this.context) : new Prelude([]);
      this.blockEventBuilder = this.display.Block;
      console.log("prelude is", this.prelude);
    }

    Presenter.prototype.start = function() {
      var block, record, trialNum, trialSpec,
        _this = this;
      this.blockList = new BlockSeq((function() {
        var _j, _len, _ref1, _results1;
        _ref1 = this.trialList.blocks;
        _results1 = [];
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          block = _ref1[_j];
          _results1.push(new Block((function() {
            var _k, _ref2, _results2;
            _results2 = [];
            for (trialNum = _k = 0, _ref2 = block.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; trialNum = 0 <= _ref2 ? ++_k : --_k) {
              record = _.clone(block[trialNum]);
              record.$trialNumber = trialNum;
              trialSpec = this.trialBuilder(record);
              _results2.push(buildTrial(trialSpec.Events, record, this.context, trialSpec.Feedback));
            }
            return _results2;
          }).call(this)));
        }
        return _results1;
      }).call(this));
      return this.prelude.start(this.context).then(function() {
        return _this.blockList.start(_this.context);
      });
    };

    return Presenter;

  })();

  exports.Experiment = Experiment = (function() {
    function Experiment(designSpec, stimFactory) {
      this.designSpec = designSpec;
      this.stimFactory = stimFactory != null ? stimFactory : new MockStimFactory();
      this.design = new ExpDesign(this.designSpec);
      this.display = this.designSpec.Display;
      this.trialGenerator = this.display.Trial;
    }

    Experiment.prototype.buildStimulus = function(event, context) {
      var params, stimType;
      stimType = _.keys(event)[0];
      params = _.values(event)[0];
      return this.stimFactory.makeStimulus(stimType, params, context);
    };

    Experiment.prototype.buildEvent = function(event, context) {
      var params, responseType;
      responseType = _.keys(event)[0];
      params = _.values(event)[0];
      return this.stimFactory.makeResponse(responseType, params, context);
    };

    Experiment.prototype.buildTrial = function(eventSpec, record, context) {
      var events, key, response, responseSpec, stim, stimSpec, value;
      events = (function() {
        var _results1;
        _results1 = [];
        for (key in eventSpec) {
          value = eventSpec[key];
          stimSpec = _.omit(value, "Next");
          responseSpec = _.pick(value, "Next");
          stim = this.buildStimulus(stimSpec);
          response = this.buildResponse(responseSpec.Next);
          _results1.push(this.stimFactory.makeEvent(stim, response));
        }
        return _results1;
      }).call(this);
      return new Trial(events, record);
    };

    Experiment.prototype.start = function(context) {
      var i, record, trialList, trialSpec, trials;
      trials = this.design.fullDesign;
      console.log(trials.nrow());
      trialList = (function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (i = _j = 0, _ref1 = trials.nrow(); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          record = trials.record(i);
          record.$trialNumber = i;
          trialSpec = this.trialGenerator(record);
          _results1.push(this.buildTrial(trialSpec, record, context));
        }
        return _results1;
      }).call(this);
      return context.start(trialList);
    };

    return Experiment;

  })();

  exports.ConditionalSampler = ConditionalSampler = (function(_super) {
    __extends(ConditionalSampler, _super);

    ConditionalSampler.prototype.makeItemSubsets = function() {
      var ctable, i, indices, itemSets, j, keySet, levs, record;
      ctable = this.factorSpec.conditionTable;
      keySet = (function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (i = _j = 0, _ref1 = ctable.nrow(); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          record = ctable.record(i);
          levs = _.values(record);
          _results1.push(_.reduce(levs, (function(a, b) {
            return a + ":" + b;
          })));
        }
        return _results1;
      })();
      console.log(keySet);
      itemSets = (function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (i = _j = 0, _ref1 = ctable.nrow(); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          record = ctable.record(i);
          indices = this.itemMap.whichRow(record);
          _results1.push((function() {
            var _k, _len, _results2;
            _results2 = [];
            for (_k = 0, _len = indices.length; _k < _len; _k++) {
              j = indices[_k];
              _results2.push(this.items[j]);
            }
            return _results2;
          }).call(this));
        }
        return _results1;
      }).call(this);
      console.log(itemSets);
      return _.zipObject(keySet, itemSets);
    };

    function ConditionalSampler(items, itemMap, factorSpec) {
      var key, value, _ref1;
      this.items = items;
      this.itemMap = itemMap;
      this.factorSpec = factorSpec;
      this.keyMap = this.makeItemSubsets();
      this.conditions = _.keys(this.keyMap);
      this.samplerSet = {};
      _ref1 = this.keyMap;
      for (key in _ref1) {
        value = _ref1[key];
        this.samplerSet[key] = new ExhaustiveSampler(value);
      }
    }

    ConditionalSampler.prototype.take = function(n) {
      var keys;
      keys = repLen(this.conditions, n);
      return _.flatten(this.takeCondition(keys));
    };

    ConditionalSampler.prototype.takeCondition = function(keys) {
      var key, _j, _len, _results1;
      _results1 = [];
      for (_j = 0, _len = keys.length; _j < _len; _j++) {
        key = keys[_j];
        _results1.push(this.samplerSet[key].take(1));
      }
      return _results1;
    };

    return ConditionalSampler;

  })(Sampler);

  exports.VarSpec = VarSpec = (function() {
    function VarSpec() {}

    VarSpec.name = "";

    VarSpec.nblocks = 1;

    VarSpec.reps = 1;

    VarSpec.expanded = {};

    VarSpec.prototype.names = function() {
      return this.name;
    };

    VarSpec.prototype.ntrials = function() {
      return this.nblocks * this.reps;
    };

    VarSpec.prototype.valueAt = function(block, trial) {};

    return VarSpec;

  })();

  exports.FactorSpec = FactorSpec = (function(_super) {
    __extends(FactorSpec, _super);

    function FactorSpec(name, levels) {
      this.name = name;
      this.levels = levels;
      this.factorSet = {};
      this.factorSet[this.name] = this.levels;
      this.conditionTable = DataTable.expand(this.factorSet);
    }

    FactorSpec.prototype.cross = function(other) {
      return new CrossedFactorSpec(this.nblocks, this.reps, [this, other]);
    };

    FactorSpec.prototype.expand = function(nblocks, reps) {
      var blocks, concatBlocks, i, prop, vset, _j, _results1;
      prop = {};
      prop[this.name] = this.levels;
      vset = new DataTable(prop);
      blocks = (function() {
        var _j, _results1;
        _results1 = [];
        for (i = _j = 1; 1 <= nblocks ? _j <= nblocks : _j >= nblocks; i = 1 <= nblocks ? ++_j : --_j) {
          _results1.push(vset.replicate(reps));
        }
        return _results1;
      })();
      concatBlocks = _.reduce(blocks, function(sum, nex) {
        return DataTable.rbind(sum, nex);
      });
      concatBlocks.bindcol("$Block", rep((function() {
        _results1 = [];
        for (var _j = 1; 1 <= nblocks ? _j <= nblocks : _j >= nblocks; 1 <= nblocks ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this), rep(reps * vset.nrow(), nblocks)));
      return concatBlocks;
    };

    return FactorSpec;

  })(VarSpec);

  exports.CellTable = CellTable = (function(_super) {
    __extends(CellTable, _super);

    function CellTable(parents) {
      var fac;
      this.parents = parents;
      this.parentNames = (function() {
        var _j, _len, _ref1, _results1;
        _ref1 = this.parents;
        _results1 = [];
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          fac = _ref1[_j];
          _results1.push(fac.name);
        }
        return _results1;
      }).call(this);
      this.name = _.reduce(this.parentNames, function(n, n1) {
        return n + ":" + n1;
      });
      this.levels = (function() {
        var _j, _len, _ref1, _results1;
        _ref1 = this.parents;
        _results1 = [];
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          fac = _ref1[_j];
          _results1.push(fac.levels);
        }
        return _results1;
      }).call(this);
      this.factorSet = _.zipObject(this.parentNames, this.levels);
      this.table = DataTable.expand(this.factorSet);
    }

    CellTable.prototype.names = function() {
      return this.parentNames;
    };

    CellTable.prototype.conditions = function() {
      var i, rec, _j, _ref1, _results1;
      _results1 = [];
      for (i = _j = 0, _ref1 = this.table.nrow(); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        rec = this.table.record(i);
        _results1.push(_.reduce(rec, function(n, n1) {
          return n + ":" + n1;
        }));
      }
      return _results1;
    };

    CellTable.prototype.expand = function(nblocks, reps) {
      var blocks, i;
      return blocks = (function() {
        var _j, _results1;
        _results1 = [];
        for (i = _j = 1; 1 <= nblocks ? _j <= nblocks : _j >= nblocks; i = 1 <= nblocks ? ++_j : --_j) {
          _results1.push(this.table.replicate(reps));
        }
        return _results1;
      }).call(this);
    };

    return CellTable;

  })(VarSpec);

  exports.TaskNode = TaskNode = (function() {
    function TaskNode(varSpecs, crossedSet) {
      var i, vname, _j, _k, _l, _len, _len1, _ref1, _ref2, _ref3;
      this.varSpecs = varSpecs;
      this.crossedSet = crossedSet != null ? crossedSet : [];
      this.factorNames = _.map(this.varSpecs, function(x) {
        return x.names();
      });
      this.varmap = {};
      for (i = _j = 0, _ref1 = this.factorNames.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        this.varmap[this.factorNames[i]] = this.varSpecs[i];
      }
      if (this.crossedSet.length > 0) {
        _ref2 = this.crossedSet;
        for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
          vname = _ref2[_k];
          this.crossedVars = this.varmap[vname];
        }
        this.crossedSpec = new CrossedFactorSpec(this.crossedVars);
      } else {
        this.crossedVars = [];
        this.crossedSpec = {};
      }
      this.uncrossedVars = _.difference(this.factorNames, this.crossedSet);
      _ref3 = this.uncrossedVars;
      for (_l = 0, _len1 = _ref3.length; _l < _len1; _l++) {
        vname = _ref3[_l];
        this.uncrossedSpec = this.varmap[vname];
      }
      ({
        expand: function(nblocks, nreps) {
          var ctable;
          if (this.crossedVars.length > 0) {
            return ctable = this.crossedSpec.expand(nblocks, nreps);
          }
        }
      });
    }

    return TaskNode;

  })();

  exports.FactorNode = FactorNode = (function() {
    FactorNode.build = function(name, spec) {
      return new FactorNode(name, spec.levels);
    };

    function FactorNode(name, levels) {
      this.name = name;
      this.levels = levels;
      this.cellTable = new CellTable([this]);
    }

    return FactorNode;

  })();

  exports.FactorSetNode = FactorSetNode = (function() {
    FactorSetNode.build = function(spec) {
      var fnodes, key, value;
      fnodes = (function() {
        var _results1;
        _results1 = [];
        for (key in spec) {
          value = spec[key];
          _results1.push(FactorNode.build(key, value));
        }
        return _results1;
      })();
      return new FactorSetNode(fnodes);
    };

    function FactorSetNode(factors) {
      var i, _j, _ref1;
      this.factors = factors;
      this.factorNames = _.map(this.factors, function(x) {
        return x.name;
      });
      this.varmap = {};
      for (i = _j = 0, _ref1 = this.factorNames.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        this.varmap[this.factorNames[i]] = this.factors[i];
      }
      this.cellTable = new CellTable(this.factors);
      this.name = this.cellTable.name;
    }

    FactorSetNode.prototype.levels = function() {
      return this.cellTable.levels;
    };

    FactorSetNode.prototype.conditions = function() {
      return this.cellTable.conditions();
    };

    FactorSetNode.prototype.expand = function(nblocks, nreps) {
      return this.cellTable.expand(nblocks, nreps);
    };

    FactorSetNode.prototype.trialList = function(nblocks, nreps) {
      var blk, blocks, i, j, tlist, _j, _k, _ref1, _ref2;
      if (nblocks == null) {
        nblocks = 1;
      }
      if (nreps == null) {
        nreps = 1;
      }
      blocks = this.expand(nblocks, nreps);
      tlist = new TrialList(nblocks);
      for (i = _j = 0, _ref1 = blocks.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        blk = blocks[i];
        for (j = _k = 0, _ref2 = blk.nrow(); 0 <= _ref2 ? _k < _ref2 : _k > _ref2; j = 0 <= _ref2 ? ++_k : --_k) {
          tlist.add(i, blk.record(j));
        }
      }
      return tlist;
    };

    return FactorSetNode;

  })();

  exports.ItemNode = ItemNode = (function() {
    ItemNode.build = function(name, spec) {
      var attrs;
      attrs = new DataTable(spec.attributes);
      return new ItemNode(name, spec.items, attrs, spec.type);
    };

    function ItemNode(name, items, attributes, type) {
      this.name = name;
      this.items = items;
      this.attributes = attributes;
      this.type = type;
      if (this.items.length !== this.attributes.nrow()) {
        throw "Number of items must equal number of attributes";
      }
    }

    return ItemNode;

  })();

  exports.VariablesNode = VariablesNode = (function() {
    function VariablesNode(variables, crossed) {
      this.variables = variables != null ? variables : [];
      this.crossed = crossed != null ? crossed : [];
    }

    return VariablesNode;

  })();

  exports.TaskSchema = TaskSchema = (function() {
    TaskSchema.build = function(spec) {
      var key, schema, value;
      schema = {};
      for (key in spec) {
        value = spec[key];
        schema[key] = FactorSetNode.build(value);
      }
      return new TaskSchema(schema);
    };

    function TaskSchema(schema) {
      this.schema = schema;
    }

    TaskSchema.prototype.trialTypes = function() {
      return _.keys(this.schema);
    };

    TaskSchema.prototype.factors = function(type) {
      return this.schema[type];
    };

    return TaskSchema;

  })();

  exports.TrialList = TrialList = (function() {
    function TrialList(nblocks) {
      var i, _j;
      this.blocks = [];
      for (i = _j = 0; 0 <= nblocks ? _j < nblocks : _j > nblocks; i = 0 <= nblocks ? ++_j : --_j) {
        this.blocks.push([]);
      }
    }

    TrialList.prototype.add = function(block, trial, type) {
      if (type == null) {
        type = "main";
      }
      trial.$TYPE = type;
      return this.blocks[block].push(trial);
    };

    TrialList.prototype.get = function(block, trialNum) {
      return this.blocks[block][trialNum];
    };

    TrialList.prototype.getBlock = function(block) {
      return this.blocks[block];
    };

    TrialList.prototype.ntrials = function() {
      var nt;
      nt = _.map(this.blocks, function(b) {
        return b.length;
      });
      return _.reduce(nt, function(x0, x1) {
        return x0 + x1;
      });
    };

    TrialList.prototype.shuffle = function() {
      return this.blocks = _.map(this.blocks, function(blk) {
        return _.shuffle(blk);
      });
    };

    TrialList.prototype.blockIterator = function() {
      return new ArrayIterator(_.map(this.blocks, function(blk) {
        return new ArrayIterator(blk);
      }));
    };

    return TrialList;

  })();

  exports.Iterator = Iterator = (function() {
    function Iterator() {}

    Iterator.prototype.hasNext = function() {
      return false;
    };

    Iterator.prototype.next = function() {
      throw "empty iterator";
    };

    Iterator.prototype.map = function(f) {};

    return Iterator;

  })();

  exports.ArrayIterator = ArrayIterator = (function(_super) {
    __extends(ArrayIterator, _super);

    function ArrayIterator(arr) {
      this.arr = arr;
      this.cursor = 0;
      ({
        hasNext: function() {
          return this.cursor < this.arr.length;
        },
        next: function() {
          var ret;
          ret = this.arr[this.cursor];
          this.cursor = this.cursor + 1;
          return ret;
        },
        map: function(f) {
          return _.map(this.arr, function(el) {
            return f(el);
          });
        }
      });
    }

    return ArrayIterator;

  })(Iterator);

  exports.ExpDesign = ExpDesign = (function() {
    ExpDesign.blocks = 1;

    ExpDesign.validate = function(spec) {
      var des;
      if (!("Design" in spec)) {
        throw "Design is undefined";
      }
      des = spec["Design"];
      if (!("Variables" in des)) {
        throw "Variables is undefined";
      }
      if (!("Structure" in des)) {
        throw "Structure is undefined";
      }
      if (!("Items" in spec)) {
        throw "Items is undefined";
      }
    };

    ExpDesign.splitCrossedItems = function(itemSpec, crossedVariables) {
      var attrnames, conditionTable, i, indices, itemSets, j, keySet, levs, record, values;
      attrnames = crossedVariables.colnames();
      keySet = (function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (i = _j = 0, _ref1 = crossedVariables.nrow(); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          record = crossedVariables.record(i);
          levs = _.values(record);
          _results1.push(_.reduce(levs, (function(a, b) {
            return a + ":" + b;
          })));
        }
        return _results1;
      })();
      values = itemSpec["values"];
      conditionTable = new DataTable(_.pick(itemSpec, attrnames));
      itemSets = (function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (i = _j = 0, _ref1 = crossedVariables.nrow(); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          record = crossedVariables.record(i);
          indices = conditionTable.whichRow(record);
          _results1.push((function() {
            var _k, _len, _results2;
            _results2 = [];
            for (_k = 0, _len = indices.length; _k < _len; _k++) {
              j = indices[_k];
              _results2.push(values[j]);
            }
            return _results2;
          })());
        }
        return _results1;
      })();
      return _.zipObject(keySet, itemSets);
    };

    ExpDesign.prototype.init = function(spec) {
      this.design = spec["Design"];
      this.variables = this.design["Variables"];
      this.itemSpec = spec["Items"];
      this.structure = this.design["Structure"];
      this.factorNames = _.keys(this.variables);
      this.crossed = this.variables["Crossed"];
      return this.auxiliary = this.variables["Auxiliary"];
    };

    ExpDesign.prototype.initStructure = function() {
      if (this.structure["type"] === "Block") {
        if (!_.has(this.structure, "reps_per_block")) {
          this.structure["reps_per_block"] = 1;
        }
        this.reps_per_block = this.structure["reps_per_block"];
        return this.blocks = this.structure["blocks"];
      } else {
        this.reps_per_block = 1;
        return this.blocks = 1;
      }
    };

    ExpDesign.prototype.makeConditionalSampler = function(crossedSpec, crossedItems) {
      var crossedItemMap, crossedItemName, key;
      crossedItemName = _.keys(crossedItems)[0];
      console.log("names:", crossedSpec.names());
      crossedItemMap = (function() {
        var _j, _len, _ref1, _results1;
        _ref1 = crossedSpec.names();
        _results1 = [];
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          key = _ref1[_j];
          _results1.push(crossedItems[crossedItemName][key]);
        }
        return _results1;
      })();
      crossedItemMap = _.zipObject(_.keys(this.crossed), crossedItemMap);
      console.log("item map: ", crossedItemMap);
      return new ConditionalSampler(crossedItems[crossedItemName].values, new DataTable(crossedItemMap), crossedSpec);
    };

    ExpDesign.prototype.makeCrossedSpec = function(crossed, nblocks, nreps) {
      var factors, key, val;
      factors = (function() {
        var _results1;
        _results1 = [];
        for (key in crossed) {
          val = crossed[key];
          _results1.push(new FactorSpec(nblocks, nreps, key, val.levels));
        }
        return _results1;
      })();
      return crossed = new CrossedFactorSpec(nblocks, nreps, factors);
    };

    ExpDesign.prototype.makeFactorSpec = function(fac, nblocks, nreps) {
      return new FactorSpec(nblocks, nreps, _.keys(fac)[0], _.values(fac)[0]);
    };

    function ExpDesign(spec) {
      var crossedItems, crossedSampler;
      if (spec == null) {
        spec = {};
      }
      ExpDesign.validate(spec);
      this.init(spec);
      this.initStructure();
      this.crossedSpec = this.makeCrossedSpec(this.crossed, this.blocks, this.reps_per_block);
      crossedItems = this.itemSpec.Crossed;
      crossedSampler = this.makeConditionalSampler(this.crossedSpec, crossedItems);
      this.fullDesign = this.crossedSpec.expanded.bindcol(_.keys(crossedItems)[0], crossedSampler.take(this.crossedSpec.expanded.nrow()));
      console.log(this.crossedDesign);
    }

    return ExpDesign;

  })();

  sam = new GridSampler([1, 2, 3], [1, 2, 3]);

  console.log("grid", sam.take(5));

  des = {
    Design: {
      Blocks: [
        [
          {
            a: 1,
            b: 2,
            c: 3,
            a: 2,
            b: 3,
            c: 4
          }
        ], [
          {
            a: 5,
            b: 7,
            c: 6,
            a: 5,
            b: 7,
            c: 6
          }
        ]
      ]
    }
  };

  console.log(des.Blocks);

  prom = Q.fcall(function() {
    console.log("promise 1");
    return 1;
  });

  prom2 = prom.then(function(input) {
    console.log("input is", input);
    return input + 1;
  });

  prom3 = prom2.then(function(input) {
    console.log("input is", input);
    return input + 1;
  }).done();

  deferred = Q.defer();

  prom = deferred.promise;

  prom.then(function(x) {
    return console.log("resolved with", x);
  });

  deferred.resolve(44);

  exports.permute = permute;

  exports.rep = rep;

  exports.repLen = repLen;

  exports.clone = clone;

  exports.sample = sample;

  exports.buildStimulus = buildStimulus;

  exports.buildResponse = buildResponse;

  exports.buildEvent = buildEvent;

  exports.buildTrial = buildTrial;

  exports.buildPrelude = buildPrelude;

}).call(this);

/*
//@ sourceMappingURL=PsyCloud.map
*/
