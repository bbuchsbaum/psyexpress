// Generated by CoffeeScript 1.4.0
(function() {
  var ConditionalSampler, CrossedFactorSpec, DataTable, Event, ExhaustiveSampler, ExpDesign, Experiment, ExperimentContext, Factor, FactorSpec, MockStimFactory, Q, Sampler, StimFactory, Trial, UniformSampler, VarSpec, asArray, dt, rep, repLen, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('lodash');

  Q = require("q");

  asArray = function(value) {
    if (_.isArray(value)) {
      return value;
    } else if (_.isNumber(value) || _.isBoolean(value)) {
      return [value];
    } else {
      return _.toArray(value);
    }
  };

  rep = function(vec, times) {
    var el, i, j, out,
      _this = this;
    if (!(times instanceof Array)) {
      times = [times];
    }
    if (times.length !== 1 && vec.length !== times.length) {
      console.log("vec", vec);
      console.log("times", times);
      throw "vec.length must equal times.length or times.length must be 1";
    }
    if (vec.length === times.length) {
      out = (function() {
        var _i, _len, _results;
        _results = [];
        for (i = _i = 0, _len = vec.length; _i < _len; i = ++_i) {
          el = vec[i];
          _results.push((function() {
            var _j, _ref, _results1;
            _results1 = [];
            for (j = _j = 1, _ref = times[i]; 1 <= _ref ? _j <= _ref : _j >= _ref; j = 1 <= _ref ? ++_j : --_j) {
              _results1.push(el);
            }
            return _results1;
          })());
        }
        return _results;
      })();
      return _.flatten(out);
    } else {
      out = _.times(times[0], function(n) {
        return vec;
      });
      return _.flatten(out);
    }
  };

  repLen = function(vec, length) {
    var i, _i, _results;
    if (length < 1) {
      throw "repLen: length must be greater than or equal to 1";
    }
    _results = [];
    for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
      _results.push(vec[i % vec.length]);
    }
    return _results;
  };

  exports.rep = rep;

  exports.repLen = repLen;

  exports.Sampler = Sampler = (function() {

    function Sampler(items) {
      this.items = items;
    }

    Sampler.prototype.take = function(n) {
      if (n > this.items.length) {
        throw "cannot take sample larger than the number of items when using non-replacing sampler";
      }
      return _.shuffle(this.items).slice(0, n);
    };

    return Sampler;

  })();

  exports.ExhaustiveSampler = ExhaustiveSampler = (function() {

    ExhaustiveSampler.fillBuffer = function(items, n) {
      var buf, i;
      buf = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
          _results.push(_.shuffle(items));
        }
        return _results;
      })();
      return _.flatten(buf);
    };

    function ExhaustiveSampler(items, buflen) {
      this.items = items;
      if (buflen == null) {
        buflen = 10;
      }
      this.buffer = ExhaustiveSampler.fillBuffer(this.items, buflen);
    }

    ExhaustiveSampler.prototype.take = function(n) {
      var buf, buflen, res;
      if (n <= this.buffer.length) {
        res = _.take(this.buffer, n);
        this.buffer = _.drop(this.buffer, n);
        return res;
      } else {
        buflen = Math.max(n, 10 * this.items.length);
        buf = ExhaustiveSampler.fillBuffer(this.items, buflen / this.items.length);
        this.buffer = this.buffer.concat(buf);
        return this.take(n);
      }
    };

    return ExhaustiveSampler;

  })();

  exports.UniformSampler = UniformSampler = (function(_super) {

    __extends(UniformSampler, _super);

    UniformSampler.validate = function(range) {
      if (range.length !== 2) {
        throw "range must be an array with two values (min, max)";
      }
      if (range[1] <= range[0]) {
        throw "range[1] must > range[0]";
      }
    };

    function UniformSampler(range) {
      this.range = range;
      this.interval = this.range[1] - this.range[0];
    }

    UniformSampler.prototype.take = function(n) {
      var i, nums;
      nums = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
          _results.push(Math.round(Math.random() * this.interval));
        }
        return _results;
      }).call(this);
      return nums;
    };

    return UniformSampler;

  })(Sampler);

  exports.Factor = Factor = (function(_super) {

    __extends(Factor, _super);

    Factor.asFactor = function(arr) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Factor, arr, function(){});
    };

    function Factor(arr) {
      var arg, _i, _len;
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        arg = arr[_i];
        this.push(arg);
      }
      this.levels = _.uniq(arr).sort();
    }

    return Factor;

  })(Array);

  exports.DataTable = DataTable = (function() {

    DataTable.prototype.show = function() {
      var i, _i, _ref, _results;
      console.log("DataTable: rows: " + (this.nrow()) + " columns: " + (this.ncol()));
      _results = [];
      for (i = _i = 0, _ref = this.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(console.log(this.record(i)));
      }
      return _results;
    };

    DataTable.fromRecords = function(records, joinAll) {
      var allkeys, key, rec, vars, _i, _j, _k, _len, _len1, _len2;
      if (joinAll == null) {
        joinAll = true;
      }
      allkeys = _.uniq(_.flatten(_.map(records, function(rec) {
        return _.keys(rec);
      })));
      console.log(allkeys);
      vars = {};
      for (_i = 0, _len = allkeys.length; _i < _len; _i++) {
        key = allkeys[_i];
        vars[key] = [];
      }
      console.log(vars);
      for (_j = 0, _len1 = records.length; _j < _len1; _j++) {
        rec = records[_j];
        for (_k = 0, _len2 = allkeys.length; _k < _len2; _k++) {
          key = allkeys[_k];
          vars[key].push(rec[key] || null);
        }
      }
      return new DataTable(vars);
    };

    DataTable.build = function(vars) {
      if (vars == null) {
        vars = {};
      }
      return Object.seal(new DataTable(vars));
    };

    DataTable.rbind = function(tab1, tab2) {
      var keys1, keys2, name, out, sharedKeys, _i, _len;
      keys1 = _.keys(tab1);
      keys2 = _.keys(tab2);
      sharedKeys = _.intersection(keys1, keys2);
      out = {};
      for (_i = 0, _len = sharedKeys.length; _i < _len; _i++) {
        name = sharedKeys[_i];
        out[name] = tab1[name].concat(tab2[name]);
      }
      return new DataTable(out);
    };

    DataTable.cbind = function(tab1, tab2) {
      var diffkeys, key, out, _i, _len;
      if (tab1.nrow() !== tab2.nrow()) {
        throw "cbind requires arguments to have same number of rows";
      }
      out = _.cloneDeep(tab1);
      diffkeys = _.difference(_.keys(tab2), _.keys(tab1));
      for (_i = 0, _len = diffkeys.length; _i < _len; _i++) {
        key = diffkeys[_i];
        out[key] = tab2[key];
      }
      return out;
    };

    DataTable.expand = function(vars, unique, nreps) {
      var d, i, key, name, nargs, nm, nx, orep, out, r1, r2, r3, repfac, value, _i, _results;
      if (vars == null) {
        vars = {};
      }
      if (unique == null) {
        unique = true;
      }
      if (nreps == null) {
        nreps = 1;
      }
      if (unique) {
        out = {};
        for (name in vars) {
          value = vars[name];
          out[name] = _.unique(value);
        }
        vars = out;
      }
      nargs = _.size(vars);
      nm = _.keys(vars);
      repfac = 1;
      d = _.map(vars, function(x) {
        return x.length;
      });
      orep = _.reduce(d, function(x, acc) {
        return x * acc;
      });
      out = {};
      for (key in vars) {
        value = vars[key];
        nx = value.length;
        orep = orep / nx;
        r1 = rep([repfac], nx);
        r2 = rep((function() {
          _results = [];
          for (var _i = 0; 0 <= nx ? _i < nx : _i > nx; 0 <= nx ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this), r1);
        r3 = rep(r2, orep);
        out[key] = (function() {
          var _j, _len, _results1;
          _results1 = [];
          for (_j = 0, _len = r3.length; _j < _len; _j++) {
            i = r3[_j];
            _results1.push(value[i]);
          }
          return _results1;
        })();
        repfac = repfac * nx;
      }
      return new DataTable(out);
    };

    function DataTable(vars) {
      var key, samelen, value, varlen;
      if (vars == null) {
        vars = {};
      }
      varlen = _.map(vars, function(x) {
        return x.length;
      });
      samelen = _.all(varlen, function(x) {
        return x === varlen[0];
      });
      if (!samelen) {
        throw "arguments to DataTable must all have same length.";
      }
      for (key in vars) {
        value = vars[key];
        this[key] = value;
      }
    }

    DataTable.prototype.subset = function(key, filter) {
      var el, i, keep, name, out, val, value;
      keep = (function() {
        var _i, _len, _ref, _results;
        _ref = this[key];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          val = _ref[_i];
          if (filter(val)) {
            _results.push(true);
          } else {
            _results.push(false);
          }
        }
        return _results;
      }).call(this);
      out = {};
      for (name in this) {
        if (!__hasProp.call(this, name)) continue;
        value = this[name];
        out[name] = (function() {
          var _i, _len, _results;
          _results = [];
          for (i = _i = 0, _len = value.length; _i < _len; i = ++_i) {
            el = value[i];
            if (keep[i] === true) {
              _results.push(el);
            }
          }
          return _results;
        })();
      }
      return new DataTable(out);
    };

    DataTable.prototype.whichRow = function(where) {
      var count, i, key, nkeys, out, rec, value, _i, _ref;
      out = [];
      nkeys = _.keys(where).length;
      for (i = _i = 0, _ref = this.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        rec = this.record(i);
        count = asArray((function() {
          var _results;
          _results = [];
          for (key in where) {
            value = where[key];
            _results.push(rec[key] === value);
          }
          return _results;
        })());
        count = _.map(count, function(x) {
          if (x) {
            return 1;
          } else {
            return 0;
          }
        });
        count = _.reduce(asArray(count), function(sum, num) {
          return sum + num;
        });
        if (count === nkeys) {
          out.push(i);
        }
      }
      return out;
    };

    DataTable.prototype.select = function(where) {
      var count, i, key, nkeys, out, rec, value, _i, _ref;
      out = [];
      nkeys = _.keys(where).length;
      for (i = _i = 0, _ref = this.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        rec = this.record(i);
        count = asArray((function() {
          var _results;
          _results = [];
          for (key in where) {
            value = where[key];
            _results.push(rec[key] === value);
          }
          return _results;
        })());
        count = _.map(count, function(x) {
          if (x) {
            return 1;
          } else {
            return 0;
          }
        });
        count = _.reduce(asArray(count), function(sum, num) {
          return sum + num;
        });
        if (count === nkeys) {
          out.push(rec);
        }
      }
      return out;
    };

    DataTable.prototype.nrow = function() {
      var lens, name, value;
      lens = (function() {
        var _results;
        _results = [];
        for (name in this) {
          if (!__hasProp.call(this, name)) continue;
          value = this[name];
          _results.push(value.length);
        }
        return _results;
      }).call(this);
      return _.max(lens);
    };

    DataTable.prototype.ncol = function() {
      return Object.keys(this).length;
    };

    DataTable.prototype.colnames = function() {
      return Object.keys(this);
    };

    DataTable.prototype.record = function(index) {
      var name, rec, value;
      rec = {};
      for (name in this) {
        if (!__hasProp.call(this, name)) continue;
        value = this[name];
        rec[name] = value[index];
      }
      return rec;
    };

    DataTable.prototype.replicate = function(nreps) {
      var name, out, value,
        _this = this;
      out = {};
      for (name in this) {
        if (!__hasProp.call(this, name)) continue;
        value = this[name];
        out[name] = _.flatten(_.times(nreps, function(n) {
          return value;
        }));
      }
      return new DataTable(out);
    };

    DataTable.prototype.bindcol = function(name, column) {
      if (column.length !== this.nrow()) {
        throw "new column must be same length as existing DataTable object: column.length is  " + column.length + " and this.length is  " + (this.nrow());
      }
      this[name] = column;
      return this;
    };

    DataTable.prototype.bindrow = function(rows) {
      var key, record, value, _i, _len;
      if (!_.isArray(rows)) {
        rows = [rows];
      }
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        record = rows[_i];
        console.log(record);
        for (key in record) {
          if (!__hasProp.call(record, key)) continue;
          value = record[key];
          if (!_.has(this, key)) {
            throw "DataTable has no field named " + key;
          } else {
            this[key].push(value);
          }
        }
      }
      return this;
    };

    return DataTable;

  })();

  exports.StimFactory = StimFactory = (function() {

    function StimFactory() {}

    StimFactory.prototype.makeStimulus = function(name, params) {};

    StimFactory.prototype.makeResponse = function(name, params) {};

    StimFactory.prototype.makeEvent = function(stim, response) {};

    return StimFactory;

  })();

  exports.MockStimFactory = MockStimFactory = (function(_super) {

    __extends(MockStimFactory, _super);

    function MockStimFactory() {
      return MockStimFactory.__super__.constructor.apply(this, arguments);
    }

    MockStimFactory.prototype.makeStimulus = function(name, params) {
      var ret;
      ret = {};
      ret[name] = params;
      return ret;
    };

    MockStimFactory.prototype.makeResponse = function(name, params) {
      var ret;
      ret = {};
      ret[name] = params;
      return ret;
    };

    MockStimFactory.prototype.makeEvent = function(stim, response) {
      return [stim, response];
    };

    return MockStimFactory;

  })(StimFactory);

  exports.Event = Event = (function() {

    function Event(stimulus, response) {
      this.stimulus = stimulus;
      this.response = response;
    }

    Event.prototype.start = function(context) {
      var _this = this;
      console.log("starting event", this.stimulus);
      if (!this.stimulus.overlay) {
        context.clearContent();
      }
      console.log("rendering event");
      this.stimulus.render(context, context.contentLayer);
      context.draw();
      console.log("activating response");
      return this.response.activate(context).then(function(ret) {
        _this.stimulus.stop();
        return ret;
      });
    };

    return Event;

  })();

  exports.Trial = Trial = (function() {

    function Trial(events, meta, background) {
      this.events = events != null ? events : [];
      this.meta = meta != null ? meta : {};
      this.background = background;
    }

    Trial.prototype.numEvents = function() {
      return this.events.length;
    };

    Trial.prototype.push = function(event) {
      return this.events.push(event);
    };

    Trial.prototype.start = function(context) {
      var farray, fun, result, _i, _len,
        _this = this;
      console.log("starting trial");
      context.clearBackground();
      if (this.background) {
        context.setBackground(this.background);
        context.drawBackground();
      }
      farray = _.map(this.events, function(ev) {
        return function() {
          return ev.start(context);
        };
      });
      result = Q.resolve(0);
      for (_i = 0, _len = farray.length; _i < _len; _i++) {
        fun = farray[_i];
        result = result.then(fun);
      }
      return result;
    };

    return Trial;

  })();

  exports.ExperimentContext = ExperimentContext = (function() {

    function ExperimentContext() {}

    ExperimentContext.prototype.eventLog = [];

    ExperimentContext.prototype.trialNumber = 0;

    ExperimentContext.prototype.currentTrial = {};

    ExperimentContext.prototype.logEvent = function(key, value) {
      var record;
      console.log("logging event");
      record = _.clone(this.currentTrial.meta);
      record[key] = value;
      this.eventLog.push(record);
      return console.log(this.eventLog);
    };

    ExperimentContext.prototype.start = function(trialList) {
      var fun, funList, result, _i, _len, _results,
        _this = this;
      funList = _.map(trialList, function(trial) {
        return function() {
          _this.trialNumber += 1;
          _this.currentTrial = trial;
          return trial.start(_this);
        };
      });
      result = Q.resolve(0);
      _results = [];
      for (_i = 0, _len = funList.length; _i < _len; _i++) {
        fun = funList[_i];
        console.log("building trial list");
        _results.push(result = result.then(fun));
      }
      return _results;
    };

    ExperimentContext.prototype.clearContent = function() {};

    ExperimentContext.prototype.clearBackground = function() {};

    ExperimentContext.prototype.keydownStream = function() {};

    ExperimentContext.prototype.keypressStream = function() {};

    ExperimentContext.prototype.mousepressStream = function() {};

    ExperimentContext.prototype.draw = function() {};

    return ExperimentContext;

  })();

  exports.Experiment = Experiment = (function() {

    function Experiment(designSpec, stimFactory) {
      this.designSpec = designSpec;
      this.stimFactory = stimFactory != null ? stimFactory : new MockStimFactory();
      this.design = new ExpDesign(this.designSpec);
      this.display = this.designSpec.Display;
      this.trialGenerator = this.display.Trial;
    }

    Experiment.prototype.buildStimulus = function(event) {
      var params, stimType;
      stimType = _.keys(event)[0];
      params = _.values(event)[0];
      return this.stimFactory.makeStimulus(stimType, params);
    };

    Experiment.prototype.buildEvent = function(event) {
      var params, responseType;
      responseType = _.keys(event)[0];
      params = _.values(event)[0];
      return this.stimFactory.makeResponse(responseType, params);
    };

    Experiment.prototype.buildTrial = function(eventSpec, record) {
      var events, key, response, responseSpec, stim, stimSpec, value;
      events = (function() {
        var _results;
        _results = [];
        for (key in eventSpec) {
          value = eventSpec[key];
          stimSpec = _.omit(value, "Next");
          responseSpec = _.pick(value, "Next");
          stim = this.buildStimulus(stimSpec);
          response = this.buildEvent(responseSpec.Next);
          _results.push(this.stimFactory.makeEvent(stim, response));
        }
        return _results;
      }).call(this);
      return new Trial(events, record);
    };

    Experiment.prototype.start = function(context) {
      var i, record, trialList, trialSpec, trials;
      trials = this.design.fullDesign;
      console.log(trials.nrow());
      trialList = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = trials.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          record = trials.record(i);
          record.$trialNumber = i;
          trialSpec = this.trialGenerator(record);
          _results.push(this.buildTrial(trialSpec, record));
        }
        return _results;
      }).call(this);
      return context.start(trialList);
    };

    return Experiment;

  })();

  exports.ConditionalSampler = ConditionalSampler = (function(_super) {

    __extends(ConditionalSampler, _super);

    ConditionalSampler.prototype.makeItemSubsets = function() {
      var ctable, i, indices, itemSets, j, keySet, levs, record;
      ctable = this.factorSpec.conditionTable;
      keySet = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = ctable.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          record = ctable.record(i);
          levs = _.values(record);
          _results.push(_.reduce(levs, (function(a, b) {
            return a + ":" + b;
          })));
        }
        return _results;
      })();
      console.log(keySet);
      itemSets = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = ctable.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          record = ctable.record(i);
          indices = this.itemMap.whichRow(record);
          _results.push((function() {
            var _j, _len, _results1;
            _results1 = [];
            for (_j = 0, _len = indices.length; _j < _len; _j++) {
              j = indices[_j];
              _results1.push(this.items[j]);
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }).call(this);
      console.log(itemSets);
      return _.zipObject(keySet, itemSets);
    };

    function ConditionalSampler(items, itemMap, factorSpec) {
      var key, value, _ref;
      this.items = items;
      this.itemMap = itemMap;
      this.factorSpec = factorSpec;
      this.keyMap = this.makeItemSubsets();
      this.conditions = _.keys(this.keyMap);
      this.samplerSet = {};
      _ref = this.keyMap;
      for (key in _ref) {
        value = _ref[key];
        this.samplerSet[key] = new ExhaustiveSampler(value);
      }
    }

    ConditionalSampler.prototype.take = function(n) {
      var keys;
      keys = repLen(this.conditions, n);
      return _.flatten(this.takeCondition(keys));
    };

    ConditionalSampler.prototype.takeCondition = function(keys) {
      var key, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        key = keys[_i];
        _results.push(this.samplerSet[key].take(1));
      }
      return _results;
    };

    return ConditionalSampler;

  })(Sampler);

  exports.VarSpec = VarSpec = (function() {

    function VarSpec() {}

    VarSpec.name = "";

    VarSpec.nblocks = 1;

    VarSpec.reps = 1;

    VarSpec.expanded = {};

    VarSpec.prototype.ntrials = function() {
      return this.nblocks * this.reps;
    };

    VarSpec.prototype.valueAt = function(block, trial) {};

    return VarSpec;

  })();

  exports.FactorSpec = FactorSpec = (function(_super) {

    __extends(FactorSpec, _super);

    function FactorSpec(nblocks, reps, name, levels) {
      this.nblocks = nblocks;
      this.reps = reps;
      this.name = name;
      this.levels = levels;
      console.log(this.name);
      console.log(this.levels);
      this.factorSet = {};
      this.factorSet[this.name] = this.levels;
      this.conditionTable = DataTable.expand(this.factorSet);
      this.expanded = this.expand(this.nblocks, this.reps);
    }

    FactorSpec.prototype.cross = function(other) {
      return new CrossedFactorSpec(this.nblocks, this.reps, [this, other]);
    };

    FactorSpec.prototype.names = function() {
      return this.name;
    };

    FactorSpec.prototype.expand = function(nblocks, reps) {
      var blocks, concatBlocks, i, prop, vset, _i, _results;
      prop = {};
      prop[this.name] = this.levels;
      vset = new DataTable(prop);
      blocks = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; 1 <= nblocks ? _i <= nblocks : _i >= nblocks; i = 1 <= nblocks ? ++_i : --_i) {
          _results.push(vset.replicate(reps));
        }
        return _results;
      })();
      concatBlocks = _.reduce(blocks, function(sum, nex) {
        return DataTable.rbind(sum, nex);
      });
      concatBlocks.bindcol("BLOCK", rep((function() {
        _results = [];
        for (var _i = 1; 1 <= nblocks ? _i <= nblocks : _i >= nblocks; 1 <= nblocks ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this), rep(reps * vset.nrow(), nblocks)));
      return concatBlocks;
    };

    FactorSpec.prototype.valueAt = function(block, trial) {
      return this.expanded[block][this.name][trial];
    };

    return FactorSpec;

  })(VarSpec);

  exports.CrossedFactorSpec = CrossedFactorSpec = (function(_super) {

    __extends(CrossedFactorSpec, _super);

    function CrossedFactorSpec(nblocks, reps, parents) {
      var fac;
      this.nblocks = nblocks;
      this.reps = reps;
      this.parents = parents;
      this.parentNames = (function() {
        var _i, _len, _ref, _results;
        _ref = this.parents;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fac = _ref[_i];
          _results.push(fac.name);
        }
        return _results;
      }).call(this);
      this.name = _.reduce(this.parentNames, function(n, n1) {
        return n + ":" + n1;
      });
      this.levels = (function() {
        var _i, _len, _ref, _results;
        _ref = this.parents;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fac = _ref[_i];
          _results.push(fac.levels);
        }
        return _results;
      }).call(this);
      this.factorSet = _.zipObject(this.parentNames, this.levels);
      this.conditionTable = DataTable.expand(this.factorSet);
      this.expanded = this.expand(this.nblocks, this.reps);
    }

    CrossedFactorSpec.prototype.names = function() {
      return this.parentNames;
    };

    CrossedFactorSpec.prototype.expand = function(nblocks, reps) {
      var blocks, concatBlocks, i, _i, _results;
      blocks = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; 1 <= nblocks ? _i <= nblocks : _i >= nblocks; i = 1 <= nblocks ? ++_i : --_i) {
          _results.push(this.conditionTable.replicate(reps));
        }
        return _results;
      }).call(this);
      concatBlocks = _.reduce(blocks, function(sum, nex) {
        return DataTable.rbind(sum, nex);
      });
      concatBlocks.bindcol("BLOCK", rep((function() {
        _results = [];
        for (var _i = 1; 1 <= nblocks ? _i <= nblocks : _i >= nblocks; 1 <= nblocks ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this), rep(reps * this.conditionTable.nrow(), nblocks)));
      return concatBlocks;
    };

    CrossedFactorSpec.prototype.valueAt = function(block, trial) {
      var name, _i, _len, _ref, _results;
      _ref = this.parentNames;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        _results.push(this.expanded[block][name][trial]);
      }
      return _results;
    };

    return CrossedFactorSpec;

  })(VarSpec);

  exports.ExpDesign = ExpDesign = (function() {

    ExpDesign.blocks = 1;

    ExpDesign.validate = function(spec) {
      var des;
      if (!("Design" in spec)) {
        throw "Design is undefined";
      }
      des = spec["Design"];
      if (!("Variables" in des)) {
        throw "Variables is undefined";
      }
      if (!("Structure" in des)) {
        throw "Structure is undefined";
      }
      if (!("Items" in spec)) {
        throw "Items is undefined";
      }
    };

    ExpDesign.splitCrossedItems = function(itemSpec, crossedVariables) {
      var attrnames, conditionTable, i, indices, itemSets, j, keySet, levs, record, values;
      attrnames = crossedVariables.colnames();
      keySet = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = crossedVariables.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          record = crossedVariables.record(i);
          levs = _.values(record);
          _results.push(_.reduce(levs, (function(a, b) {
            return a + ":" + b;
          })));
        }
        return _results;
      })();
      values = itemSpec["values"];
      conditionTable = new DataTable(_.pick(itemSpec, attrnames));
      itemSets = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = crossedVariables.nrow(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          record = crossedVariables.record(i);
          indices = conditionTable.whichRow(record);
          _results.push((function() {
            var _j, _len, _results1;
            _results1 = [];
            for (_j = 0, _len = indices.length; _j < _len; _j++) {
              j = indices[_j];
              _results1.push(values[j]);
            }
            return _results1;
          })());
        }
        return _results;
      })();
      return _.zipObject(keySet, itemSets);
    };

    ExpDesign.prototype.init = function(spec) {
      this.design = spec["Design"];
      this.variables = this.design["Variables"];
      this.itemSpec = spec["Items"];
      this.structure = this.design["Structure"];
      this.varnames = _.keys(this.variables);
      this.crossed = this.variables["Crossed"];
      return this.auxiliary = this.variables["Auxiliary"];
    };

    ExpDesign.prototype.initStructure = function() {
      if (this.structure["type"] === "Block") {
        if (!_.has(this.structure, "reps_per_block")) {
          this.structure["reps_per_block"] = 1;
        }
        this.reps_per_block = this.structure["reps_per_block"];
        return this.blocks = this.structure["blocks"];
      } else {
        this.reps_per_block = 1;
        return this.blocks = 1;
      }
    };

    ExpDesign.prototype.makeConditionalSampler = function(crossedSpec, crossedItems) {
      var crossedItemMap, crossedItemName, key;
      crossedItemName = _.keys(crossedItems)[0];
      console.log("names:", crossedSpec.names());
      crossedItemMap = (function() {
        var _i, _len, _ref, _results;
        _ref = crossedSpec.names();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          _results.push(crossedItems[crossedItemName][key]);
        }
        return _results;
      })();
      crossedItemMap = _.zipObject(_.keys(this.crossed), crossedItemMap);
      console.log("item map: ", crossedItemMap);
      return new ConditionalSampler(crossedItems[crossedItemName].values, new DataTable(crossedItemMap), crossedSpec);
    };

    ExpDesign.prototype.makeCrossedSpec = function(crossed, nblocks, nreps) {
      var factors, key, val;
      factors = (function() {
        var _results;
        _results = [];
        for (key in crossed) {
          val = crossed[key];
          _results.push(new FactorSpec(nblocks, nreps, key, val.levels));
        }
        return _results;
      })();
      return crossed = new CrossedFactorSpec(nblocks, nreps, factors);
    };

    ExpDesign.prototype.makeFactorSpec = function(fac, nblocks, nreps) {
      return new FactorSpec(nblocks, nreps, _.keys(fac)[0], _.values(fac)[0]);
    };

    function ExpDesign(spec) {
      var crossedItems, crossedSampler;
      if (spec == null) {
        spec = {};
      }
      ExpDesign.validate(spec);
      this.init(spec);
      this.initStructure();
      this.crossedSpec = this.makeCrossedSpec(this.crossed, this.blocks, this.reps_per_block);
      crossedItems = this.itemSpec.Crossed;
      crossedSampler = this.makeConditionalSampler(this.crossedSpec, crossedItems);
      this.fullDesign = this.crossedSpec.expanded.bindcol(_.keys(crossedItems)[0], crossedSampler.take(this.crossedSpec.expanded.nrow()));
      console.log(this.crossedDesign);
    }

    return ExpDesign;

  })();

  dt = new DataTable.fromRecords([
    {
      a: 1,
      b: 2
    }, {
      c: 1,
      d: 2,
      a: 88
    }
  ]);

  dt = new DataTable.fromRecords([
    {
      a: 1,
      b: 2
    }
  ]);

  dt.show();

}).call(this);
